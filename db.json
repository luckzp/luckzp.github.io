{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/alipay.jpg","path":"images/alipay.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"source/images/profile.jpg","path":"images/profile.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1596957705673},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1596957705673},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1596957705673},{"_id":"themes/next/.gitignore","hash":"0378adb9c2dc4855b3198184df4863cb30e4059c","modified":1596957705681},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1596957705684},{"_id":"themes/next/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1596957705684},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1596957705685},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1596957705686},{"_id":"themes/next/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1596957705688},{"_id":"themes/next/LICENSE.md","hash":"f0190c7d83a98464549a6b3a51bb206148d88e1b","modified":1596957705689},{"_id":"themes/next/README.md","hash":"eafc2f2e1d966e27835449970bc60f0f7d5a8f0b","modified":1596957705691},{"_id":"themes/next/_config.yml","hash":"b4d99fee8dce2bed96e134e25559cf1b58bf238f","modified":1596959468056},{"_id":"themes/next/bower.json","hash":"38a620a57d97340e0eea0d7ce5675c7974ac3da5","modified":1596957705693},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1596957705707},{"_id":"themes/next/package.json","hash":"30e43ab2f4ab4bbb2d0ad95c361b2c6ae8957322","modified":1596957705778},{"_id":"source/_discarded/Spring学习笔记2.md","hash":"8f48c6a7efeb77fdd32b7ea9788c6c7244134683","modified":1596950653269},{"_id":"source/_discarded/Untitled.md","hash":"c15a45d194fc22542da44ca4c0d68ce66de96849","modified":1596950653270},{"_id":"source/_discarded/ajax学习.md","hash":"efcfcf026bf45ef9f11613730f7af2e5b0a95c9d","modified":1596950653271},{"_id":"source/_discarded/pictureTest.md","hash":"64a202385218f4a521c7916e002a55cb9d64de02","modified":1596950653271},{"_id":"source/_discarded/出生啊.md","hash":"c3ae07316b2fb2639f9cbfbeb9016a80807a8083","modified":1596950653272},{"_id":"source/_discarded/十八回想.md","hash":"7b7bb095f19c5a969f71a725291b484565326262","modified":1596950653272},{"_id":"source/_drafts/自我提升总结.md","hash":"c614d79c02f1154b59c1571661b4da670ed46552","modified":1596950653273},{"_id":"source/_posts/01背包和完全背包问题.md","hash":"20b874daee027e2e324b1ffd575e854fb4519e0a","modified":1596950653274},{"_id":"source/_posts/2019年年终总结.md","hash":"cd74ace2b70a4b674b5466660468386ace4924f3","modified":1596950653275},{"_id":"source/_posts/Bean生命周期和SpringMVC的工作原理.md","hash":"edbbc5c808fccb034a3049d67888f8083638d587","modified":1596950653275},{"_id":"source/_posts/ELK初识.md","hash":"c90757f6aeec6a5a196e705b1aac577ade71874d","modified":1596950653279},{"_id":"source/_posts/Join工作原理.md","hash":"e6ce7695e7ac9337294a198469a77ec5e8c8c784","modified":1596950653287},{"_id":"source/_posts/Mysql中的B+树.md","hash":"0d53dd16204158ebaf80f9212c079805e9348ac6","modified":1596950653287},{"_id":"source/_posts/Mysql实战-学习笔记(1).md","hash":"d62698322db852d497b3d6ab74ebcec2b92f8840","modified":1596950653288},{"_id":"source/_posts/Mysql实战-学习笔记(2).md","hash":"efa957568d9c96f3bd0fa386a0f33fc86822b7e3","modified":1596950653289},{"_id":"source/_posts/NIO初识.md","hash":"e72efdb1cc5772d07259784064da7f70a3ab3543","modified":1596950653289},{"_id":"source/_posts/OKR学习.md","hash":"61c697e615813301fab1ec066c610e315c57f72a","modified":1596950653290},{"_id":"source/_posts/TCP的拥塞控制机制.md","hash":"e1ca9466d0023f1f90a4a6efa7a9a5a7f7000bc2","modified":1596950653290},{"_id":"source/_posts/出生.md","hash":"bbf3d74f41a447409897539575334cb650ff3555","modified":1596950653292},{"_id":"source/_posts/单体到微服务.md","hash":"ac8fcd73a4a4976f4e30c1a84615ef95c3818cf6","modified":1596950653294},{"_id":"source/_posts/快排里的Partition应用-找第K大的数字 .md","hash":"e934f276ac5d5e04c1e720b90d30257b704ec20f","modified":1596950653295},{"_id":"source/_posts/操作系统.md","hash":"0a6cf170645ce3a1603cc4f3246cbddc77759756","modified":1596950653295},{"_id":"source/_posts/校招笔试题目总结(二).md","hash":"9d43e2bfb9bd8dd926a7f2ab91ea7a0f186586ce","modified":1596950653296},{"_id":"source/_posts/校招笔试题目总结（一）.md","hash":"4f0121c4e00e8fa5a1f635e041a469822d96e6c0","modified":1596950653297},{"_id":"source/_posts/泛型类与泛型方法.md","hash":"0c5046d19e70287de49536ba14d6fd5ada2ca4de","modified":1596950653297},{"_id":"source/_posts/编程笔面试题.md","hash":"300e1a77f9d0ce72f3a9f7ad5ac3d6de39ddde72","modified":1596950653299},{"_id":"source/_posts/自我提升总结.md","hash":"f347202a50313ea3dc0e3f6ed5cc22b0ea3bd173","modified":1596950653299},{"_id":"source/_posts/计算机网络面试题.md","hash":"0f6624d86b49a90090a6a4fc02072e655d9cfb2e","modified":1596950653301},{"_id":"source/_posts/财务分析和决策.md","hash":"0060828af842750443edde5e313bbdfc2f7f694b","modified":1596950653303},{"_id":"source/_posts/领域驱动设计（DDD）.md","hash":"eda1a9486fc9652160d65f49a2b53b6b4a97477d","modified":1596950653303},{"_id":"source/about/index.md","hash":"8eb1d26cbfaf99a51bb8aa7ed585fffbb6feb7bc","modified":1596950653304},{"_id":"source/categories/index.md","hash":"bf599f1968d28a0273d7b30aeb5da07b3013afc0","modified":1596950653305},{"_id":"source/tags/index.md","hash":"195395eeb6ba4b2200efe27550a40fa99f9c3ce2","modified":1596950653315},{"_id":"themes/next/.git/HEAD","hash":"c0cd8129128a1715fe2b02c086f6c96186f5fadb","modified":1596957705523},{"_id":"themes/next/.git/config","hash":"314cf8692fc88ad51df56fbc87f1d27b9b4abf05","modified":1596957295818},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1596957290980},{"_id":"themes/next/.git/index","hash":"2a42fafab330c8b37e20dbc9639a86a2745a9573","modified":1596957705961},{"_id":"themes/next/.git/packed-refs","hash":"28b66e978497180eab3e3a861a9c6cf0f7e980c6","modified":1596957705510},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"71fefb297a880325c59b3791013ebbb3dc3584af","modified":1596957705674},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"6e83418ee348f13aee00ae47b71695f3b218714b","modified":1596957705674},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"36201119490a04107c8179b10202548a9d0e5e60","modified":1596957705679},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1596957705680},{"_id":"themes/next/.github/stale.yml","hash":"b9f7b394c0f3c00ac36168aa5f88c04cbb335911","modified":1596957705681},{"_id":"themes/next/docs/AUTHORS.md","hash":"f04132472dbc25b9c1202d4cb82a74aea7e6ca10","modified":1596957705695},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1596957705694},{"_id":"themes/next/docs/INSTALLATION.md","hash":"90565973c39b1c6166317740df2685a1b9961c25","modified":1596957705696},{"_id":"themes/next/docs/LICENSE","hash":"5b702310012d480b40529fd10cf1872f687277a0","modified":1596957705697},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"39b2a74e15555a3333c05ca6ea259ccb683fa96f","modified":1596957705697},{"_id":"themes/next/docs/DATA-FILES.md","hash":"a5b89b34c1a76bef60f650fdcfae08ccedc4a4a6","modified":1596957705695},{"_id":"themes/next/languages/de.yml","hash":"b8962e3a680530c331c96b06a41a519e7eca9988","modified":1596957705709},{"_id":"themes/next/languages/default.yml","hash":"2e52aa06eedfdfbb90ab0e8792968721aac412fb","modified":1596957705709},{"_id":"themes/next/languages/en.yml","hash":"4e6b8699dca27936b2f784c7680f1e4fab5b4c5b","modified":1596957705710},{"_id":"themes/next/languages/fr-FR.yml","hash":"e8cf4d66e919f3c1672b8ca26827185e774c4439","modified":1596957705711},{"_id":"themes/next/languages/id.yml","hash":"d0c2f8e90b047db16491a1a5c8f288d0e7244ed3","modified":1596957705711},{"_id":"themes/next/languages/it.yml","hash":"ac109a258ba8a58d07ece728239b093e132feb82","modified":1596957705712},{"_id":"themes/next/languages/ja.yml","hash":"640f0886603b8ed850a2ce81240a414c0cdda997","modified":1596957705713},{"_id":"themes/next/languages/ko.yml","hash":"edf0eeebb6d713c1f7e6b9751b19e8d0b13de4ee","modified":1596957705714},{"_id":"themes/next/languages/nl-NL.yml","hash":"213e7a002b82fb265f69dabafbbc382cfd460030","modified":1596957705714},{"_id":"themes/next/languages/pt-BR.yml","hash":"379591d355f7a1f16447635a0c154bad655db06e","modified":1596957705715},{"_id":"themes/next/languages/pt.yml","hash":"ef68c52c85fa6c1aa0d53586794f8afd0d3a99ae","modified":1596957705716},{"_id":"themes/next/languages/ru.yml","hash":"06e92838a38696f6a519caee12e70ca7898eaea4","modified":1596957705718},{"_id":"themes/next/languages/vi.yml","hash":"a9b89ebd3e5933033d1386c7c56b66c44aca299a","modified":1596957705719},{"_id":"themes/next/languages/zh-Hans.yml","hash":"aec7be889bed2c8eb9c347b94939f67ca284ac9f","modified":1596957705720},{"_id":"themes/next/languages/zh-hk.yml","hash":"6f01b26859d6f3fa86ae346c03f2cff86cdbdc63","modified":1596957705720},{"_id":"themes/next/languages/zh-tw.yml","hash":"85a434a7ed860fed58dc748cba2a857ad6878338","modified":1596957705721},{"_id":"themes/next/layout/_layout.swig","hash":"484a5effad24e96d577af9a12398fc3dae87a733","modified":1596957705723},{"_id":"themes/next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1596957705774},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1596957705774},{"_id":"themes/next/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1596957705775},{"_id":"themes/next/layout/page.swig","hash":"e8fcaa641d46930237675d2ad4b56964d9e262e9","modified":1596957705775},{"_id":"themes/next/layout/post.swig","hash":"7a6ce102ca82c3a80f776e555dddae1a9981e1ed","modified":1596957705776},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1596957705776},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1596957705777},{"_id":"themes/next/scripts/merge-configs.js","hash":"5758f8f3f12d17bc80da65bb808a20b3a8aae186","modified":1596957705778},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1596957705780},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1596957705956},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1596957705957},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1596957705957},{"_id":"source/images/alipay.jpg","hash":"056a5f5b7aae4ef2fcc49d1d7ae1d90bb8ea3468","modified":1596950653307},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1596957705906},{"_id":"source/_posts/C++/C++Review.md","hash":"242746ef663446359ba0ade4a2f1dbce6a18a60c","modified":1596950653276},{"_id":"source/_posts/C++/C++笔面试题目.md","hash":"8963b37c0ed19d5e3d6c2fe6afd892b12892b660","modified":1596950653277},{"_id":"source/_posts/C++/Matrix multiply.md","hash":"3f7d084faa0ebbae6edf61059e53ba5f6d0b4246","modified":1596950653277},{"_id":"source/_posts/C++/两个指针在算法中的应用.md","hash":"7b33a0fb459b1ee797fc2a7fd564e1283ea17dbc","modified":1596950653278},{"_id":"source/_posts/C++/链表.md","hash":"e073805acdc0bfc0555d35c27fedf7a673792123","modified":1596950653279},{"_id":"source/_posts/JAVA/20190507深入学习.md","hash":"3f96bc365e0f8f5eb0788bfec605ae2f151716a7","modified":1596950653280},{"_id":"source/_posts/JAVA/20190521深入学习.md","hash":"7e271bcc6cbe87edd0fb913b66814414992a6114","modified":1596950653281},{"_id":"source/_posts/JAVA/20191107深入学习.md","hash":"f42688a75fc9783ceb8de23a893ca3643a44be16","modified":1596950653281},{"_id":"source/_posts/JAVA/JVM内存分区.md","hash":"7b86c689fc405ea23e65ac8c54e9ea7e8c40d496","modified":1596950653282},{"_id":"source/_posts/JAVA/Maven理解.md","hash":"3faeda6bb0148f6cca732ec1d654f2a191a225bf","modified":1596950653283},{"_id":"source/_posts/JAVA/SpringBoot中直接new对象为NULL值.md","hash":"df8a7e4a1f79c5a7dccca777b72559df334544e2","modified":1596950653283},{"_id":"source/_posts/JAVA/Spring学习笔记.md","hash":"d328c67941b1d9148241f6226a93f0a20ae460ef","modified":1596950653284},{"_id":"source/_posts/JAVA/动态代理.md","hash":"d7f859f870494d4e80589e7dcde1561bf9b2460a","modified":1596950653285},{"_id":"source/_posts/JAVA/二分查找容易出错的3个地方.md","hash":"9a6e65df0f5655f1493df1bb61605893c64730ff","modified":1596950653284},{"_id":"source/_posts/JAVA/深入理解JVM.md","hash":"7f2be813356346c1d0dbc93fd6cc9feb86db6982","modified":1596950653286},{"_id":"source/_posts/JAVA/单例模式.md","hash":"a7dd523ccec0f33fe79d07261d32fa48ee957b5e","modified":1596950653285},{"_id":"source/_posts/TED/How to see past your own perspective and find truth.md","hash":"6a0fa6017f21e57f8294bf74bfb12f001a8d797c","modified":1596950653291},{"_id":"source/_posts/TED/Does money make you mean.md","hash":"8129e26d6da91fd4c43ce0ae3019f7ae2898b750","modified":1596950653291},{"_id":"source/_posts/前端/ajax学习.md","hash":"39a427f802d8a4c6f5dabdc444d38b2a143f8512","modified":1596950653294},{"_id":"source/_posts/前端/CSS定位 文档流 浮动流.md","hash":"9759305f356ec0b43a5f15a012bd9b651b5396a8","modified":1596950653293},{"_id":"source/_posts/生活/校园照片.md","hash":"f337312fe4a85d9c0e460a311ba4fb0742c86320","modified":1596950653298},{"_id":"source/_posts/读书/万历王朝的兴衰史.md","hash":"4e6e98d0fb29886541af31bc056b36fd8b20b699","modified":1596950653302},{"_id":"source/_posts/读书/区块链初认识.md","hash":"74f2ef49caeb72095b4de0e2ccbf4c41f01f54dd","modified":1596950653302},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1596957290998},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1596957290981},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1596957290982},{"_id":"themes/next/.git/hooks/fsmonitor-watchman.sample","hash":"118ff5509f187039734d04456bf01e44c933ac19","modified":1596957290983},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1596957290986},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1596957290990},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"a79d057388ee2c2fe6561d7697f1f5efcff96f23","modified":1596957290993},{"_id":"themes/next/.git/hooks/pre-merge-commit.sample","hash":"04c64e58bc25c149482ed45dbd79e40effb89eb7","modified":1596957290994},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1596957290994},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1596957290995},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1596957290996},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1596957290997},{"_id":"themes/next/.git/hooks/update.sample","hash":"92e81cca38312414b140f52b9de0655ee232f65f","modified":1596957290997},{"_id":"themes/next/.git/logs/HEAD","hash":"eeab49f241ad744c30f5ec8df5adeff9d6d863b4","modified":1596957705523},{"_id":"themes/next/docs/cn/DATA-FILES.md","hash":"9d1efb47c78969e9b1e5a2374d03ad9ea6e8b738","modified":1596957705699},{"_id":"themes/next/docs/cn/INSTALLATION.md","hash":"eb488ed645c48fe3436b9dcd6c719ec38295bd41","modified":1596957705700},{"_id":"themes/next/docs/cn/README.md","hash":"54fbf2aa610f66b77dca4325bf626bb45b13605b","modified":1596957705702},{"_id":"themes/next/docs/cn/UPDATE-FROM-5.1.X.md","hash":"9e41dad049021f3c0d72fca38f47a689fa015eb8","modified":1596957705703},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"3afd4abd7a25d78951a7e027b8c72ba817991c47","modified":1596957705705},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"6f10fbc0aa0bb65a8eaeb0a9454aa280f1d84d77","modified":1596957705704},{"_id":"themes/next/docs/ru/README.md","hash":"56454783898c08eccfff3a8c856e0b40728ba70b","modified":1596957705706},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"6600ec3ec8b251232dc6a1639cbbbf36068ea8f6","modified":1596957705706},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1596957705722},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1596957705722},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1596957705724},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1596957705724},{"_id":"themes/next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1596957705725},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9c7343fd470e0943ebd75f227a083a980816290b","modified":1596957705726},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1596957705727},{"_id":"themes/next/layout/_partials/footer.swig","hash":"90e5cf2cedb2657d8e8092b470fef9e6290d9828","modified":1596957705728},{"_id":"themes/next/layout/_macro/post.swig","hash":"1f5666fc0da066c93533eba61c166908f3130ae6","modified":1596957705725},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4adc65a602d1276615da3b887dcbf2ac68e7382b","modified":1596957705727},{"_id":"themes/next/layout/_partials/head.swig","hash":"24930a298cf6f10ac5f732c1bc8a4c6b91993b07","modified":1596957705729},{"_id":"themes/next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1596957705732},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1596957705733},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1596957705735},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1596957705736},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1596957705741},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1596957705742},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"b48c992ba130914713566a5fe3602c57e0f1ca32","modified":1596957705745},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1596957705762},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1596957705763},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1596957705764},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1596957705764},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1596957705765},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1596957705766},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1596957705767},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1596957705781},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1596957705781},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1596957705783},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1596957705785},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1596957705787},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1596957705787},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1596957705788},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1596957705789},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1596957705789},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1596957705906},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1596957705907},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1596957705907},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1596957705908},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1596957705909},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1596957705909},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1596957705910},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1596957705911},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1596957705911},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1596957705913},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1596957705912},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1596957705913},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1596957705914},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1596957705914},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1596957705915},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1596957705916},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1596957705916},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1596957705917},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1596957705918},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1596957705744},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1596957705744},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1596957705873},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1596957705873},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1596957705877},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1596957705904},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1596957705905},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1596957705729},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1596957705731},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1596957705737},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1596957705738},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1596957705738},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1596957705739},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1596957705739},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1596957705740},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1596957705741},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1596957705743},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1596957705743},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1596957705744},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1596957705746},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1596957705747},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1596957705746},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1596957705747},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1596957705748},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1596957705749},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"ccc443b22bd4f8c7ac4145664686c756395b90e0","modified":1596957705750},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1596957705751},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1596957705753},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1596957705755},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1596957705754},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1596957705754},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1596957705756},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1596957705756},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1596957705757},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1596957705758},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"4dcc3213c033994d342d02b800b6229295433d30","modified":1596957705758},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"493bd5999a1061b981922be92d8277a0f9152447","modified":1596957705760},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1596957705761},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1596957705759},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4050553d44ba1396174161c9a6bb0f89fa779eca","modified":1596957705761},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1596957705762},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1596957705771},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1596957705772},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1596957705772},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1596957705773},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1596957705871},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1596957705872},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1596957705875},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1596957705877},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1596957705902},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1596957705903},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1596957705904},{"_id":"themes/next/source/css/_variables/base.styl","hash":"b1f6ea881a4938a54603d68282b0f8efb4d7915d","modified":1596957705905},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1596957705919},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1596957705920},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"6c30aab4822b189d1fe9b20ca5272fd8d3ebe998","modified":1596957705921},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1596957705921},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1596957705922},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1596957705923},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1596957705923},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1596957705924},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1596957705925},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1596957705926},{"_id":"themes/next/source/js/src/utils.js","hash":"b3e9eca64aba59403334f3fa821f100d98d40337","modified":1596957705927},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1596957705928},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1596957705929},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1596957705931},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1596957705930},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1596957705930},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1596957705948},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1596957705950},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1596957705943},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1596957705949},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1596957705520},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1596957705769},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1596957705770},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1596957705791},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1596957705804},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1596957705805},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1596957705805},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1596957705806},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1596957705814},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1596957705841},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1596957705863},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"24ee4b356ff55fc6e58f26a929fa07750002cf29","modified":1596957705864},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1596957705865},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1596957705867},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1596957705869},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1596957705870},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1596957705870},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1596957705878},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1596957705879},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1596957705879},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1596957705880},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1596957705881},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1596957705881},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1596957705882},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1596957705884},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1596957705894},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1596957705895},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1596957705895},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"a98ad885ee4f48d85b2578a0b9c2bbf166e96733","modified":1596957705895},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1596957705896},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1596957705897},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1596957705898},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1596957705898},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1596957705899},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ad2dcedf393ed1f3f5afd2508d24969c916d02fc","modified":1596957705900},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1596957705901},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1596957705925},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1596957705933},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1596957705934},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1596957705935},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1596957705944},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1596957705945},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1596957705940},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1596957705941},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1596957705947},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"a4edb8c15b1031a35c23ff9cbd7d4d5e665ef91d","modified":1596957705520},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1596957705807},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1596957705808},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1596957705807},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1596957705808},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1596957705809},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1596957705809},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1596957705810},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1596957705810},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1596957705811},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1596957705812},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1596957705812},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1596957705813},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1596957705813},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1596957705814},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1596957705815},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1596957705816},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1596957705819},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1596957705820},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1596957705820},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1596957705821},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"f1e6e6495e69c4da3e8167ffc56bfc4d17aa15e1","modified":1596957705822},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1596957705823},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1596957705823},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1596957705824},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1596957705824},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1596957705825},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1596957705825},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1596957705826},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"89d6c3b697efc63de42afd2e89194b1be14152af","modified":1596957705826},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1596957705827},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1596957705828},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1596957705830},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1596957705829},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1596957705829},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1596957705831},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1596957705834},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1596957705835},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1596957705840},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"c8fe49a4bc014c24dead05b782a7082411a4abc5","modified":1596957705831},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1596957705842},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1596957705842},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1596957705844},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1596957705844},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"f825da191816eef69ea8efb498a7f756d5ebb498","modified":1596957705843},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1596957705845},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1596957705846},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1596957705846},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1596957705847},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1596957705850},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1596957705856},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1596957705857},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1596957705857},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1596957705858},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1596957705859},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1596957705859},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1596957705861},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1596957705860},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1596957705861},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1596957705886},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1596957705887},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1596957705897},{"_id":"themes/next/.git/objects/pack/pack-771a37d1c6049afaf5ec2f3f00376493e609b573.idx","hash":"47bf768263927e6be84359aa0082c304e0894f4a","modified":1596957705341},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1596957705939},{"_id":"source/images/profile.jpg","hash":"a9949063039582dc8e065da3e16e97a4f30f5829","modified":1596950653314},{"_id":"themes/next/.git/objects/pack/pack-771a37d1c6049afaf5ec2f3f00376493e609b573.pack","hash":"5d4fc338b9d5da041fcaa2a05cf44445c31938fd","modified":1596957705323}],"Category":[],"Data":[],"Page":[{"date":"2017-09-04T05:01:49.000Z","type":"about","_content":"后端JAVA开发一枚，平时喜欢捣鼓捣鼓....\n\n欢迎交流，收到消息后会立即回复。\n\n联系方式：\n\n- QQ:：245527922(加的时候请备注下\"博客\"哈)\n- 邮箱：245527922@qq.com  \n\n","source":"about/index.md","raw":"---\ndate: 2017-09-04 13:01:49\ntype: \"about\"\n---\n后端JAVA开发一枚，平时喜欢捣鼓捣鼓....\n\n欢迎交流，收到消息后会立即回复。\n\n联系方式：\n\n- QQ:：245527922(加的时候请备注下\"博客\"哈)\n- 邮箱：245527922@qq.com  \n\n","updated":"2020-08-09T05:24:13.304Z","path":"about/index.html","title":"","comments":1,"layout":"page","_id":"ckdmsedyj0001lguwulejkw77","content":"<p>后端JAVA开发一枚，平时喜欢捣鼓捣鼓….</p>\n<p>欢迎交流，收到消息后会立即回复。</p>\n<p>联系方式：</p>\n<ul>\n<li>QQ:：245527922(加的时候请备注下”博客”哈)</li>\n<li>邮箱：<a href=\"mailto:245527922@qq.com\" target=\"_blank\" rel=\"noopener\">245527922@qq.com</a>  </li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>后端JAVA开发一枚，平时喜欢捣鼓捣鼓….</p>\n<p>欢迎交流，收到消息后会立即回复。</p>\n<p>联系方式：</p>\n<ul>\n<li>QQ:：245527922(加的时候请备注下”博客”哈)</li>\n<li>邮箱：<a href=\"mailto:245527922@qq.com\" target=\"_blank\" rel=\"noopener\">245527922@qq.com</a>  </li>\n</ul>\n"},{"title":"分类","date":"2017-09-03T16:01:46.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2017-09-04 00:01:46\ntype: \"categories\"\n---\n","updated":"2020-08-09T05:24:13.305Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckdmsedym0003lguwck4zz9g1","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2017-09-03T16:01:46.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2017-09-04 00:01:46\ntype: \"tags\"\n---","updated":"2020-08-09T05:24:13.315Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckdmsee5x001mlguwwz458kf9","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"自我提升总结","author":"Zhang Peng","date":"2018-07-26T03:10:00.000Z","_content":"","source":"_drafts/自我提升总结.md","raw":"title: 自我提升总结\nauthor: Zhang Peng\ntags: []\ncategories: []\ndate: 2018-07-26 11:10:00\n---\n","slug":"自我提升总结","published":0,"updated":"2020-08-09T05:24:13.273Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdmsedya0000lguwaroz50ni","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"2019年年终总结","date":"2019-12-30T14:32:37.000Z","_content":"\n回顾1年工作的经历，现在想想能够让自己记忆深刻的事情，发现这些事情都是自己全身心投入进去的。\n\n1. 物流轨迹项目\n\n   从年初开始弄起，陆陆续续了弄了2,3个月。从最初接的快递鸟，采用数据库存储的方式。到现在采用Redis以物流单号为key,会员信息为value存储，对接了菜鸟。这个项目让我对RabbitMQ有了更深的了解，由于物流轨迹服务是不分集群的，根据不同队列会接受不同集群WMS的消息，然后订阅菜鸟。当菜鸟有消息过来时，又会将消息分发到不同集群的WMS，更新物流状态。一开始上线的时候，发现消息积压，20个消费者消费不了这么多消息，后来找尹凌英问了下调整到40个才解决。\n\n   后来随着对RabbitMQ削峰解耦的理解，将原先WMS调LTS接口订阅菜鸟改成发消息订阅，提高WMS的吞吐量。\n\n   物流轨迹目前这个功能还不够完善，只接了菜鸟，还有顺丰，京东，拼多多等平台还未对接。\n\n2. 到印尼帮助得力上线吉客云。\n\n   在出发去印尼前幻想着有一天可以清闲点到处逛逛。后来，我算是被打脸了。跟飞哥天天待在仓库里，帮忙上线吉客云。再加上印尼是热带气候，天天30度左右在仓库待了十几天。本来天气又热，再加上这里的网络真的是慢。打开一个页面不低于3s，后来好不容易上线了之后。回国后，一会Lazada的打印单子有问题，一会京东印尼打印单子有问题，又过一段时间Shoppe打印单子有问题。幸运的是，有欧世懿，何佳龙，黄景铺，董文华大佬们积极的帮助，一个个的帮客户解决。这个解决过程现在回想起非常温馨的，当出了问题，大家都不逃避，不推脱，一起想各种办法去解决问题。大家都有干劲，有激情，冲着解决问题去，这样一起工作的感觉非常棒。\n\n   当然了，印尼那边依然还有问题待解决，道阻且长。\n\n   PS:印尼人口有2亿多，市场潜力巨大，国内有滴滴，这里有go-jerk; 国内有美团，这里有Grab; 国内有淘宝，这里Tokopedia。很多与国内类似的商业模式在这里也成了独角兽。我在想，电商服务商是不是也可以复制到印尼了。\n\n3. 对称重和打包的重构。\n\n   在重构过程中借用翁嘉鑫年终总结的一句话：发现前辈们挖了不少的坑，他们事了拂衣去，留我加班至深夜。历史代码针对不同输入的单号会各种if-else，阅读起来困难。当时借着多包裹的需求，直接用策略模式对其重构，扫描物流单号有物流单号的策略，扫描发货单号有发货单号的策略，扫描包裹号有包裹的策略。重构完后，自己看代码就清爽多了。\n\n   示范仓的流水线和打包设备也一一对接。与北岱对接称重接口时，对方要求接口性能要好，也是优化，还好现在一直都很稳定。\n\n4. 直接发货的优化\n\n   在优化前，WMS会间隙性出现死锁，刘大专门做了个分享。对此，后来，我们WMS迅速修改代码。一开始对直接发货完全摸不到头脑的，觉得很复杂，要改的太多。后来想到多线程，但一开始对多线程不熟悉，就看了一些资料，看完后，实现了一番，发现经常死锁。本来准备放弃多线程的，和袁铭恩交流了下，告诉我还是要往多线程这边想想，就比如1000个单子1个人验货很慢，1000单10个人验货就会快很多。后来，我重新的实现了一遍扣减货位库存的逻辑，本地测的不死锁。后来一上线，没考虑到用户是十几个波次一起点直接发货，还是产生了死锁。辛好当时将死锁的线程try catch了然后用了countDownLatch，让用户可以重试直接发货。当天的还在排查为啥死锁，这时候金林刚开完OKR会议后回来和我说：试下对货位-货品-批次进行排序。经他这一提醒，我又想到了阿里规范（对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。）的排序能减少死锁，立即发了hotfix。后来果然死锁没了。接着，计算邮资也改成异步，直接发货的效率提升了许多，以前发200单要7s，现在400单要1s。这个事情，看了Mysql实战45讲和一些并发管理的文章，学到了很多，还是很开心的。\n   \n   但是出库验货的性能这一块还需优化和调整。\n\n------\n\n2019年也发现许多不足，于是立下2020年的flag去解决\n\n1. 力求代码可读性高，多写点注释，多抽象方法。\n2. 将业务代码和一些注意事项整理成文档，避免后人踩坑。\n3. 保存谦卑，Stay hungry, Stay foolish。\n\n------\n\n我眼中的吉客云\n\n吉客云有各种不足，性能问题，Bug多，客户用的不顺畅，被客户和同事各种花式吐槽；本以为无望，但又能给客户真真正正的带来方便，提高发货效率。\n\n吉客云就像一块璞玉，需要雕琢才成器。祝愿吉客云早日散发光彩，越来越好。","source":"_posts/2019年年终总结.md","raw":"---\ntitle: 2019年年终总结\ndate: 2019-12-30 22:32:37\ntags: 个人提升\n---\n\n回顾1年工作的经历，现在想想能够让自己记忆深刻的事情，发现这些事情都是自己全身心投入进去的。\n\n1. 物流轨迹项目\n\n   从年初开始弄起，陆陆续续了弄了2,3个月。从最初接的快递鸟，采用数据库存储的方式。到现在采用Redis以物流单号为key,会员信息为value存储，对接了菜鸟。这个项目让我对RabbitMQ有了更深的了解，由于物流轨迹服务是不分集群的，根据不同队列会接受不同集群WMS的消息，然后订阅菜鸟。当菜鸟有消息过来时，又会将消息分发到不同集群的WMS，更新物流状态。一开始上线的时候，发现消息积压，20个消费者消费不了这么多消息，后来找尹凌英问了下调整到40个才解决。\n\n   后来随着对RabbitMQ削峰解耦的理解，将原先WMS调LTS接口订阅菜鸟改成发消息订阅，提高WMS的吞吐量。\n\n   物流轨迹目前这个功能还不够完善，只接了菜鸟，还有顺丰，京东，拼多多等平台还未对接。\n\n2. 到印尼帮助得力上线吉客云。\n\n   在出发去印尼前幻想着有一天可以清闲点到处逛逛。后来，我算是被打脸了。跟飞哥天天待在仓库里，帮忙上线吉客云。再加上印尼是热带气候，天天30度左右在仓库待了十几天。本来天气又热，再加上这里的网络真的是慢。打开一个页面不低于3s，后来好不容易上线了之后。回国后，一会Lazada的打印单子有问题，一会京东印尼打印单子有问题，又过一段时间Shoppe打印单子有问题。幸运的是，有欧世懿，何佳龙，黄景铺，董文华大佬们积极的帮助，一个个的帮客户解决。这个解决过程现在回想起非常温馨的，当出了问题，大家都不逃避，不推脱，一起想各种办法去解决问题。大家都有干劲，有激情，冲着解决问题去，这样一起工作的感觉非常棒。\n\n   当然了，印尼那边依然还有问题待解决，道阻且长。\n\n   PS:印尼人口有2亿多，市场潜力巨大，国内有滴滴，这里有go-jerk; 国内有美团，这里有Grab; 国内有淘宝，这里Tokopedia。很多与国内类似的商业模式在这里也成了独角兽。我在想，电商服务商是不是也可以复制到印尼了。\n\n3. 对称重和打包的重构。\n\n   在重构过程中借用翁嘉鑫年终总结的一句话：发现前辈们挖了不少的坑，他们事了拂衣去，留我加班至深夜。历史代码针对不同输入的单号会各种if-else，阅读起来困难。当时借着多包裹的需求，直接用策略模式对其重构，扫描物流单号有物流单号的策略，扫描发货单号有发货单号的策略，扫描包裹号有包裹的策略。重构完后，自己看代码就清爽多了。\n\n   示范仓的流水线和打包设备也一一对接。与北岱对接称重接口时，对方要求接口性能要好，也是优化，还好现在一直都很稳定。\n\n4. 直接发货的优化\n\n   在优化前，WMS会间隙性出现死锁，刘大专门做了个分享。对此，后来，我们WMS迅速修改代码。一开始对直接发货完全摸不到头脑的，觉得很复杂，要改的太多。后来想到多线程，但一开始对多线程不熟悉，就看了一些资料，看完后，实现了一番，发现经常死锁。本来准备放弃多线程的，和袁铭恩交流了下，告诉我还是要往多线程这边想想，就比如1000个单子1个人验货很慢，1000单10个人验货就会快很多。后来，我重新的实现了一遍扣减货位库存的逻辑，本地测的不死锁。后来一上线，没考虑到用户是十几个波次一起点直接发货，还是产生了死锁。辛好当时将死锁的线程try catch了然后用了countDownLatch，让用户可以重试直接发货。当天的还在排查为啥死锁，这时候金林刚开完OKR会议后回来和我说：试下对货位-货品-批次进行排序。经他这一提醒，我又想到了阿里规范（对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。）的排序能减少死锁，立即发了hotfix。后来果然死锁没了。接着，计算邮资也改成异步，直接发货的效率提升了许多，以前发200单要7s，现在400单要1s。这个事情，看了Mysql实战45讲和一些并发管理的文章，学到了很多，还是很开心的。\n   \n   但是出库验货的性能这一块还需优化和调整。\n\n------\n\n2019年也发现许多不足，于是立下2020年的flag去解决\n\n1. 力求代码可读性高，多写点注释，多抽象方法。\n2. 将业务代码和一些注意事项整理成文档，避免后人踩坑。\n3. 保存谦卑，Stay hungry, Stay foolish。\n\n------\n\n我眼中的吉客云\n\n吉客云有各种不足，性能问题，Bug多，客户用的不顺畅，被客户和同事各种花式吐槽；本以为无望，但又能给客户真真正正的带来方便，提高发货效率。\n\n吉客云就像一块璞玉，需要雕琢才成器。祝愿吉客云早日散发光彩，越来越好。","slug":"2019年年终总结","published":1,"updated":"2020-08-09T05:24:13.275Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdmsedyk0002lguwa1038h9p","content":"<p>回顾1年工作的经历，现在想想能够让自己记忆深刻的事情，发现这些事情都是自己全身心投入进去的。</p>\n<ol>\n<li><p>物流轨迹项目</p>\n<p>从年初开始弄起，陆陆续续了弄了2,3个月。从最初接的快递鸟，采用数据库存储的方式。到现在采用Redis以物流单号为key,会员信息为value存储，对接了菜鸟。这个项目让我对RabbitMQ有了更深的了解，由于物流轨迹服务是不分集群的，根据不同队列会接受不同集群WMS的消息，然后订阅菜鸟。当菜鸟有消息过来时，又会将消息分发到不同集群的WMS，更新物流状态。一开始上线的时候，发现消息积压，20个消费者消费不了这么多消息，后来找尹凌英问了下调整到40个才解决。</p>\n<p>后来随着对RabbitMQ削峰解耦的理解，将原先WMS调LTS接口订阅菜鸟改成发消息订阅，提高WMS的吞吐量。</p>\n<p>物流轨迹目前这个功能还不够完善，只接了菜鸟，还有顺丰，京东，拼多多等平台还未对接。</p>\n</li>\n<li><p>到印尼帮助得力上线吉客云。</p>\n<p>在出发去印尼前幻想着有一天可以清闲点到处逛逛。后来，我算是被打脸了。跟飞哥天天待在仓库里，帮忙上线吉客云。再加上印尼是热带气候，天天30度左右在仓库待了十几天。本来天气又热，再加上这里的网络真的是慢。打开一个页面不低于3s，后来好不容易上线了之后。回国后，一会Lazada的打印单子有问题，一会京东印尼打印单子有问题，又过一段时间Shoppe打印单子有问题。幸运的是，有欧世懿，何佳龙，黄景铺，董文华大佬们积极的帮助，一个个的帮客户解决。这个解决过程现在回想起非常温馨的，当出了问题，大家都不逃避，不推脱，一起想各种办法去解决问题。大家都有干劲，有激情，冲着解决问题去，这样一起工作的感觉非常棒。</p>\n<p>当然了，印尼那边依然还有问题待解决，道阻且长。</p>\n<p>PS:印尼人口有2亿多，市场潜力巨大，国内有滴滴，这里有go-jerk; 国内有美团，这里有Grab; 国内有淘宝，这里Tokopedia。很多与国内类似的商业模式在这里也成了独角兽。我在想，电商服务商是不是也可以复制到印尼了。</p>\n</li>\n<li><p>对称重和打包的重构。</p>\n<p>在重构过程中借用翁嘉鑫年终总结的一句话：发现前辈们挖了不少的坑，他们事了拂衣去，留我加班至深夜。历史代码针对不同输入的单号会各种if-else，阅读起来困难。当时借着多包裹的需求，直接用策略模式对其重构，扫描物流单号有物流单号的策略，扫描发货单号有发货单号的策略，扫描包裹号有包裹的策略。重构完后，自己看代码就清爽多了。</p>\n<p>示范仓的流水线和打包设备也一一对接。与北岱对接称重接口时，对方要求接口性能要好，也是优化，还好现在一直都很稳定。</p>\n</li>\n<li><p>直接发货的优化</p>\n<p>在优化前，WMS会间隙性出现死锁，刘大专门做了个分享。对此，后来，我们WMS迅速修改代码。一开始对直接发货完全摸不到头脑的，觉得很复杂，要改的太多。后来想到多线程，但一开始对多线程不熟悉，就看了一些资料，看完后，实现了一番，发现经常死锁。本来准备放弃多线程的，和袁铭恩交流了下，告诉我还是要往多线程这边想想，就比如1000个单子1个人验货很慢，1000单10个人验货就会快很多。后来，我重新的实现了一遍扣减货位库存的逻辑，本地测的不死锁。后来一上线，没考虑到用户是十几个波次一起点直接发货，还是产生了死锁。辛好当时将死锁的线程try catch了然后用了countDownLatch，让用户可以重试直接发货。当天的还在排查为啥死锁，这时候金林刚开完OKR会议后回来和我说：试下对货位-货品-批次进行排序。经他这一提醒，我又想到了阿里规范（对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。）的排序能减少死锁，立即发了hotfix。后来果然死锁没了。接着，计算邮资也改成异步，直接发货的效率提升了许多，以前发200单要7s，现在400单要1s。这个事情，看了Mysql实战45讲和一些并发管理的文章，学到了很多，还是很开心的。</p>\n<p>但是出库验货的性能这一块还需优化和调整。</p>\n</li>\n</ol>\n<hr>\n<p>2019年也发现许多不足，于是立下2020年的flag去解决</p>\n<ol>\n<li>力求代码可读性高，多写点注释，多抽象方法。</li>\n<li>将业务代码和一些注意事项整理成文档，避免后人踩坑。</li>\n<li>保存谦卑，Stay hungry, Stay foolish。</li>\n</ol>\n<hr>\n<p>我眼中的吉客云</p>\n<p>吉客云有各种不足，性能问题，Bug多，客户用的不顺畅，被客户和同事各种花式吐槽；本以为无望，但又能给客户真真正正的带来方便，提高发货效率。</p>\n<p>吉客云就像一块璞玉，需要雕琢才成器。祝愿吉客云早日散发光彩，越来越好。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>回顾1年工作的经历，现在想想能够让自己记忆深刻的事情，发现这些事情都是自己全身心投入进去的。</p>\n<ol>\n<li><p>物流轨迹项目</p>\n<p>从年初开始弄起，陆陆续续了弄了2,3个月。从最初接的快递鸟，采用数据库存储的方式。到现在采用Redis以物流单号为key,会员信息为value存储，对接了菜鸟。这个项目让我对RabbitMQ有了更深的了解，由于物流轨迹服务是不分集群的，根据不同队列会接受不同集群WMS的消息，然后订阅菜鸟。当菜鸟有消息过来时，又会将消息分发到不同集群的WMS，更新物流状态。一开始上线的时候，发现消息积压，20个消费者消费不了这么多消息，后来找尹凌英问了下调整到40个才解决。</p>\n<p>后来随着对RabbitMQ削峰解耦的理解，将原先WMS调LTS接口订阅菜鸟改成发消息订阅，提高WMS的吞吐量。</p>\n<p>物流轨迹目前这个功能还不够完善，只接了菜鸟，还有顺丰，京东，拼多多等平台还未对接。</p>\n</li>\n<li><p>到印尼帮助得力上线吉客云。</p>\n<p>在出发去印尼前幻想着有一天可以清闲点到处逛逛。后来，我算是被打脸了。跟飞哥天天待在仓库里，帮忙上线吉客云。再加上印尼是热带气候，天天30度左右在仓库待了十几天。本来天气又热，再加上这里的网络真的是慢。打开一个页面不低于3s，后来好不容易上线了之后。回国后，一会Lazada的打印单子有问题，一会京东印尼打印单子有问题，又过一段时间Shoppe打印单子有问题。幸运的是，有欧世懿，何佳龙，黄景铺，董文华大佬们积极的帮助，一个个的帮客户解决。这个解决过程现在回想起非常温馨的，当出了问题，大家都不逃避，不推脱，一起想各种办法去解决问题。大家都有干劲，有激情，冲着解决问题去，这样一起工作的感觉非常棒。</p>\n<p>当然了，印尼那边依然还有问题待解决，道阻且长。</p>\n<p>PS:印尼人口有2亿多，市场潜力巨大，国内有滴滴，这里有go-jerk; 国内有美团，这里有Grab; 国内有淘宝，这里Tokopedia。很多与国内类似的商业模式在这里也成了独角兽。我在想，电商服务商是不是也可以复制到印尼了。</p>\n</li>\n<li><p>对称重和打包的重构。</p>\n<p>在重构过程中借用翁嘉鑫年终总结的一句话：发现前辈们挖了不少的坑，他们事了拂衣去，留我加班至深夜。历史代码针对不同输入的单号会各种if-else，阅读起来困难。当时借着多包裹的需求，直接用策略模式对其重构，扫描物流单号有物流单号的策略，扫描发货单号有发货单号的策略，扫描包裹号有包裹的策略。重构完后，自己看代码就清爽多了。</p>\n<p>示范仓的流水线和打包设备也一一对接。与北岱对接称重接口时，对方要求接口性能要好，也是优化，还好现在一直都很稳定。</p>\n</li>\n<li><p>直接发货的优化</p>\n<p>在优化前，WMS会间隙性出现死锁，刘大专门做了个分享。对此，后来，我们WMS迅速修改代码。一开始对直接发货完全摸不到头脑的，觉得很复杂，要改的太多。后来想到多线程，但一开始对多线程不熟悉，就看了一些资料，看完后，实现了一番，发现经常死锁。本来准备放弃多线程的，和袁铭恩交流了下，告诉我还是要往多线程这边想想，就比如1000个单子1个人验货很慢，1000单10个人验货就会快很多。后来，我重新的实现了一遍扣减货位库存的逻辑，本地测的不死锁。后来一上线，没考虑到用户是十几个波次一起点直接发货，还是产生了死锁。辛好当时将死锁的线程try catch了然后用了countDownLatch，让用户可以重试直接发货。当天的还在排查为啥死锁，这时候金林刚开完OKR会议后回来和我说：试下对货位-货品-批次进行排序。经他这一提醒，我又想到了阿里规范（对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。）的排序能减少死锁，立即发了hotfix。后来果然死锁没了。接着，计算邮资也改成异步，直接发货的效率提升了许多，以前发200单要7s，现在400单要1s。这个事情，看了Mysql实战45讲和一些并发管理的文章，学到了很多，还是很开心的。</p>\n<p>但是出库验货的性能这一块还需优化和调整。</p>\n</li>\n</ol>\n<hr>\n<p>2019年也发现许多不足，于是立下2020年的flag去解决</p>\n<ol>\n<li>力求代码可读性高，多写点注释，多抽象方法。</li>\n<li>将业务代码和一些注意事项整理成文档，避免后人踩坑。</li>\n<li>保存谦卑，Stay hungry, Stay foolish。</li>\n</ol>\n<hr>\n<p>我眼中的吉客云</p>\n<p>吉客云有各种不足，性能问题，Bug多，客户用的不顺畅，被客户和同事各种花式吐槽；本以为无望，但又能给客户真真正正的带来方便，提高发货效率。</p>\n<p>吉客云就像一块璞玉，需要雕琢才成器。祝愿吉客云早日散发光彩，越来越好。</p>\n"},{"title":"Bean生命周期和SpringMVC的工作原理","date":"2020-01-27T07:27:08.000Z","_content":"**Spring Bean生命周期**\n\n![SpringBean生命周期.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gbb5fetvg1j20ui0i1dgz.jpg)\n\n<!--more--> \n\n![实例化.png](http://ww1.sinaimg.cn/mw690/aacc02d8gy1gba3ri4qgpj20kf0f2tab.jpg)\n\n\n\n![初始化.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gbb536clp7j21dx0nyn1m.jpg)\n\n**SpringMVC工作原理**\n\n在SpringBoot启动过程中，创建了Tomcat和DispatcherServlet。\n\n![微信图片_20200127150113.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gbb51vdrccj21cr0jxdil.jpg)\n\n当有请求时，会被DispatcherServlet#doDispatch处理，处理流程图如下：\n\n![MVC流程图.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gbb5f0ds12j20yh0dnwfs.jpg)\n\n[实践源码](https://github.com/luckzp/SpringCode)\n\n","source":"_posts/Bean生命周期和SpringMVC的工作原理.md","raw":"---\ntitle: Bean生命周期和SpringMVC的工作原理\ndate: 2020-01-27 15:27:08\ntags: Java\n---\n**Spring Bean生命周期**\n\n![SpringBean生命周期.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gbb5fetvg1j20ui0i1dgz.jpg)\n\n<!--more--> \n\n![实例化.png](http://ww1.sinaimg.cn/mw690/aacc02d8gy1gba3ri4qgpj20kf0f2tab.jpg)\n\n\n\n![初始化.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gbb536clp7j21dx0nyn1m.jpg)\n\n**SpringMVC工作原理**\n\n在SpringBoot启动过程中，创建了Tomcat和DispatcherServlet。\n\n![微信图片_20200127150113.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gbb51vdrccj21cr0jxdil.jpg)\n\n当有请求时，会被DispatcherServlet#doDispatch处理，处理流程图如下：\n\n![MVC流程图.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gbb5f0ds12j20yh0dnwfs.jpg)\n\n[实践源码](https://github.com/luckzp/SpringCode)\n\n","slug":"Bean生命周期和SpringMVC的工作原理","published":1,"updated":"2020-08-09T05:24:13.275Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdmsedyn0004lguwte49srd0","content":"<p><strong>Spring Bean生命周期</strong></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gbb5fetvg1j20ui0i1dgz.jpg\" alt=\"SpringBean生命周期.png\"></p>\n<a id=\"more\"></a> \n<p><img src=\"http://ww1.sinaimg.cn/mw690/aacc02d8gy1gba3ri4qgpj20kf0f2tab.jpg\" alt=\"实例化.png\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gbb536clp7j21dx0nyn1m.jpg\" alt=\"初始化.png\"></p>\n<p><strong>SpringMVC工作原理</strong></p>\n<p>在SpringBoot启动过程中，创建了Tomcat和DispatcherServlet。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gbb51vdrccj21cr0jxdil.jpg\" alt=\"微信图片_20200127150113.png\"></p>\n<p>当有请求时，会被DispatcherServlet#doDispatch处理，处理流程图如下：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gbb5f0ds12j20yh0dnwfs.jpg\" alt=\"MVC流程图.png\"></p>\n<p><a href=\"https://github.com/luckzp/SpringCode\" target=\"_blank\" rel=\"noopener\">实践源码</a></p>\n","site":{"data":{}},"excerpt":"<p><strong>Spring Bean生命周期</strong></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gbb5fetvg1j20ui0i1dgz.jpg\" alt=\"SpringBean生命周期.png\"></p>","more":"<p><img src=\"http://ww1.sinaimg.cn/mw690/aacc02d8gy1gba3ri4qgpj20kf0f2tab.jpg\" alt=\"实例化.png\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gbb536clp7j21dx0nyn1m.jpg\" alt=\"初始化.png\"></p>\n<p><strong>SpringMVC工作原理</strong></p>\n<p>在SpringBoot启动过程中，创建了Tomcat和DispatcherServlet。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gbb51vdrccj21cr0jxdil.jpg\" alt=\"微信图片_20200127150113.png\"></p>\n<p>当有请求时，会被DispatcherServlet#doDispatch处理，处理流程图如下：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gbb5f0ds12j20yh0dnwfs.jpg\" alt=\"MVC流程图.png\"></p>\n<p><a href=\"https://github.com/luckzp/SpringCode\" target=\"_blank\" rel=\"noopener\">实践源码</a></p>"},{"layout":"post","title":"01背包和完全背包问题","date":"2018-01-07T13:27:00.000Z","comments":1,"reward":true,"_content":"### 01背包问题描述\n\n容量为m的背包和n个物品，每个物品都有各自的体积v和价值val，从这n 个物品中选择多个物品放在包里而物品体积总数不超过包的容量m 时，能够得到的最大价值是多少？\n\n\n\n**一般同学们会考录到用贪心的算法通过求最大的性价比来填满背包，这样会有什么样的不妥之处了？**\n\n<!--more-->\n\n### 贪心与背包问题的不同\n\n- 首先说一下贪心是每一步都是最优的决策，就是每次方我都会放进去解决问题的目前最好的结果。\n- 贪心虽然会带来每一次最优但是不一定是整体最优。(比如说C的性价比最高，但是放了C就不能放别的了，总价值就不如放A和B的多了)\n- 背包可以从宏观上整体得到一个最优的结果。\n\n\n\n### 01背包问题解析\n\n- 问题的特点是：每种物品一件，可以选择放1或不放0。\n\n- 用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：`f[i][v] = max(f[i-1][v-p[i]] + w[i], f[i-1][v])`\n\n- 如果在这里第i件物品放的话就表明它是由第i-1的状态传递过来的并且加上新的价值w[i]，如果不放就表明这里是保持第i-1的状态没有增加新的价值。\n\n代码如下：\n\n```C\n for(i=0; i<=n; i++) dp[i][0] = 0;\n        for(i=0; i<=v; i++) dp[0][i] = 0;\n\n        for(i=1; i<=n; i++){\n            for(j=0; j<=v; j++){\n                dp[i][j] = dp[i-1][j];\n                if(j>=p[i]) dp[i][j] = max(dp[i-1][j], dp[i-1][j-p[i]]+w[i]);\n            }\n        }\n        printf(\"%d\\n\", dp[n][v]);\n    }\n\n```\n\n手工模拟代码：\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1f157poj20kk04h0w4.jpg)\n\n解释这个表：\n有三个物品 就用 (3,4), (4,5), (5,6) 表示（对应表左边）\n用 C(i)(j) 表示表C ，j 为横， i 为纵\n从 C(1)(1)开始，此时你只有一个物品 (3,4) 和一个 容量为 j = 1 的背包。\n因为 3 > 1 所以不能装入，所以此时背包内物品价值为 C(1)(1)= 0\n同理 C(1)(2)时，背包 j = 2，3 > 2，C(1)(2)= 0\nC(1)(3)时 背包大小为 3 刚好能装下这个大小为 3 的物品 所以C(1)(3) = 4\n之后因为只有物品 (3,4) 可选 所以包里价值都是 4\n…………\nC(3)(10)  的时候三种物品都可选，最佳组合是 (4,5) 和 (5,6)，所以C(3)(10) = 5 + 6 = 11.\n\n\n\n### 01背包代码优化\n\n原式子(二维的):  `f[i][v] = max{f[i-1][v-p[i]] + w[i], f[i-1][v]}`\n\n现在要改成一维的(空间优化):  `f[v] = max{f[v-p[i]] + w[i], f[v]}`\n\n注意上面的状态转移方程两边的是2个状态(左边的是这一状态  右边的是上一状态（二维的通过i可以看出来）)\n\n`f[i][v]`是由`f[i-1][v-c[i]]`推出来的,现在要把二维的改成一维的,即要推f[v],要保证f[v]由f[v-c[i]]推出来，如果v是顺序递增的,则相当于`f[i][v]`变得是由`f[i][v-c[i]]`推出来的,而不是由原来的`f[i-1][v-c[i]]`推的.\n\n具体分析见：[01背包问题 总结关于为什么01背包优化成1维数组后,内层循环是逆序的?](http://blog.csdn.net/xiajiawei0206/article/details/19933781)\n\n`f[i][v]`只与`f[i-1][v]`和`f[i-1][v-C[i]]`有关，即只和i-1时刻状态有关，所以我们只需要用一维数组f[]来保存i-1时的状态f[]。\n假设i-1时刻的f[]为{a0，a1，a2，…，av}，难么i时刻的f[]中第v个应该为max(av,av-C[i]+W[i])即max(f[v],f[v-C[i]]+W[i])，这就需要我们遍历V时逆序遍历，这样才能保证求i时刻f[v]时f[v-C[i]]是i-1时刻的值。如果正序遍历则当求f[v]时,其前面的f[0],f[1]，…，f[v-1]都已经改变过，里面存的都不是i-1时刻的值，这样求f[v]时利用f[v-C[i]]必定是错的值。最后f[V]即为最大价值.\n\n```c\nfor(i=0; i<=v; i++){\n            dp[i] = 0;\n        }\n        for(i=1; i<=n; i++){\n            for(j=v; j>=0; j--){\n                if(j>=p[i]) dp[j] = max_num(dp[j], dp[j-p[i]]+w[i]);\n            }\n        }\n        printf(\"%d\\n\", dp[v]);\n    }\n\n```\n\n\n\n### 完全背包问题描述\n\n容量为m的背包和n种物品，每个物品都有各自的体积v和价值val，每种物品都有无限件可用，将哪些物品装入背包物品体积总数不超过包的容量m 时，能够得到的最大价值是多少？\n\n### 完全背包问题解析\n\n这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令`f[i][v]`表示前i种物品恰放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程：\n\n`f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k*c[i]<=v}`\n\n\n同样可以转换成一维数组来表示：\n\n伪代码如下：\n\n```c++\n    for (int i=1; i<=n; i++)  \n        for (int j=1; j<=v; j++)  \n        {  \n            if (p[i]<=j)  \n            {  \n                f[j]=max(f[j],f[j-p[i]]+w[i]);  \n            }             \n        }  \n      \n    cout<<f[v]<<endl;//输出最优解\n```\n\n# 顺序！\n\n想必大家看出了和01背包的区别，这里的内循环是顺序的，而01背包是逆序的。\n现在关键的是考虑：为何完全背包可以这么写？\n在次我们先来回忆下，01背包逆序的原因？是为了是max中的两项是前一状态值，这就对了。\n那么这里，我们顺序写，这里的max中的两项当然就是当前状态的值了，为何？\n因为每种背包都是无限的。当我们把i从1到N循环时，f[v]表示容量为v在前i种背包时所得的价值，这里我们要添加的不是前一个背包，而是当前背包。所以我们要考虑的当然是当前状态。\n\n","source":"_posts/01背包和完全背包问题.md","raw":"---\nlayout: post\ntitle: \"01背包和完全背包问题\"\ndate: 2018-01-07 21:27\ncomments: true\nreward: true\ntags: \n\t- 校招\n---\n### 01背包问题描述\n\n容量为m的背包和n个物品，每个物品都有各自的体积v和价值val，从这n 个物品中选择多个物品放在包里而物品体积总数不超过包的容量m 时，能够得到的最大价值是多少？\n\n\n\n**一般同学们会考录到用贪心的算法通过求最大的性价比来填满背包，这样会有什么样的不妥之处了？**\n\n<!--more-->\n\n### 贪心与背包问题的不同\n\n- 首先说一下贪心是每一步都是最优的决策，就是每次方我都会放进去解决问题的目前最好的结果。\n- 贪心虽然会带来每一次最优但是不一定是整体最优。(比如说C的性价比最高，但是放了C就不能放别的了，总价值就不如放A和B的多了)\n- 背包可以从宏观上整体得到一个最优的结果。\n\n\n\n### 01背包问题解析\n\n- 问题的特点是：每种物品一件，可以选择放1或不放0。\n\n- 用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：`f[i][v] = max(f[i-1][v-p[i]] + w[i], f[i-1][v])`\n\n- 如果在这里第i件物品放的话就表明它是由第i-1的状态传递过来的并且加上新的价值w[i]，如果不放就表明这里是保持第i-1的状态没有增加新的价值。\n\n代码如下：\n\n```C\n for(i=0; i<=n; i++) dp[i][0] = 0;\n        for(i=0; i<=v; i++) dp[0][i] = 0;\n\n        for(i=1; i<=n; i++){\n            for(j=0; j<=v; j++){\n                dp[i][j] = dp[i-1][j];\n                if(j>=p[i]) dp[i][j] = max(dp[i-1][j], dp[i-1][j-p[i]]+w[i]);\n            }\n        }\n        printf(\"%d\\n\", dp[n][v]);\n    }\n\n```\n\n手工模拟代码：\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1f157poj20kk04h0w4.jpg)\n\n解释这个表：\n有三个物品 就用 (3,4), (4,5), (5,6) 表示（对应表左边）\n用 C(i)(j) 表示表C ，j 为横， i 为纵\n从 C(1)(1)开始，此时你只有一个物品 (3,4) 和一个 容量为 j = 1 的背包。\n因为 3 > 1 所以不能装入，所以此时背包内物品价值为 C(1)(1)= 0\n同理 C(1)(2)时，背包 j = 2，3 > 2，C(1)(2)= 0\nC(1)(3)时 背包大小为 3 刚好能装下这个大小为 3 的物品 所以C(1)(3) = 4\n之后因为只有物品 (3,4) 可选 所以包里价值都是 4\n…………\nC(3)(10)  的时候三种物品都可选，最佳组合是 (4,5) 和 (5,6)，所以C(3)(10) = 5 + 6 = 11.\n\n\n\n### 01背包代码优化\n\n原式子(二维的):  `f[i][v] = max{f[i-1][v-p[i]] + w[i], f[i-1][v]}`\n\n现在要改成一维的(空间优化):  `f[v] = max{f[v-p[i]] + w[i], f[v]}`\n\n注意上面的状态转移方程两边的是2个状态(左边的是这一状态  右边的是上一状态（二维的通过i可以看出来）)\n\n`f[i][v]`是由`f[i-1][v-c[i]]`推出来的,现在要把二维的改成一维的,即要推f[v],要保证f[v]由f[v-c[i]]推出来，如果v是顺序递增的,则相当于`f[i][v]`变得是由`f[i][v-c[i]]`推出来的,而不是由原来的`f[i-1][v-c[i]]`推的.\n\n具体分析见：[01背包问题 总结关于为什么01背包优化成1维数组后,内层循环是逆序的?](http://blog.csdn.net/xiajiawei0206/article/details/19933781)\n\n`f[i][v]`只与`f[i-1][v]`和`f[i-1][v-C[i]]`有关，即只和i-1时刻状态有关，所以我们只需要用一维数组f[]来保存i-1时的状态f[]。\n假设i-1时刻的f[]为{a0，a1，a2，…，av}，难么i时刻的f[]中第v个应该为max(av,av-C[i]+W[i])即max(f[v],f[v-C[i]]+W[i])，这就需要我们遍历V时逆序遍历，这样才能保证求i时刻f[v]时f[v-C[i]]是i-1时刻的值。如果正序遍历则当求f[v]时,其前面的f[0],f[1]，…，f[v-1]都已经改变过，里面存的都不是i-1时刻的值，这样求f[v]时利用f[v-C[i]]必定是错的值。最后f[V]即为最大价值.\n\n```c\nfor(i=0; i<=v; i++){\n            dp[i] = 0;\n        }\n        for(i=1; i<=n; i++){\n            for(j=v; j>=0; j--){\n                if(j>=p[i]) dp[j] = max_num(dp[j], dp[j-p[i]]+w[i]);\n            }\n        }\n        printf(\"%d\\n\", dp[v]);\n    }\n\n```\n\n\n\n### 完全背包问题描述\n\n容量为m的背包和n种物品，每个物品都有各自的体积v和价值val，每种物品都有无限件可用，将哪些物品装入背包物品体积总数不超过包的容量m 时，能够得到的最大价值是多少？\n\n### 完全背包问题解析\n\n这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令`f[i][v]`表示前i种物品恰放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程：\n\n`f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k*c[i]<=v}`\n\n\n同样可以转换成一维数组来表示：\n\n伪代码如下：\n\n```c++\n    for (int i=1; i<=n; i++)  \n        for (int j=1; j<=v; j++)  \n        {  \n            if (p[i]<=j)  \n            {  \n                f[j]=max(f[j],f[j-p[i]]+w[i]);  \n            }             \n        }  \n      \n    cout<<f[v]<<endl;//输出最优解\n```\n\n# 顺序！\n\n想必大家看出了和01背包的区别，这里的内循环是顺序的，而01背包是逆序的。\n现在关键的是考虑：为何完全背包可以这么写？\n在次我们先来回忆下，01背包逆序的原因？是为了是max中的两项是前一状态值，这就对了。\n那么这里，我们顺序写，这里的max中的两项当然就是当前状态的值了，为何？\n因为每种背包都是无限的。当我们把i从1到N循环时，f[v]表示容量为v在前i种背包时所得的价值，这里我们要添加的不是前一个背包，而是当前背包。所以我们要考虑的当然是当前状态。\n\n","slug":"01背包和完全背包问题","published":1,"updated":"2020-08-09T05:24:13.274Z","photos":[],"link":"","_id":"ckdmsedys0006lguwbkue9jnv","content":"<h3 id=\"01背包问题描述\"><a href=\"#01背包问题描述\" class=\"headerlink\" title=\"01背包问题描述\"></a>01背包问题描述</h3><p>容量为m的背包和n个物品，每个物品都有各自的体积v和价值val，从这n 个物品中选择多个物品放在包里而物品体积总数不超过包的容量m 时，能够得到的最大价值是多少？</p>\n<p><strong>一般同学们会考录到用贪心的算法通过求最大的性价比来填满背包，这样会有什么样的不妥之处了？</strong></p>\n<a id=\"more\"></a>\n<h3 id=\"贪心与背包问题的不同\"><a href=\"#贪心与背包问题的不同\" class=\"headerlink\" title=\"贪心与背包问题的不同\"></a>贪心与背包问题的不同</h3><ul>\n<li>首先说一下贪心是每一步都是最优的决策，就是每次方我都会放进去解决问题的目前最好的结果。</li>\n<li>贪心虽然会带来每一次最优但是不一定是整体最优。(比如说C的性价比最高，但是放了C就不能放别的了，总价值就不如放A和B的多了)</li>\n<li>背包可以从宏观上整体得到一个最优的结果。</li>\n</ul>\n<h3 id=\"01背包问题解析\"><a href=\"#01背包问题解析\" class=\"headerlink\" title=\"01背包问题解析\"></a>01背包问题解析</h3><ul>\n<li><p>问题的特点是：每种物品一件，可以选择放1或不放0。</p>\n</li>\n<li><p>用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：<code>f[i][v] = max(f[i-1][v-p[i]] + w[i], f[i-1][v])</code></p>\n</li>\n<li><p>如果在这里第i件物品放的话就表明它是由第i-1的状态传递过来的并且加上新的价值w[i]，如果不放就表明这里是保持第i-1的状态没有增加新的价值。</p>\n</li>\n</ul>\n<p>代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;=n; i++) dp[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;=v; i++) dp[<span class=\"number\">0</span>][i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; i&lt;=n; i++)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">for</span>(j=<span class=\"number\">0</span>; j&lt;=v; j++)&#123;</span><br><span class=\"line\">               dp[i][j] = dp[i<span class=\"number\">-1</span>][j];</span><br><span class=\"line\">               <span class=\"keyword\">if</span>(j&gt;=p[i]) dp[i][j] = max(dp[i<span class=\"number\">-1</span>][j], dp[i<span class=\"number\">-1</span>][j-p[i]]+w[i]);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, dp[n][v]);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>手工模拟代码：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1f157poj20kk04h0w4.jpg\" alt></p>\n<p>解释这个表：<br>有三个物品 就用 (3,4), (4,5), (5,6) 表示（对应表左边）<br>用 C(i)(j) 表示表C ，j 为横， i 为纵<br>从 C(1)(1)开始，此时你只有一个物品 (3,4) 和一个 容量为 j = 1 的背包。<br>因为 3 &gt; 1 所以不能装入，所以此时背包内物品价值为 C(1)(1)= 0<br>同理 C(1)(2)时，背包 j = 2，3 &gt; 2，C(1)(2)= 0<br>C(1)(3)时 背包大小为 3 刚好能装下这个大小为 3 的物品 所以C(1)(3) = 4<br>之后因为只有物品 (3,4) 可选 所以包里价值都是 4<br>…………<br>C(3)(10)  的时候三种物品都可选，最佳组合是 (4,5) 和 (5,6)，所以C(3)(10) = 5 + 6 = 11.</p>\n<h3 id=\"01背包代码优化\"><a href=\"#01背包代码优化\" class=\"headerlink\" title=\"01背包代码优化\"></a>01背包代码优化</h3><p>原式子(二维的):  <code>f[i][v] = max{f[i-1][v-p[i]] + w[i], f[i-1][v]}</code></p>\n<p>现在要改成一维的(空间优化):  <code>f[v] = max{f[v-p[i]] + w[i], f[v]}</code></p>\n<p>注意上面的状态转移方程两边的是2个状态(左边的是这一状态  右边的是上一状态（二维的通过i可以看出来）)</p>\n<p><code>f[i][v]</code>是由<code>f[i-1][v-c[i]]</code>推出来的,现在要把二维的改成一维的,即要推f[v],要保证f[v]由f[v-c[i]]推出来，如果v是顺序递增的,则相当于<code>f[i][v]</code>变得是由<code>f[i][v-c[i]]</code>推出来的,而不是由原来的<code>f[i-1][v-c[i]]</code>推的.</p>\n<p>具体分析见：<a href=\"http://blog.csdn.net/xiajiawei0206/article/details/19933781\" target=\"_blank\" rel=\"noopener\">01背包问题 总结关于为什么01背包优化成1维数组后,内层循环是逆序的?</a></p>\n<p><code>f[i][v]</code>只与<code>f[i-1][v]</code>和<code>f[i-1][v-C[i]]</code>有关，即只和i-1时刻状态有关，所以我们只需要用一维数组f[]来保存i-1时的状态f[]。<br>假设i-1时刻的f[]为{a0，a1，a2，…，av}，难么i时刻的f[]中第v个应该为max(av,av-C[i]+W[i])即max(f[v],f[v-C[i]]+W[i])，这就需要我们遍历V时逆序遍历，这样才能保证求i时刻f[v]时f[v-C[i]]是i-1时刻的值。如果正序遍历则当求f[v]时,其前面的f[0],f[1]，…，f[v-1]都已经改变过，里面存的都不是i-1时刻的值，这样求f[v]时利用f[v-C[i]]必定是错的值。最后f[V]即为最大价值.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;=v; i++)&#123;</span><br><span class=\"line\">            dp[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; i&lt;=n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(j=v; j&gt;=<span class=\"number\">0</span>; j--)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j&gt;=p[i]) dp[j] = max_num(dp[j], dp[j-p[i]]+w[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, dp[v]);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"完全背包问题描述\"><a href=\"#完全背包问题描述\" class=\"headerlink\" title=\"完全背包问题描述\"></a>完全背包问题描述</h3><p>容量为m的背包和n种物品，每个物品都有各自的体积v和价值val，每种物品都有无限件可用，将哪些物品装入背包物品体积总数不超过包的容量m 时，能够得到的最大价值是多少？</p>\n<h3 id=\"完全背包问题解析\"><a href=\"#完全背包问题解析\" class=\"headerlink\" title=\"完全背包问题解析\"></a>完全背包问题解析</h3><p>这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令<code>f[i][v]</code>表示前i种物品恰放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程：</p>\n<p><code>f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k*c[i]&lt;=v}</code></p>\n<p>同样可以转换成一维数组来表示：</p>\n<p>伪代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n; i++)  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>; j&lt;=v; j++)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p[i]&lt;=j)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            f[j]=max(f[j],f[j-p[i]]+w[i]);  </span><br><span class=\"line\">        &#125;             </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;f[v]&lt;&lt;<span class=\"built_in\">endl</span>;<span class=\"comment\">//输出最优解</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"顺序！\"><a href=\"#顺序！\" class=\"headerlink\" title=\"顺序！\"></a>顺序！</h1><p>想必大家看出了和01背包的区别，这里的内循环是顺序的，而01背包是逆序的。<br>现在关键的是考虑：为何完全背包可以这么写？<br>在次我们先来回忆下，01背包逆序的原因？是为了是max中的两项是前一状态值，这就对了。<br>那么这里，我们顺序写，这里的max中的两项当然就是当前状态的值了，为何？<br>因为每种背包都是无限的。当我们把i从1到N循环时，f[v]表示容量为v在前i种背包时所得的价值，这里我们要添加的不是前一个背包，而是当前背包。所以我们要考虑的当然是当前状态。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"01背包问题描述\"><a href=\"#01背包问题描述\" class=\"headerlink\" title=\"01背包问题描述\"></a>01背包问题描述</h3><p>容量为m的背包和n个物品，每个物品都有各自的体积v和价值val，从这n 个物品中选择多个物品放在包里而物品体积总数不超过包的容量m 时，能够得到的最大价值是多少？</p>\n<p><strong>一般同学们会考录到用贪心的算法通过求最大的性价比来填满背包，这样会有什么样的不妥之处了？</strong></p>","more":"<h3 id=\"贪心与背包问题的不同\"><a href=\"#贪心与背包问题的不同\" class=\"headerlink\" title=\"贪心与背包问题的不同\"></a>贪心与背包问题的不同</h3><ul>\n<li>首先说一下贪心是每一步都是最优的决策，就是每次方我都会放进去解决问题的目前最好的结果。</li>\n<li>贪心虽然会带来每一次最优但是不一定是整体最优。(比如说C的性价比最高，但是放了C就不能放别的了，总价值就不如放A和B的多了)</li>\n<li>背包可以从宏观上整体得到一个最优的结果。</li>\n</ul>\n<h3 id=\"01背包问题解析\"><a href=\"#01背包问题解析\" class=\"headerlink\" title=\"01背包问题解析\"></a>01背包问题解析</h3><ul>\n<li><p>问题的特点是：每种物品一件，可以选择放1或不放0。</p>\n</li>\n<li><p>用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：<code>f[i][v] = max(f[i-1][v-p[i]] + w[i], f[i-1][v])</code></p>\n</li>\n<li><p>如果在这里第i件物品放的话就表明它是由第i-1的状态传递过来的并且加上新的价值w[i]，如果不放就表明这里是保持第i-1的状态没有增加新的价值。</p>\n</li>\n</ul>\n<p>代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;=n; i++) dp[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;=v; i++) dp[<span class=\"number\">0</span>][i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; i&lt;=n; i++)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">for</span>(j=<span class=\"number\">0</span>; j&lt;=v; j++)&#123;</span><br><span class=\"line\">               dp[i][j] = dp[i<span class=\"number\">-1</span>][j];</span><br><span class=\"line\">               <span class=\"keyword\">if</span>(j&gt;=p[i]) dp[i][j] = max(dp[i<span class=\"number\">-1</span>][j], dp[i<span class=\"number\">-1</span>][j-p[i]]+w[i]);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, dp[n][v]);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>手工模拟代码：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1f157poj20kk04h0w4.jpg\" alt></p>\n<p>解释这个表：<br>有三个物品 就用 (3,4), (4,5), (5,6) 表示（对应表左边）<br>用 C(i)(j) 表示表C ，j 为横， i 为纵<br>从 C(1)(1)开始，此时你只有一个物品 (3,4) 和一个 容量为 j = 1 的背包。<br>因为 3 &gt; 1 所以不能装入，所以此时背包内物品价值为 C(1)(1)= 0<br>同理 C(1)(2)时，背包 j = 2，3 &gt; 2，C(1)(2)= 0<br>C(1)(3)时 背包大小为 3 刚好能装下这个大小为 3 的物品 所以C(1)(3) = 4<br>之后因为只有物品 (3,4) 可选 所以包里价值都是 4<br>…………<br>C(3)(10)  的时候三种物品都可选，最佳组合是 (4,5) 和 (5,6)，所以C(3)(10) = 5 + 6 = 11.</p>\n<h3 id=\"01背包代码优化\"><a href=\"#01背包代码优化\" class=\"headerlink\" title=\"01背包代码优化\"></a>01背包代码优化</h3><p>原式子(二维的):  <code>f[i][v] = max{f[i-1][v-p[i]] + w[i], f[i-1][v]}</code></p>\n<p>现在要改成一维的(空间优化):  <code>f[v] = max{f[v-p[i]] + w[i], f[v]}</code></p>\n<p>注意上面的状态转移方程两边的是2个状态(左边的是这一状态  右边的是上一状态（二维的通过i可以看出来）)</p>\n<p><code>f[i][v]</code>是由<code>f[i-1][v-c[i]]</code>推出来的,现在要把二维的改成一维的,即要推f[v],要保证f[v]由f[v-c[i]]推出来，如果v是顺序递增的,则相当于<code>f[i][v]</code>变得是由<code>f[i][v-c[i]]</code>推出来的,而不是由原来的<code>f[i-1][v-c[i]]</code>推的.</p>\n<p>具体分析见：<a href=\"http://blog.csdn.net/xiajiawei0206/article/details/19933781\" target=\"_blank\" rel=\"noopener\">01背包问题 总结关于为什么01背包优化成1维数组后,内层循环是逆序的?</a></p>\n<p><code>f[i][v]</code>只与<code>f[i-1][v]</code>和<code>f[i-1][v-C[i]]</code>有关，即只和i-1时刻状态有关，所以我们只需要用一维数组f[]来保存i-1时的状态f[]。<br>假设i-1时刻的f[]为{a0，a1，a2，…，av}，难么i时刻的f[]中第v个应该为max(av,av-C[i]+W[i])即max(f[v],f[v-C[i]]+W[i])，这就需要我们遍历V时逆序遍历，这样才能保证求i时刻f[v]时f[v-C[i]]是i-1时刻的值。如果正序遍历则当求f[v]时,其前面的f[0],f[1]，…，f[v-1]都已经改变过，里面存的都不是i-1时刻的值，这样求f[v]时利用f[v-C[i]]必定是错的值。最后f[V]即为最大价值.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;=v; i++)&#123;</span><br><span class=\"line\">            dp[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; i&lt;=n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(j=v; j&gt;=<span class=\"number\">0</span>; j--)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j&gt;=p[i]) dp[j] = max_num(dp[j], dp[j-p[i]]+w[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, dp[v]);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"完全背包问题描述\"><a href=\"#完全背包问题描述\" class=\"headerlink\" title=\"完全背包问题描述\"></a>完全背包问题描述</h3><p>容量为m的背包和n种物品，每个物品都有各自的体积v和价值val，每种物品都有无限件可用，将哪些物品装入背包物品体积总数不超过包的容量m 时，能够得到的最大价值是多少？</p>\n<h3 id=\"完全背包问题解析\"><a href=\"#完全背包问题解析\" class=\"headerlink\" title=\"完全背包问题解析\"></a>完全背包问题解析</h3><p>这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令<code>f[i][v]</code>表示前i种物品恰放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程：</p>\n<p><code>f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k*c[i]&lt;=v}</code></p>\n<p>同样可以转换成一维数组来表示：</p>\n<p>伪代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n; i++)  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>; j&lt;=v; j++)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p[i]&lt;=j)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            f[j]=max(f[j],f[j-p[i]]+w[i]);  </span><br><span class=\"line\">        &#125;             </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;f[v]&lt;&lt;<span class=\"built_in\">endl</span>;<span class=\"comment\">//输出最优解</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"顺序！\"><a href=\"#顺序！\" class=\"headerlink\" title=\"顺序！\"></a>顺序！</h1><p>想必大家看出了和01背包的区别，这里的内循环是顺序的，而01背包是逆序的。<br>现在关键的是考虑：为何完全背包可以这么写？<br>在次我们先来回忆下，01背包逆序的原因？是为了是max中的两项是前一状态值，这就对了。<br>那么这里，我们顺序写，这里的max中的两项当然就是当前状态的值了，为何？<br>因为每种背包都是无限的。当我们把i从1到N循环时，f[v]表示容量为v在前i种背包时所得的价值，这里我们要添加的不是前一个背包，而是当前背包。所以我们要考虑的当然是当前状态。</p>"},{"title":"Join工作原理","date":"2020-05-06T15:22:26.000Z","_content":"### Join工作原理\n\n### 1.Index Nested-Loop Join\n\n可以使用被驱动表的索引走的是Index Nested-Loop Join。\n\n执行流程是这样的：\n\n![TIM截图20191127174928.png](http://ww1.sinaimg.cn/large/aacc02d8ly1gej4hmbzpbj20kg0pbn0f.jpg)\n\n在这个流程里：\n1. 对驱动表 t1 做了全表扫描，这个过程需要扫描 100 行；\n2. 而对于每一行 R，根据 a 字段去表 t2 查找，走的是树搜索过程。由于我们构造的数据\n都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描 100 行；\n3. 所以，整个执行流程，总扫描行数是 200。\n\n### 2.Block Nested-Loop Join\n\n不能使用被驱动表的索引,流程是这样的:\n\n![微信截图_20200506230957.png](http://ww1.sinaimg.cn/large/aacc02d8ly1gej4vnonkcj20od0ov77r.jpg)\n\n在这个流程里：\n\n由于 join_buffer 是以无序数组的方式组织的，因此对表 t2 中的每一行，都要做100 次判断，总共需要在内存中做的判断次数是：100*1000=10 万次。\n\njoin_buffer 的大小是由参数 join_buffer_size 设定的，默认值是 256k。如果放不下表 t1的所有数据话，策略很简单，就是分段放。","source":"_posts/Join工作原理.md","raw":"---\ntitle: Join工作原理\ndate: 2020-05-06 23:22:26\ntags: Mysql\n---\n### Join工作原理\n\n### 1.Index Nested-Loop Join\n\n可以使用被驱动表的索引走的是Index Nested-Loop Join。\n\n执行流程是这样的：\n\n![TIM截图20191127174928.png](http://ww1.sinaimg.cn/large/aacc02d8ly1gej4hmbzpbj20kg0pbn0f.jpg)\n\n在这个流程里：\n1. 对驱动表 t1 做了全表扫描，这个过程需要扫描 100 行；\n2. 而对于每一行 R，根据 a 字段去表 t2 查找，走的是树搜索过程。由于我们构造的数据\n都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描 100 行；\n3. 所以，整个执行流程，总扫描行数是 200。\n\n### 2.Block Nested-Loop Join\n\n不能使用被驱动表的索引,流程是这样的:\n\n![微信截图_20200506230957.png](http://ww1.sinaimg.cn/large/aacc02d8ly1gej4vnonkcj20od0ov77r.jpg)\n\n在这个流程里：\n\n由于 join_buffer 是以无序数组的方式组织的，因此对表 t2 中的每一行，都要做100 次判断，总共需要在内存中做的判断次数是：100*1000=10 万次。\n\njoin_buffer 的大小是由参数 join_buffer_size 设定的，默认值是 256k。如果放不下表 t1的所有数据话，策略很简单，就是分段放。","slug":"Join工作原理","published":1,"updated":"2020-08-09T05:24:13.287Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdmsedyv0007lguw7u64cv8v","content":"<h3 id=\"Join工作原理\"><a href=\"#Join工作原理\" class=\"headerlink\" title=\"Join工作原理\"></a>Join工作原理</h3><h3 id=\"1-Index-Nested-Loop-Join\"><a href=\"#1-Index-Nested-Loop-Join\" class=\"headerlink\" title=\"1.Index Nested-Loop Join\"></a>1.Index Nested-Loop Join</h3><p>可以使用被驱动表的索引走的是Index Nested-Loop Join。</p>\n<p>执行流程是这样的：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1gej4hmbzpbj20kg0pbn0f.jpg\" alt=\"TIM截图20191127174928.png\"></p>\n<p>在这个流程里：</p>\n<ol>\n<li>对驱动表 t1 做了全表扫描，这个过程需要扫描 100 行；</li>\n<li>而对于每一行 R，根据 a 字段去表 t2 查找，走的是树搜索过程。由于我们构造的数据<br>都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描 100 行；</li>\n<li>所以，整个执行流程，总扫描行数是 200。</li>\n</ol>\n<h3 id=\"2-Block-Nested-Loop-Join\"><a href=\"#2-Block-Nested-Loop-Join\" class=\"headerlink\" title=\"2.Block Nested-Loop Join\"></a>2.Block Nested-Loop Join</h3><p>不能使用被驱动表的索引,流程是这样的:</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1gej4vnonkcj20od0ov77r.jpg\" alt=\"微信截图_20200506230957.png\"></p>\n<p>在这个流程里：</p>\n<p>由于 join_buffer 是以无序数组的方式组织的，因此对表 t2 中的每一行，都要做100 次判断，总共需要在内存中做的判断次数是：100*1000=10 万次。</p>\n<p>join_buffer 的大小是由参数 join_buffer_size 设定的，默认值是 256k。如果放不下表 t1的所有数据话，策略很简单，就是分段放。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Join工作原理\"><a href=\"#Join工作原理\" class=\"headerlink\" title=\"Join工作原理\"></a>Join工作原理</h3><h3 id=\"1-Index-Nested-Loop-Join\"><a href=\"#1-Index-Nested-Loop-Join\" class=\"headerlink\" title=\"1.Index Nested-Loop Join\"></a>1.Index Nested-Loop Join</h3><p>可以使用被驱动表的索引走的是Index Nested-Loop Join。</p>\n<p>执行流程是这样的：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1gej4hmbzpbj20kg0pbn0f.jpg\" alt=\"TIM截图20191127174928.png\"></p>\n<p>在这个流程里：</p>\n<ol>\n<li>对驱动表 t1 做了全表扫描，这个过程需要扫描 100 行；</li>\n<li>而对于每一行 R，根据 a 字段去表 t2 查找，走的是树搜索过程。由于我们构造的数据<br>都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描 100 行；</li>\n<li>所以，整个执行流程，总扫描行数是 200。</li>\n</ol>\n<h3 id=\"2-Block-Nested-Loop-Join\"><a href=\"#2-Block-Nested-Loop-Join\" class=\"headerlink\" title=\"2.Block Nested-Loop Join\"></a>2.Block Nested-Loop Join</h3><p>不能使用被驱动表的索引,流程是这样的:</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1gej4vnonkcj20od0ov77r.jpg\" alt=\"微信截图_20200506230957.png\"></p>\n<p>在这个流程里：</p>\n<p>由于 join_buffer 是以无序数组的方式组织的，因此对表 t2 中的每一行，都要做100 次判断，总共需要在内存中做的判断次数是：100*1000=10 万次。</p>\n<p>join_buffer 的大小是由参数 join_buffer_size 设定的，默认值是 256k。如果放不下表 t1的所有数据话，策略很简单，就是分段放。</p>\n"},{"title":"Mysql中的B+树","date":"2019-12-25T12:34:49.000Z","_content":"\n### 索引\n\nmysql中的索引底层使用的是B+树，索引存储在硬盘中，而非内存中。考虑性能，要减少磁盘IO次数。\n\n构建M叉树，M越大，树的高度越小，磁盘IO变少了。\n\n**举例：**\n\n如果 m 叉树中的 m 是 100，那对一亿个数据构建索引，树的高度也只是 3（层数是4），最多只要 3 次磁盘 IO 就能获取到数据（第一层节点存在内存里）。磁盘IO 变少了，查找数据的效率也就提高了。\n\n**那 m 叉树中的 m 是不是越大越好呢？到底多大才最合适呢？**\n\n不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是 4KB，这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。所以，我们在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘 IO 操作。","source":"_posts/Mysql中的B+树.md","raw":"---\ntitle: Mysql中的B+树\ndate: 2019-12-25 20:34:49\ntags: Mysql\n---\n\n### 索引\n\nmysql中的索引底层使用的是B+树，索引存储在硬盘中，而非内存中。考虑性能，要减少磁盘IO次数。\n\n构建M叉树，M越大，树的高度越小，磁盘IO变少了。\n\n**举例：**\n\n如果 m 叉树中的 m 是 100，那对一亿个数据构建索引，树的高度也只是 3（层数是4），最多只要 3 次磁盘 IO 就能获取到数据（第一层节点存在内存里）。磁盘IO 变少了，查找数据的效率也就提高了。\n\n**那 m 叉树中的 m 是不是越大越好呢？到底多大才最合适呢？**\n\n不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是 4KB，这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。所以，我们在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘 IO 操作。","slug":"Mysql中的B+树","published":1,"updated":"2020-08-09T05:24:13.287Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdmsedyy0008lguww62a52gj","content":"<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><p>mysql中的索引底层使用的是B+树，索引存储在硬盘中，而非内存中。考虑性能，要减少磁盘IO次数。</p>\n<p>构建M叉树，M越大，树的高度越小，磁盘IO变少了。</p>\n<p><strong>举例：</strong></p>\n<p>如果 m 叉树中的 m 是 100，那对一亿个数据构建索引，树的高度也只是 3（层数是4），最多只要 3 次磁盘 IO 就能获取到数据（第一层节点存在内存里）。磁盘IO 变少了，查找数据的效率也就提高了。</p>\n<p><strong>那 m 叉树中的 m 是不是越大越好呢？到底多大才最合适呢？</strong></p>\n<p>不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是 4KB，这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。所以，我们在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘 IO 操作。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><p>mysql中的索引底层使用的是B+树，索引存储在硬盘中，而非内存中。考虑性能，要减少磁盘IO次数。</p>\n<p>构建M叉树，M越大，树的高度越小，磁盘IO变少了。</p>\n<p><strong>举例：</strong></p>\n<p>如果 m 叉树中的 m 是 100，那对一亿个数据构建索引，树的高度也只是 3（层数是4），最多只要 3 次磁盘 IO 就能获取到数据（第一层节点存在内存里）。磁盘IO 变少了，查找数据的效率也就提高了。</p>\n<p><strong>那 m 叉树中的 m 是不是越大越好呢？到底多大才最合适呢？</strong></p>\n<p>不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是 4KB，这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。所以，我们在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘 IO 操作。</p>\n"},{"title":"Mysql实战-学习笔记(1)","date":"2019-10-18T13:43:08.000Z","_content":"\n### 1 一条SQL查询语句是如何执行的？\n\n创建数据库连接，SQL经过分析器分析语义，优化器选择合适的索引，选择最佳的执行方案，最后执行器执行。\n\n如果是更新语句，先是查找到这行，然后才执行更新操作。\n\n### 2 日志系统：一条SQL更新语句是如何执行的？\n\nMysql中的Binlog有2种模式，statement模式记录的是sql语句，row格式会记录的行的内容，记录2条，更新前和更新后。\n\nMysql默认执行引擎Innodb的redo log 记录数据页有什么改动。\n\nrelog采用2阶段提交保证和binlog的一致性。\n\n**日志系统使用场景**\n\n当误操作后或多搭建一个读库的时候，现在常见的做法就是全量备份和加上Binlog来实现的。如果relog和binlog不一致，会导致恢复的数据库数据不一致或主从数据库不一致的情况发生。\n\n**日志系统参数配置**\n\ninnodb_flush_log_at_trx_commit 这个参数设置成1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。\n\nsync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。\n\n<!--more--> \n\n**日志系统命令**\n\n全量备份命令\n\n```sql\nmysqldump -u[username] -p[password]  [database] [table] > backup.sql\n```\n\n恢复备份命令\n\n```sql\nmysql -u[username] -p[password] [database] < backup.sql\n```\n\n当然也可以用Mysql可视化工具进行备份。\n\n### 3 事务隔离：为什么你改了我还看不见？\n\n在一个事务里，实际上每条记录在更新的时候都会同时记录一条回滚日志操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。\n\n**大事务的弊端**\n\n- 大事务会导致记录大量的回滚操作，在这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。\n- 大事务还占用锁资源，提高死锁概率，长时间占用连接，也可能拖垮整个库。\n\n **大事务的排查**\n\n在information_schema库的innodb_trx这个表中查询长事务，比如下面这个语句，用于查找持续时间超过60s的事务。 \n\n```sql\nselect * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60\n```\n\n同时也可以排查 Lock wait timeout exceeded; try restarting transaction 异常，找到相应的线程并kill thread id。 锁等待超时。是当前事务在等待其它事务释放锁资源造成的。可以找出锁资源竞争的表和语句。\n\n### 4 深入浅出索引\n\n**回表**\n\n普通索引查询方式，则需要先搜索 普通索引树，得到一个主键索引的值，再到主键 索引树搜索一次。这个过程称为回表。普通索引树的叶子节点是主键值,主键索引树的叶子节点是数据。所以，普通索引树比主键索引树小很多。回表是一行行地查数据，因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。\n\n**覆盖索引**\n\n```sql\nselect ID from T where k between 3 and 5\n```\n\n这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。不再需要回表查整行记录，减少语句的执行时间。\n\n联合索引（a,b）也可以达到覆盖索引的要求。假如现在有个查询是\n\n```sql\nselect b from T where a = x\n```\n\n这样也不用回表了。","source":"_posts/Mysql实战-学习笔记(1).md","raw":"---\ntitle: Mysql实战-学习笔记(1)\ndate: 2019-10-18 21:43:08\ntags: Mysql\n---\n\n### 1 一条SQL查询语句是如何执行的？\n\n创建数据库连接，SQL经过分析器分析语义，优化器选择合适的索引，选择最佳的执行方案，最后执行器执行。\n\n如果是更新语句，先是查找到这行，然后才执行更新操作。\n\n### 2 日志系统：一条SQL更新语句是如何执行的？\n\nMysql中的Binlog有2种模式，statement模式记录的是sql语句，row格式会记录的行的内容，记录2条，更新前和更新后。\n\nMysql默认执行引擎Innodb的redo log 记录数据页有什么改动。\n\nrelog采用2阶段提交保证和binlog的一致性。\n\n**日志系统使用场景**\n\n当误操作后或多搭建一个读库的时候，现在常见的做法就是全量备份和加上Binlog来实现的。如果relog和binlog不一致，会导致恢复的数据库数据不一致或主从数据库不一致的情况发生。\n\n**日志系统参数配置**\n\ninnodb_flush_log_at_trx_commit 这个参数设置成1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。\n\nsync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。\n\n<!--more--> \n\n**日志系统命令**\n\n全量备份命令\n\n```sql\nmysqldump -u[username] -p[password]  [database] [table] > backup.sql\n```\n\n恢复备份命令\n\n```sql\nmysql -u[username] -p[password] [database] < backup.sql\n```\n\n当然也可以用Mysql可视化工具进行备份。\n\n### 3 事务隔离：为什么你改了我还看不见？\n\n在一个事务里，实际上每条记录在更新的时候都会同时记录一条回滚日志操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。\n\n**大事务的弊端**\n\n- 大事务会导致记录大量的回滚操作，在这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。\n- 大事务还占用锁资源，提高死锁概率，长时间占用连接，也可能拖垮整个库。\n\n **大事务的排查**\n\n在information_schema库的innodb_trx这个表中查询长事务，比如下面这个语句，用于查找持续时间超过60s的事务。 \n\n```sql\nselect * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60\n```\n\n同时也可以排查 Lock wait timeout exceeded; try restarting transaction 异常，找到相应的线程并kill thread id。 锁等待超时。是当前事务在等待其它事务释放锁资源造成的。可以找出锁资源竞争的表和语句。\n\n### 4 深入浅出索引\n\n**回表**\n\n普通索引查询方式，则需要先搜索 普通索引树，得到一个主键索引的值，再到主键 索引树搜索一次。这个过程称为回表。普通索引树的叶子节点是主键值,主键索引树的叶子节点是数据。所以，普通索引树比主键索引树小很多。回表是一行行地查数据，因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。\n\n**覆盖索引**\n\n```sql\nselect ID from T where k between 3 and 5\n```\n\n这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。不再需要回表查整行记录，减少语句的执行时间。\n\n联合索引（a,b）也可以达到覆盖索引的要求。假如现在有个查询是\n\n```sql\nselect b from T where a = x\n```\n\n这样也不用回表了。","slug":"Mysql实战-学习笔记(1)","published":1,"updated":"2020-08-09T05:24:13.288Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdmsedz1000blguwgrepi7nb","content":"<h3 id=\"1-一条SQL查询语句是如何执行的？\"><a href=\"#1-一条SQL查询语句是如何执行的？\" class=\"headerlink\" title=\"1 一条SQL查询语句是如何执行的？\"></a>1 一条SQL查询语句是如何执行的？</h3><p>创建数据库连接，SQL经过分析器分析语义，优化器选择合适的索引，选择最佳的执行方案，最后执行器执行。</p>\n<p>如果是更新语句，先是查找到这行，然后才执行更新操作。</p>\n<h3 id=\"2-日志系统：一条SQL更新语句是如何执行的？\"><a href=\"#2-日志系统：一条SQL更新语句是如何执行的？\" class=\"headerlink\" title=\"2 日志系统：一条SQL更新语句是如何执行的？\"></a>2 日志系统：一条SQL更新语句是如何执行的？</h3><p>Mysql中的Binlog有2种模式，statement模式记录的是sql语句，row格式会记录的行的内容，记录2条，更新前和更新后。</p>\n<p>Mysql默认执行引擎Innodb的redo log 记录数据页有什么改动。</p>\n<p>relog采用2阶段提交保证和binlog的一致性。</p>\n<p><strong>日志系统使用场景</strong></p>\n<p>当误操作后或多搭建一个读库的时候，现在常见的做法就是全量备份和加上Binlog来实现的。如果relog和binlog不一致，会导致恢复的数据库数据不一致或主从数据库不一致的情况发生。</p>\n<p><strong>日志系统参数配置</strong></p>\n<p>innodb_flush_log_at_trx_commit 这个参数设置成1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。</p>\n<p>sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。</p>\n<a id=\"more\"></a> \n<p><strong>日志系统命令</strong></p>\n<p>全量备份命令</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysqldump -u[username] -p[password]  [database] [table] &gt; backup.sql</span><br></pre></td></tr></table></figure>\n<p>恢复备份命令</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -u[username] -p[password] [database] &lt; backup.sql</span><br></pre></td></tr></table></figure>\n<p>当然也可以用Mysql可视化工具进行备份。</p>\n<h3 id=\"3-事务隔离：为什么你改了我还看不见？\"><a href=\"#3-事务隔离：为什么你改了我还看不见？\" class=\"headerlink\" title=\"3 事务隔离：为什么你改了我还看不见？\"></a>3 事务隔离：为什么你改了我还看不见？</h3><p>在一个事务里，实际上每条记录在更新的时候都会同时记录一条回滚日志操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p>\n<p><strong>大事务的弊端</strong></p>\n<ul>\n<li>大事务会导致记录大量的回滚操作，在这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</li>\n<li><p>大事务还占用锁资源，提高死锁概率，长时间占用连接，也可能拖垮整个库。</p>\n<p><strong>大事务的排查</strong></p>\n</li>\n</ul>\n<p>在information_schema库的innodb_trx这个表中查询长事务，比如下面这个语句，用于查找持续时间超过60s的事务。 </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> information_schema.innodb_trx <span class=\"keyword\">where</span> TIME_TO_SEC(<span class=\"keyword\">timediff</span>(<span class=\"keyword\">now</span>(),trx_started))&gt;<span class=\"number\">60</span></span><br></pre></td></tr></table></figure>\n<p>同时也可以排查 Lock wait timeout exceeded; try restarting transaction 异常，找到相应的线程并kill thread id。 锁等待超时。是当前事务在等待其它事务释放锁资源造成的。可以找出锁资源竞争的表和语句。</p>\n<h3 id=\"4-深入浅出索引\"><a href=\"#4-深入浅出索引\" class=\"headerlink\" title=\"4 深入浅出索引\"></a>4 深入浅出索引</h3><p><strong>回表</strong></p>\n<p>普通索引查询方式，则需要先搜索 普通索引树，得到一个主键索引的值，再到主键 索引树搜索一次。这个过程称为回表。普通索引树的叶子节点是主键值,主键索引树的叶子节点是数据。所以，普通索引树比主键索引树小很多。回表是一行行地查数据，因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。</p>\n<p><strong>覆盖索引</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">ID</span> <span class=\"keyword\">from</span> T <span class=\"keyword\">where</span> k <span class=\"keyword\">between</span> <span class=\"number\">3</span> <span class=\"keyword\">and</span> <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p>这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。不再需要回表查整行记录，减少语句的执行时间。</p>\n<p>联合索引（a,b）也可以达到覆盖索引的要求。假如现在有个查询是</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> b <span class=\"keyword\">from</span> T <span class=\"keyword\">where</span> a = x</span><br></pre></td></tr></table></figure>\n<p>这样也不用回表了。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-一条SQL查询语句是如何执行的？\"><a href=\"#1-一条SQL查询语句是如何执行的？\" class=\"headerlink\" title=\"1 一条SQL查询语句是如何执行的？\"></a>1 一条SQL查询语句是如何执行的？</h3><p>创建数据库连接，SQL经过分析器分析语义，优化器选择合适的索引，选择最佳的执行方案，最后执行器执行。</p>\n<p>如果是更新语句，先是查找到这行，然后才执行更新操作。</p>\n<h3 id=\"2-日志系统：一条SQL更新语句是如何执行的？\"><a href=\"#2-日志系统：一条SQL更新语句是如何执行的？\" class=\"headerlink\" title=\"2 日志系统：一条SQL更新语句是如何执行的？\"></a>2 日志系统：一条SQL更新语句是如何执行的？</h3><p>Mysql中的Binlog有2种模式，statement模式记录的是sql语句，row格式会记录的行的内容，记录2条，更新前和更新后。</p>\n<p>Mysql默认执行引擎Innodb的redo log 记录数据页有什么改动。</p>\n<p>relog采用2阶段提交保证和binlog的一致性。</p>\n<p><strong>日志系统使用场景</strong></p>\n<p>当误操作后或多搭建一个读库的时候，现在常见的做法就是全量备份和加上Binlog来实现的。如果relog和binlog不一致，会导致恢复的数据库数据不一致或主从数据库不一致的情况发生。</p>\n<p><strong>日志系统参数配置</strong></p>\n<p>innodb_flush_log_at_trx_commit 这个参数设置成1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。</p>\n<p>sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。</p>","more":"<p><strong>日志系统命令</strong></p>\n<p>全量备份命令</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysqldump -u[username] -p[password]  [database] [table] &gt; backup.sql</span><br></pre></td></tr></table></figure>\n<p>恢复备份命令</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -u[username] -p[password] [database] &lt; backup.sql</span><br></pre></td></tr></table></figure>\n<p>当然也可以用Mysql可视化工具进行备份。</p>\n<h3 id=\"3-事务隔离：为什么你改了我还看不见？\"><a href=\"#3-事务隔离：为什么你改了我还看不见？\" class=\"headerlink\" title=\"3 事务隔离：为什么你改了我还看不见？\"></a>3 事务隔离：为什么你改了我还看不见？</h3><p>在一个事务里，实际上每条记录在更新的时候都会同时记录一条回滚日志操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p>\n<p><strong>大事务的弊端</strong></p>\n<ul>\n<li>大事务会导致记录大量的回滚操作，在这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</li>\n<li><p>大事务还占用锁资源，提高死锁概率，长时间占用连接，也可能拖垮整个库。</p>\n<p><strong>大事务的排查</strong></p>\n</li>\n</ul>\n<p>在information_schema库的innodb_trx这个表中查询长事务，比如下面这个语句，用于查找持续时间超过60s的事务。 </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> information_schema.innodb_trx <span class=\"keyword\">where</span> TIME_TO_SEC(<span class=\"keyword\">timediff</span>(<span class=\"keyword\">now</span>(),trx_started))&gt;<span class=\"number\">60</span></span><br></pre></td></tr></table></figure>\n<p>同时也可以排查 Lock wait timeout exceeded; try restarting transaction 异常，找到相应的线程并kill thread id。 锁等待超时。是当前事务在等待其它事务释放锁资源造成的。可以找出锁资源竞争的表和语句。</p>\n<h3 id=\"4-深入浅出索引\"><a href=\"#4-深入浅出索引\" class=\"headerlink\" title=\"4 深入浅出索引\"></a>4 深入浅出索引</h3><p><strong>回表</strong></p>\n<p>普通索引查询方式，则需要先搜索 普通索引树，得到一个主键索引的值，再到主键 索引树搜索一次。这个过程称为回表。普通索引树的叶子节点是主键值,主键索引树的叶子节点是数据。所以，普通索引树比主键索引树小很多。回表是一行行地查数据，因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。</p>\n<p><strong>覆盖索引</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">ID</span> <span class=\"keyword\">from</span> T <span class=\"keyword\">where</span> k <span class=\"keyword\">between</span> <span class=\"number\">3</span> <span class=\"keyword\">and</span> <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p>这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。不再需要回表查整行记录，减少语句的执行时间。</p>\n<p>联合索引（a,b）也可以达到覆盖索引的要求。假如现在有个查询是</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> b <span class=\"keyword\">from</span> T <span class=\"keyword\">where</span> a = x</span><br></pre></td></tr></table></figure>\n<p>这样也不用回表了。</p>"},{"title":"Mysql实战-学习笔记(2)","date":"2019-10-22T13:58:45.000Z","_content":"\n### 7 行锁功过：怎么减少行锁对性能的影响？\n\n**两阶段锁协议**\n\n在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。在一个事务中，把最可能发生锁冲突的SQL语句放在最后，减少锁行的时间。\n\n### 8 事务到底是隔离的还是不隔离的？\n\n**可重复读**\n\n事务 T 启动的时候会创建一个视图 read-view，之后事务 T 执行期间，即使有其他事务修改了数\n据，事务 T 看到的仍然跟在启动时看到的一样。\n\n一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。\n\n<!--more--> \n\n**当前读VS快照读**\n\n当事务隔离级别是可重复读时\n\n- 快照读： 读取的是事务开启前的数据，比如 select。\n\n  ```sql\n  select * from table …\n  ```\n\n- 当前读：总是读取已经提交完成的最新版本。特殊的读操作，插入 / 更新 / 删除操作，属于当前读，处理的都是当前的数据，需要加锁。\n\n  ```sql\n  select * from table where ? lock in share mode; S 锁，Gap 锁\n  \n  select * from table where ? for update; X 锁，Gap 锁\n  \n  insert; X 锁，Gap 锁\n  \n  update ; X 锁，Gap 锁\n  \n  delete; X 锁，Gap 锁\n  ```\n\n  读操作通常加共享锁（Share locks，S锁，又叫读锁），写操作加排它锁（Exclusive locks，X锁，又叫写锁）；加了共享锁的记录，其他事务也可以读，但不能写；加了排它锁的记录，其他事务既不能读，也不能写。 \n\n### 9 普通索引和唯一索引，应该怎么选择？\n\nUpdate语句普通索引会用到change buffer 减少磁盘IO，先把数据记录到change buffer,然后当查询的时候触发merge将数据同步到磁盘上，从而达到比唯一索引快的目的。但是针对于更新完后，立即访问对应的数据页，会增加了change buffer维护代价。\n\n### 13 为什么表数据删掉一半，表文件大小不变？\n\ndelete删除数据，但是实际上数据页并没有被删除，而是留着被复用。如果要减小文件大小通过 optimize table t 。通过如下程序实验，先通过存储过程idata新增数据然后查询表文件大小，后delete删除后发现表文件大小没变，最后通过optimize table t 来减少了表文件大小。\n\n```sql\nbegin\ndeclare i int;\nset i=1000;\nwhile(i<=10000)do\ninsert into user values(i, i);\nset i=i+1;\nend while;\nend\n```\n\n```sql\nselect concat(round(sum(DATA_LENGTH/1024/1024),2),'M') from tables;\nCALL idata();\nselect concat(round(sum(DATA_LENGTH/1024/1024),2),'M') from tables;\nDELETE FROM `user` where user_id > 6;\nselect concat(round(sum(DATA_LENGTH/1024/1024),2),'M') from tables;\noptimize table `user`;\n```\n\n### 15 临时表\n\n建表语法是 \n\n```sql\ncreate temporary table …\n```\n\n临时表只能被创建它的 session 访问，所以在这个 session 结束的时候，会自动删除临时表。\n\n### 16 Join使用注意\n\n1. 小标表作为驱动表。\n2. 在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与 join 的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。","source":"_posts/Mysql实战-学习笔记(2).md","raw":"---\ntitle: Mysql实战-学习笔记(2)\ndate: 2019-10-22 21:58:45\ntags: Mysql\n---\n\n### 7 行锁功过：怎么减少行锁对性能的影响？\n\n**两阶段锁协议**\n\n在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。在一个事务中，把最可能发生锁冲突的SQL语句放在最后，减少锁行的时间。\n\n### 8 事务到底是隔离的还是不隔离的？\n\n**可重复读**\n\n事务 T 启动的时候会创建一个视图 read-view，之后事务 T 执行期间，即使有其他事务修改了数\n据，事务 T 看到的仍然跟在启动时看到的一样。\n\n一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。\n\n<!--more--> \n\n**当前读VS快照读**\n\n当事务隔离级别是可重复读时\n\n- 快照读： 读取的是事务开启前的数据，比如 select。\n\n  ```sql\n  select * from table …\n  ```\n\n- 当前读：总是读取已经提交完成的最新版本。特殊的读操作，插入 / 更新 / 删除操作，属于当前读，处理的都是当前的数据，需要加锁。\n\n  ```sql\n  select * from table where ? lock in share mode; S 锁，Gap 锁\n  \n  select * from table where ? for update; X 锁，Gap 锁\n  \n  insert; X 锁，Gap 锁\n  \n  update ; X 锁，Gap 锁\n  \n  delete; X 锁，Gap 锁\n  ```\n\n  读操作通常加共享锁（Share locks，S锁，又叫读锁），写操作加排它锁（Exclusive locks，X锁，又叫写锁）；加了共享锁的记录，其他事务也可以读，但不能写；加了排它锁的记录，其他事务既不能读，也不能写。 \n\n### 9 普通索引和唯一索引，应该怎么选择？\n\nUpdate语句普通索引会用到change buffer 减少磁盘IO，先把数据记录到change buffer,然后当查询的时候触发merge将数据同步到磁盘上，从而达到比唯一索引快的目的。但是针对于更新完后，立即访问对应的数据页，会增加了change buffer维护代价。\n\n### 13 为什么表数据删掉一半，表文件大小不变？\n\ndelete删除数据，但是实际上数据页并没有被删除，而是留着被复用。如果要减小文件大小通过 optimize table t 。通过如下程序实验，先通过存储过程idata新增数据然后查询表文件大小，后delete删除后发现表文件大小没变，最后通过optimize table t 来减少了表文件大小。\n\n```sql\nbegin\ndeclare i int;\nset i=1000;\nwhile(i<=10000)do\ninsert into user values(i, i);\nset i=i+1;\nend while;\nend\n```\n\n```sql\nselect concat(round(sum(DATA_LENGTH/1024/1024),2),'M') from tables;\nCALL idata();\nselect concat(round(sum(DATA_LENGTH/1024/1024),2),'M') from tables;\nDELETE FROM `user` where user_id > 6;\nselect concat(round(sum(DATA_LENGTH/1024/1024),2),'M') from tables;\noptimize table `user`;\n```\n\n### 15 临时表\n\n建表语法是 \n\n```sql\ncreate temporary table …\n```\n\n临时表只能被创建它的 session 访问，所以在这个 session 结束的时候，会自动删除临时表。\n\n### 16 Join使用注意\n\n1. 小标表作为驱动表。\n2. 在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与 join 的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。","slug":"Mysql实战-学习笔记(2)","published":1,"updated":"2020-08-09T05:24:13.289Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdmsedz5000clguw16ixg23g","content":"<h3 id=\"7-行锁功过：怎么减少行锁对性能的影响？\"><a href=\"#7-行锁功过：怎么减少行锁对性能的影响？\" class=\"headerlink\" title=\"7 行锁功过：怎么减少行锁对性能的影响？\"></a>7 行锁功过：怎么减少行锁对性能的影响？</h3><p><strong>两阶段锁协议</strong></p>\n<p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。在一个事务中，把最可能发生锁冲突的SQL语句放在最后，减少锁行的时间。</p>\n<h3 id=\"8-事务到底是隔离的还是不隔离的？\"><a href=\"#8-事务到底是隔离的还是不隔离的？\" class=\"headerlink\" title=\"8 事务到底是隔离的还是不隔离的？\"></a>8 事务到底是隔离的还是不隔离的？</h3><p><strong>可重复读</strong></p>\n<p>事务 T 启动的时候会创建一个视图 read-view，之后事务 T 执行期间，即使有其他事务修改了数<br>据，事务 T 看到的仍然跟在启动时看到的一样。</p>\n<p>一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。</p>\n<a id=\"more\"></a> \n<p><strong>当前读VS快照读</strong></p>\n<p>当事务隔离级别是可重复读时</p>\n<ul>\n<li><p>快照读： 读取的是事务开启前的数据，比如 select。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> …</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>当前读：总是读取已经提交完成的最新版本。特殊的读操作，插入 / 更新 / 删除操作，属于当前读，处理的都是当前的数据，需要加锁。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> ? <span class=\"keyword\">lock</span> <span class=\"keyword\">in</span> <span class=\"keyword\">share</span> <span class=\"keyword\">mode</span>; S 锁，Gap 锁</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> ? <span class=\"keyword\">for</span> <span class=\"keyword\">update</span>; X 锁，Gap 锁</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">insert</span>; X 锁，Gap 锁</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">update</span> ; X 锁，Gap 锁</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span>; X 锁，Gap 锁</span><br></pre></td></tr></table></figure>\n<p>读操作通常加共享锁（Share locks，S锁，又叫读锁），写操作加排它锁（Exclusive locks，X锁，又叫写锁）；加了共享锁的记录，其他事务也可以读，但不能写；加了排它锁的记录，其他事务既不能读，也不能写。 </p>\n</li>\n</ul>\n<h3 id=\"9-普通索引和唯一索引，应该怎么选择？\"><a href=\"#9-普通索引和唯一索引，应该怎么选择？\" class=\"headerlink\" title=\"9 普通索引和唯一索引，应该怎么选择？\"></a>9 普通索引和唯一索引，应该怎么选择？</h3><p>Update语句普通索引会用到change buffer 减少磁盘IO，先把数据记录到change buffer,然后当查询的时候触发merge将数据同步到磁盘上，从而达到比唯一索引快的目的。但是针对于更新完后，立即访问对应的数据页，会增加了change buffer维护代价。</p>\n<h3 id=\"13-为什么表数据删掉一半，表文件大小不变？\"><a href=\"#13-为什么表数据删掉一半，表文件大小不变？\" class=\"headerlink\" title=\"13 为什么表数据删掉一半，表文件大小不变？\"></a>13 为什么表数据删掉一半，表文件大小不变？</h3><p>delete删除数据，但是实际上数据页并没有被删除，而是留着被复用。如果要减小文件大小通过 optimize table t 。通过如下程序实验，先通过存储过程idata新增数据然后查询表文件大小，后delete删除后发现表文件大小没变，最后通过optimize table t 来减少了表文件大小。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> i <span class=\"built_in\">int</span>;</span><br><span class=\"line\"><span class=\"keyword\">set</span> i=<span class=\"number\">1000</span>;</span><br><span class=\"line\">while(i&lt;=10000)do</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> <span class=\"keyword\">user</span> <span class=\"keyword\">values</span>(i, i);</span><br><span class=\"line\"><span class=\"keyword\">set</span> i=i+<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">end</span> <span class=\"keyword\">while</span>;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">concat</span>(<span class=\"keyword\">round</span>(<span class=\"keyword\">sum</span>(DATA_LENGTH/<span class=\"number\">1024</span>/<span class=\"number\">1024</span>),<span class=\"number\">2</span>),<span class=\"string\">'M'</span>) <span class=\"keyword\">from</span> <span class=\"keyword\">tables</span>;</span><br><span class=\"line\"><span class=\"keyword\">CALL</span> idata();</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">concat</span>(<span class=\"keyword\">round</span>(<span class=\"keyword\">sum</span>(DATA_LENGTH/<span class=\"number\">1024</span>/<span class=\"number\">1024</span>),<span class=\"number\">2</span>),<span class=\"string\">'M'</span>) <span class=\"keyword\">from</span> <span class=\"keyword\">tables</span>;</span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> <span class=\"string\">`user`</span> <span class=\"keyword\">where</span> user_id &gt; <span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">concat</span>(<span class=\"keyword\">round</span>(<span class=\"keyword\">sum</span>(DATA_LENGTH/<span class=\"number\">1024</span>/<span class=\"number\">1024</span>),<span class=\"number\">2</span>),<span class=\"string\">'M'</span>) <span class=\"keyword\">from</span> <span class=\"keyword\">tables</span>;</span><br><span class=\"line\"><span class=\"keyword\">optimize</span> <span class=\"keyword\">table</span> <span class=\"string\">`user`</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"15-临时表\"><a href=\"#15-临时表\" class=\"headerlink\" title=\"15 临时表\"></a>15 临时表</h3><p>建表语法是 </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">temporary</span> <span class=\"keyword\">table</span> …</span><br></pre></td></tr></table></figure>\n<p>临时表只能被创建它的 session 访问，所以在这个 session 结束的时候，会自动删除临时表。</p>\n<h3 id=\"16-Join使用注意\"><a href=\"#16-Join使用注意\" class=\"headerlink\" title=\"16 Join使用注意\"></a>16 Join使用注意</h3><ol>\n<li>小标表作为驱动表。</li>\n<li>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与 join 的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"7-行锁功过：怎么减少行锁对性能的影响？\"><a href=\"#7-行锁功过：怎么减少行锁对性能的影响？\" class=\"headerlink\" title=\"7 行锁功过：怎么减少行锁对性能的影响？\"></a>7 行锁功过：怎么减少行锁对性能的影响？</h3><p><strong>两阶段锁协议</strong></p>\n<p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。在一个事务中，把最可能发生锁冲突的SQL语句放在最后，减少锁行的时间。</p>\n<h3 id=\"8-事务到底是隔离的还是不隔离的？\"><a href=\"#8-事务到底是隔离的还是不隔离的？\" class=\"headerlink\" title=\"8 事务到底是隔离的还是不隔离的？\"></a>8 事务到底是隔离的还是不隔离的？</h3><p><strong>可重复读</strong></p>\n<p>事务 T 启动的时候会创建一个视图 read-view，之后事务 T 执行期间，即使有其他事务修改了数<br>据，事务 T 看到的仍然跟在启动时看到的一样。</p>\n<p>一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。</p>","more":"<p><strong>当前读VS快照读</strong></p>\n<p>当事务隔离级别是可重复读时</p>\n<ul>\n<li><p>快照读： 读取的是事务开启前的数据，比如 select。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> …</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>当前读：总是读取已经提交完成的最新版本。特殊的读操作，插入 / 更新 / 删除操作，属于当前读，处理的都是当前的数据，需要加锁。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> ? <span class=\"keyword\">lock</span> <span class=\"keyword\">in</span> <span class=\"keyword\">share</span> <span class=\"keyword\">mode</span>; S 锁，Gap 锁</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> ? <span class=\"keyword\">for</span> <span class=\"keyword\">update</span>; X 锁，Gap 锁</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">insert</span>; X 锁，Gap 锁</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">update</span> ; X 锁，Gap 锁</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span>; X 锁，Gap 锁</span><br></pre></td></tr></table></figure>\n<p>读操作通常加共享锁（Share locks，S锁，又叫读锁），写操作加排它锁（Exclusive locks，X锁，又叫写锁）；加了共享锁的记录，其他事务也可以读，但不能写；加了排它锁的记录，其他事务既不能读，也不能写。 </p>\n</li>\n</ul>\n<h3 id=\"9-普通索引和唯一索引，应该怎么选择？\"><a href=\"#9-普通索引和唯一索引，应该怎么选择？\" class=\"headerlink\" title=\"9 普通索引和唯一索引，应该怎么选择？\"></a>9 普通索引和唯一索引，应该怎么选择？</h3><p>Update语句普通索引会用到change buffer 减少磁盘IO，先把数据记录到change buffer,然后当查询的时候触发merge将数据同步到磁盘上，从而达到比唯一索引快的目的。但是针对于更新完后，立即访问对应的数据页，会增加了change buffer维护代价。</p>\n<h3 id=\"13-为什么表数据删掉一半，表文件大小不变？\"><a href=\"#13-为什么表数据删掉一半，表文件大小不变？\" class=\"headerlink\" title=\"13 为什么表数据删掉一半，表文件大小不变？\"></a>13 为什么表数据删掉一半，表文件大小不变？</h3><p>delete删除数据，但是实际上数据页并没有被删除，而是留着被复用。如果要减小文件大小通过 optimize table t 。通过如下程序实验，先通过存储过程idata新增数据然后查询表文件大小，后delete删除后发现表文件大小没变，最后通过optimize table t 来减少了表文件大小。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> i <span class=\"built_in\">int</span>;</span><br><span class=\"line\"><span class=\"keyword\">set</span> i=<span class=\"number\">1000</span>;</span><br><span class=\"line\">while(i&lt;=10000)do</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> <span class=\"keyword\">user</span> <span class=\"keyword\">values</span>(i, i);</span><br><span class=\"line\"><span class=\"keyword\">set</span> i=i+<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">end</span> <span class=\"keyword\">while</span>;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">concat</span>(<span class=\"keyword\">round</span>(<span class=\"keyword\">sum</span>(DATA_LENGTH/<span class=\"number\">1024</span>/<span class=\"number\">1024</span>),<span class=\"number\">2</span>),<span class=\"string\">'M'</span>) <span class=\"keyword\">from</span> <span class=\"keyword\">tables</span>;</span><br><span class=\"line\"><span class=\"keyword\">CALL</span> idata();</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">concat</span>(<span class=\"keyword\">round</span>(<span class=\"keyword\">sum</span>(DATA_LENGTH/<span class=\"number\">1024</span>/<span class=\"number\">1024</span>),<span class=\"number\">2</span>),<span class=\"string\">'M'</span>) <span class=\"keyword\">from</span> <span class=\"keyword\">tables</span>;</span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> <span class=\"string\">`user`</span> <span class=\"keyword\">where</span> user_id &gt; <span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">concat</span>(<span class=\"keyword\">round</span>(<span class=\"keyword\">sum</span>(DATA_LENGTH/<span class=\"number\">1024</span>/<span class=\"number\">1024</span>),<span class=\"number\">2</span>),<span class=\"string\">'M'</span>) <span class=\"keyword\">from</span> <span class=\"keyword\">tables</span>;</span><br><span class=\"line\"><span class=\"keyword\">optimize</span> <span class=\"keyword\">table</span> <span class=\"string\">`user`</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"15-临时表\"><a href=\"#15-临时表\" class=\"headerlink\" title=\"15 临时表\"></a>15 临时表</h3><p>建表语法是 </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">temporary</span> <span class=\"keyword\">table</span> …</span><br></pre></td></tr></table></figure>\n<p>临时表只能被创建它的 session 访问，所以在这个 session 结束的时候，会自动删除临时表。</p>\n<h3 id=\"16-Join使用注意\"><a href=\"#16-Join使用注意\" class=\"headerlink\" title=\"16 Join使用注意\"></a>16 Join使用注意</h3><ol>\n<li>小标表作为驱动表。</li>\n<li>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与 join 的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</li>\n</ol>"},{"title":"NIO初识","date":"2020-05-06T11:16:59.000Z","_content":"### 1.NIO概念\n\n同步非阻塞IO(socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作是同步阻塞的)，通常用于网络服务器进行多路复用IO。Redis，Nginx, Tomcat8.X采用这种方式，RabbitMQ采用类似这种思想。\n\n![IO多路复用.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gdqtd66t03j20gb05f0tw.jpg)\n\n以nginx为例，ngnix会有很多请求进来， epoll会把他们都监视起来，然后像拨开关一样，谁有数据就拨向谁，然后调用相应的代码处理。\n\n### 2.epoll\n\nepoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I/O事件通知我们。此时我们对这些流的操作都是有意义的。（复杂度降低到了O(k)，k为产生I/O事件的流的个数)。\n\n### 3.selector \n\n新事件(读就绪、写就绪、有新连接到来)到来的时候，会在selector上注册标记位，标示可读、可写或者有连接到来。\n\n**Selector.select()**是阻塞的，通过操作系统的通知（epoll）这个函数是阻塞的。可以在一个while(true)里面调用这个函数而不用担心CPU空转。","source":"_posts/NIO初识.md","raw":"---\ntitle: NIO初识\ndate: 2020-05-06 19:16:59\ntags: Java\n---\n### 1.NIO概念\n\n同步非阻塞IO(socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作是同步阻塞的)，通常用于网络服务器进行多路复用IO。Redis，Nginx, Tomcat8.X采用这种方式，RabbitMQ采用类似这种思想。\n\n![IO多路复用.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gdqtd66t03j20gb05f0tw.jpg)\n\n以nginx为例，ngnix会有很多请求进来， epoll会把他们都监视起来，然后像拨开关一样，谁有数据就拨向谁，然后调用相应的代码处理。\n\n### 2.epoll\n\nepoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I/O事件通知我们。此时我们对这些流的操作都是有意义的。（复杂度降低到了O(k)，k为产生I/O事件的流的个数)。\n\n### 3.selector \n\n新事件(读就绪、写就绪、有新连接到来)到来的时候，会在selector上注册标记位，标示可读、可写或者有连接到来。\n\n**Selector.select()**是阻塞的，通过操作系统的通知（epoll）这个函数是阻塞的。可以在一个while(true)里面调用这个函数而不用担心CPU空转。","slug":"NIO初识","published":1,"updated":"2020-08-09T05:24:13.289Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdmsedz9000elguws3083ntb","content":"<h3 id=\"1-NIO概念\"><a href=\"#1-NIO概念\" class=\"headerlink\" title=\"1.NIO概念\"></a>1.NIO概念</h3><p>同步非阻塞IO(socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作是同步阻塞的)，通常用于网络服务器进行多路复用IO。Redis，Nginx, Tomcat8.X采用这种方式，RabbitMQ采用类似这种思想。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gdqtd66t03j20gb05f0tw.jpg\" alt=\"IO多路复用.png\"></p>\n<p>以nginx为例，ngnix会有很多请求进来， epoll会把他们都监视起来，然后像拨开关一样，谁有数据就拨向谁，然后调用相应的代码处理。</p>\n<h3 id=\"2-epoll\"><a href=\"#2-epoll\" class=\"headerlink\" title=\"2.epoll\"></a>2.epoll</h3><p>epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I/O事件通知我们。此时我们对这些流的操作都是有意义的。（复杂度降低到了O(k)，k为产生I/O事件的流的个数)。</p>\n<h3 id=\"3-selector\"><a href=\"#3-selector\" class=\"headerlink\" title=\"3.selector\"></a>3.selector</h3><p>新事件(读就绪、写就绪、有新连接到来)到来的时候，会在selector上注册标记位，标示可读、可写或者有连接到来。</p>\n<p><strong>Selector.select()</strong>是阻塞的，通过操作系统的通知（epoll）这个函数是阻塞的。可以在一个while(true)里面调用这个函数而不用担心CPU空转。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-NIO概念\"><a href=\"#1-NIO概念\" class=\"headerlink\" title=\"1.NIO概念\"></a>1.NIO概念</h3><p>同步非阻塞IO(socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作是同步阻塞的)，通常用于网络服务器进行多路复用IO。Redis，Nginx, Tomcat8.X采用这种方式，RabbitMQ采用类似这种思想。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gdqtd66t03j20gb05f0tw.jpg\" alt=\"IO多路复用.png\"></p>\n<p>以nginx为例，ngnix会有很多请求进来， epoll会把他们都监视起来，然后像拨开关一样，谁有数据就拨向谁，然后调用相应的代码处理。</p>\n<h3 id=\"2-epoll\"><a href=\"#2-epoll\" class=\"headerlink\" title=\"2.epoll\"></a>2.epoll</h3><p>epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I/O事件通知我们。此时我们对这些流的操作都是有意义的。（复杂度降低到了O(k)，k为产生I/O事件的流的个数)。</p>\n<h3 id=\"3-selector\"><a href=\"#3-selector\" class=\"headerlink\" title=\"3.selector\"></a>3.selector</h3><p>新事件(读就绪、写就绪、有新连接到来)到来的时候，会在selector上注册标记位，标示可读、可写或者有连接到来。</p>\n<p><strong>Selector.select()</strong>是阻塞的，通过操作系统的通知（epoll）这个函数是阻塞的。可以在一个while(true)里面调用这个函数而不用担心CPU空转。</p>\n"},{"title":"OKR学习","date":"2020-02-03T14:07:56.000Z","_content":"### 1. OKR与心理学\n\n在人性角度上讲，承诺的事情就要去努力做到。深层次来看，OKR便恰恰体现了这样一种“承诺”精神，这也是社会心理学中提到的“承诺和一致原理”，即人们通常**会将自己的承诺与行动保持一致**。此外，当我们看到许多人在同时做某件事情时，自己也会跟着去效仿，这就是社会心理学中所提到的“**从众心理**”。\n\n<!--more--> \n\n### 2. OKR制定注意事项\n\nO：\n\n- 方向明确：目标不能太抽象，也不能含混不清，要让每个人都能看得懂。\n- 目标对齐：下级要对齐上级的目标，即向上对齐，平级还要相互对齐，即水平对齐。\n-  时间限制：目标需要有时间边界，不能遥遥无期，而且时间边界要恰到好处。\n- **O 尽可能要以动词形式开头。例如：打造……、建设……、实现……。**\n- O 最好能附上一句目标描述。建议为 O 增加一句话描述，就“为何我要写这个目\n  标？”这一问题，来向大家讲解。\n\nKR：\n\n- 有挑战性：关键结果要有挑战性，拒绝平庸，拒绝不切实际，要做到“跳一跳，就能够\n  得着”。\n- 容易度量：无法度量的关键结果是没有任何意义的，宁可抛弃。\n- 不是任务：关键结果需要对目标产生直接影响，它不是日常任务，也不是行动计划。\n\nO 和 KR 之间是“一对多”的关系。既然 OKR 需要考虑时间限制，最多不要超过 3个，否则就容易导致精力有限，不够聚焦。每个 O 所包含的 KR 也无需太多，最多也不要超过 3 个。\n\n![OKR使用流程.png](http://ww1.sinaimg.cn/large/aacc02d8ly1gbjkfbmdgdj20ri0ap3zp.jpg)\n\n![OKR制定技巧.png](http://ww1.sinaimg.cn/large/aacc02d8ly1gbjkg54iuwj20sz0f90wb.jpg)\n\n### 3. OKR与KPI区别\n\n- KPI是是由上级领导制定，自己需要去执行，中间难免会有“讨价还价”的过程；OKR是根据上级领导的KR来制定自己的OKR，能激发其主观能动性。\n- KPI 是工业时代下的产物，它提倡用结果来说话，进而减少过程中的管理成本。适合于重复\n  性机械劳动比如拧螺丝钉。OKR是互联网时代下的产物，更适合用探索型工作，没有现成的指令和方法可以遵循。\n\nOKR与KPI结合使用：**KPI 中包括的绩效指标一定是只看结果，而不看过程的，只要结果达到了就行，而 OKR 需要更多地关心过程，从结果中判断目标的具体达成情况。**\n\n### 4. OKR的对齐\n\n- 不建议将上级 KR 变成下级 O，这样会降低 OKR 系统的稳定性。比如，如果上级 KR 变化，就会导致下级 O 变化，从而导致下级 KR 变化。\n- OKR 所提倡的“对齐”指的是在 O 上做出支撑，下级需要支撑上级的 O，平级之间也要相互支撑，然而 KR 只是为了支撑自己的 O。\n\n### 5. OKR使用不当\n\nOKR 是自驱力较强的人自我成长的利器，一定要了解 OKR 的这一特性：OKR 落地不需要让人在后面不断催促，然后才能出结果的。否则，就必然会适得其反。在这过程中，如果你用了 OKR，反而让大家产生了更大的压力，那就起反作用了，因此也失去了OKR 原本的“功效”。\n\n### 6. OKR评分\n\n- 1.0 分：不可能做到，但实际做到了。\n- 0.7 分：希望能做到，实际也做到了。\n- 0.3 分：肯定能做到，实际也做到了。\n- 0 分：肯定能做到，但实际没做到。\n\nOKR 评分不是跟别人比，而是跟自己的过去比，自己有没有进步？有没有超越过去的自己？\n\n![评分和信心指数关系.png](http://ww1.sinaimg.cn/large/aacc02d8ly1gbjkhb899lj20oi0by0tf.jpg)\n\n\n\n","source":"_posts/OKR学习.md","raw":"---\ntitle: OKR学习\ndate: 2020-02-03 22:07:56\ntags: 个人提升\n---\n### 1. OKR与心理学\n\n在人性角度上讲，承诺的事情就要去努力做到。深层次来看，OKR便恰恰体现了这样一种“承诺”精神，这也是社会心理学中提到的“承诺和一致原理”，即人们通常**会将自己的承诺与行动保持一致**。此外，当我们看到许多人在同时做某件事情时，自己也会跟着去效仿，这就是社会心理学中所提到的“**从众心理**”。\n\n<!--more--> \n\n### 2. OKR制定注意事项\n\nO：\n\n- 方向明确：目标不能太抽象，也不能含混不清，要让每个人都能看得懂。\n- 目标对齐：下级要对齐上级的目标，即向上对齐，平级还要相互对齐，即水平对齐。\n-  时间限制：目标需要有时间边界，不能遥遥无期，而且时间边界要恰到好处。\n- **O 尽可能要以动词形式开头。例如：打造……、建设……、实现……。**\n- O 最好能附上一句目标描述。建议为 O 增加一句话描述，就“为何我要写这个目\n  标？”这一问题，来向大家讲解。\n\nKR：\n\n- 有挑战性：关键结果要有挑战性，拒绝平庸，拒绝不切实际，要做到“跳一跳，就能够\n  得着”。\n- 容易度量：无法度量的关键结果是没有任何意义的，宁可抛弃。\n- 不是任务：关键结果需要对目标产生直接影响，它不是日常任务，也不是行动计划。\n\nO 和 KR 之间是“一对多”的关系。既然 OKR 需要考虑时间限制，最多不要超过 3个，否则就容易导致精力有限，不够聚焦。每个 O 所包含的 KR 也无需太多，最多也不要超过 3 个。\n\n![OKR使用流程.png](http://ww1.sinaimg.cn/large/aacc02d8ly1gbjkfbmdgdj20ri0ap3zp.jpg)\n\n![OKR制定技巧.png](http://ww1.sinaimg.cn/large/aacc02d8ly1gbjkg54iuwj20sz0f90wb.jpg)\n\n### 3. OKR与KPI区别\n\n- KPI是是由上级领导制定，自己需要去执行，中间难免会有“讨价还价”的过程；OKR是根据上级领导的KR来制定自己的OKR，能激发其主观能动性。\n- KPI 是工业时代下的产物，它提倡用结果来说话，进而减少过程中的管理成本。适合于重复\n  性机械劳动比如拧螺丝钉。OKR是互联网时代下的产物，更适合用探索型工作，没有现成的指令和方法可以遵循。\n\nOKR与KPI结合使用：**KPI 中包括的绩效指标一定是只看结果，而不看过程的，只要结果达到了就行，而 OKR 需要更多地关心过程，从结果中判断目标的具体达成情况。**\n\n### 4. OKR的对齐\n\n- 不建议将上级 KR 变成下级 O，这样会降低 OKR 系统的稳定性。比如，如果上级 KR 变化，就会导致下级 O 变化，从而导致下级 KR 变化。\n- OKR 所提倡的“对齐”指的是在 O 上做出支撑，下级需要支撑上级的 O，平级之间也要相互支撑，然而 KR 只是为了支撑自己的 O。\n\n### 5. OKR使用不当\n\nOKR 是自驱力较强的人自我成长的利器，一定要了解 OKR 的这一特性：OKR 落地不需要让人在后面不断催促，然后才能出结果的。否则，就必然会适得其反。在这过程中，如果你用了 OKR，反而让大家产生了更大的压力，那就起反作用了，因此也失去了OKR 原本的“功效”。\n\n### 6. OKR评分\n\n- 1.0 分：不可能做到，但实际做到了。\n- 0.7 分：希望能做到，实际也做到了。\n- 0.3 分：肯定能做到，实际也做到了。\n- 0 分：肯定能做到，但实际没做到。\n\nOKR 评分不是跟别人比，而是跟自己的过去比，自己有没有进步？有没有超越过去的自己？\n\n![评分和信心指数关系.png](http://ww1.sinaimg.cn/large/aacc02d8ly1gbjkhb899lj20oi0by0tf.jpg)\n\n\n\n","slug":"OKR学习","published":1,"updated":"2020-08-09T05:24:13.290Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdmsedzc000glguw5e2nrpwk","content":"<h3 id=\"1-OKR与心理学\"><a href=\"#1-OKR与心理学\" class=\"headerlink\" title=\"1. OKR与心理学\"></a>1. OKR与心理学</h3><p>在人性角度上讲，承诺的事情就要去努力做到。深层次来看，OKR便恰恰体现了这样一种“承诺”精神，这也是社会心理学中提到的“承诺和一致原理”，即人们通常<strong>会将自己的承诺与行动保持一致</strong>。此外，当我们看到许多人在同时做某件事情时，自己也会跟着去效仿，这就是社会心理学中所提到的“<strong>从众心理</strong>”。</p>\n<a id=\"more\"></a> \n<h3 id=\"2-OKR制定注意事项\"><a href=\"#2-OKR制定注意事项\" class=\"headerlink\" title=\"2. OKR制定注意事项\"></a>2. OKR制定注意事项</h3><p>O：</p>\n<ul>\n<li>方向明确：目标不能太抽象，也不能含混不清，要让每个人都能看得懂。</li>\n<li>目标对齐：下级要对齐上级的目标，即向上对齐，平级还要相互对齐，即水平对齐。</li>\n<li>时间限制：目标需要有时间边界，不能遥遥无期，而且时间边界要恰到好处。</li>\n<li><strong>O 尽可能要以动词形式开头。例如：打造……、建设……、实现……。</strong></li>\n<li>O 最好能附上一句目标描述。建议为 O 增加一句话描述，就“为何我要写这个目<br>标？”这一问题，来向大家讲解。</li>\n</ul>\n<p>KR：</p>\n<ul>\n<li>有挑战性：关键结果要有挑战性，拒绝平庸，拒绝不切实际，要做到“跳一跳，就能够<br>得着”。</li>\n<li>容易度量：无法度量的关键结果是没有任何意义的，宁可抛弃。</li>\n<li>不是任务：关键结果需要对目标产生直接影响，它不是日常任务，也不是行动计划。</li>\n</ul>\n<p>O 和 KR 之间是“一对多”的关系。既然 OKR 需要考虑时间限制，最多不要超过 3个，否则就容易导致精力有限，不够聚焦。每个 O 所包含的 KR 也无需太多，最多也不要超过 3 个。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1gbjkfbmdgdj20ri0ap3zp.jpg\" alt=\"OKR使用流程.png\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1gbjkg54iuwj20sz0f90wb.jpg\" alt=\"OKR制定技巧.png\"></p>\n<h3 id=\"3-OKR与KPI区别\"><a href=\"#3-OKR与KPI区别\" class=\"headerlink\" title=\"3. OKR与KPI区别\"></a>3. OKR与KPI区别</h3><ul>\n<li>KPI是是由上级领导制定，自己需要去执行，中间难免会有“讨价还价”的过程；OKR是根据上级领导的KR来制定自己的OKR，能激发其主观能动性。</li>\n<li>KPI 是工业时代下的产物，它提倡用结果来说话，进而减少过程中的管理成本。适合于重复<br>性机械劳动比如拧螺丝钉。OKR是互联网时代下的产物，更适合用探索型工作，没有现成的指令和方法可以遵循。</li>\n</ul>\n<p>OKR与KPI结合使用：<strong>KPI 中包括的绩效指标一定是只看结果，而不看过程的，只要结果达到了就行，而 OKR 需要更多地关心过程，从结果中判断目标的具体达成情况。</strong></p>\n<h3 id=\"4-OKR的对齐\"><a href=\"#4-OKR的对齐\" class=\"headerlink\" title=\"4. OKR的对齐\"></a>4. OKR的对齐</h3><ul>\n<li>不建议将上级 KR 变成下级 O，这样会降低 OKR 系统的稳定性。比如，如果上级 KR 变化，就会导致下级 O 变化，从而导致下级 KR 变化。</li>\n<li>OKR 所提倡的“对齐”指的是在 O 上做出支撑，下级需要支撑上级的 O，平级之间也要相互支撑，然而 KR 只是为了支撑自己的 O。</li>\n</ul>\n<h3 id=\"5-OKR使用不当\"><a href=\"#5-OKR使用不当\" class=\"headerlink\" title=\"5. OKR使用不当\"></a>5. OKR使用不当</h3><p>OKR 是自驱力较强的人自我成长的利器，一定要了解 OKR 的这一特性：OKR 落地不需要让人在后面不断催促，然后才能出结果的。否则，就必然会适得其反。在这过程中，如果你用了 OKR，反而让大家产生了更大的压力，那就起反作用了，因此也失去了OKR 原本的“功效”。</p>\n<h3 id=\"6-OKR评分\"><a href=\"#6-OKR评分\" class=\"headerlink\" title=\"6. OKR评分\"></a>6. OKR评分</h3><ul>\n<li>1.0 分：不可能做到，但实际做到了。</li>\n<li>0.7 分：希望能做到，实际也做到了。</li>\n<li>0.3 分：肯定能做到，实际也做到了。</li>\n<li>0 分：肯定能做到，但实际没做到。</li>\n</ul>\n<p>OKR 评分不是跟别人比，而是跟自己的过去比，自己有没有进步？有没有超越过去的自己？</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1gbjkhb899lj20oi0by0tf.jpg\" alt=\"评分和信心指数关系.png\"></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-OKR与心理学\"><a href=\"#1-OKR与心理学\" class=\"headerlink\" title=\"1. OKR与心理学\"></a>1. OKR与心理学</h3><p>在人性角度上讲，承诺的事情就要去努力做到。深层次来看，OKR便恰恰体现了这样一种“承诺”精神，这也是社会心理学中提到的“承诺和一致原理”，即人们通常<strong>会将自己的承诺与行动保持一致</strong>。此外，当我们看到许多人在同时做某件事情时，自己也会跟着去效仿，这就是社会心理学中所提到的“<strong>从众心理</strong>”。</p>","more":"<h3 id=\"2-OKR制定注意事项\"><a href=\"#2-OKR制定注意事项\" class=\"headerlink\" title=\"2. OKR制定注意事项\"></a>2. OKR制定注意事项</h3><p>O：</p>\n<ul>\n<li>方向明确：目标不能太抽象，也不能含混不清，要让每个人都能看得懂。</li>\n<li>目标对齐：下级要对齐上级的目标，即向上对齐，平级还要相互对齐，即水平对齐。</li>\n<li>时间限制：目标需要有时间边界，不能遥遥无期，而且时间边界要恰到好处。</li>\n<li><strong>O 尽可能要以动词形式开头。例如：打造……、建设……、实现……。</strong></li>\n<li>O 最好能附上一句目标描述。建议为 O 增加一句话描述，就“为何我要写这个目<br>标？”这一问题，来向大家讲解。</li>\n</ul>\n<p>KR：</p>\n<ul>\n<li>有挑战性：关键结果要有挑战性，拒绝平庸，拒绝不切实际，要做到“跳一跳，就能够<br>得着”。</li>\n<li>容易度量：无法度量的关键结果是没有任何意义的，宁可抛弃。</li>\n<li>不是任务：关键结果需要对目标产生直接影响，它不是日常任务，也不是行动计划。</li>\n</ul>\n<p>O 和 KR 之间是“一对多”的关系。既然 OKR 需要考虑时间限制，最多不要超过 3个，否则就容易导致精力有限，不够聚焦。每个 O 所包含的 KR 也无需太多，最多也不要超过 3 个。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1gbjkfbmdgdj20ri0ap3zp.jpg\" alt=\"OKR使用流程.png\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1gbjkg54iuwj20sz0f90wb.jpg\" alt=\"OKR制定技巧.png\"></p>\n<h3 id=\"3-OKR与KPI区别\"><a href=\"#3-OKR与KPI区别\" class=\"headerlink\" title=\"3. OKR与KPI区别\"></a>3. OKR与KPI区别</h3><ul>\n<li>KPI是是由上级领导制定，自己需要去执行，中间难免会有“讨价还价”的过程；OKR是根据上级领导的KR来制定自己的OKR，能激发其主观能动性。</li>\n<li>KPI 是工业时代下的产物，它提倡用结果来说话，进而减少过程中的管理成本。适合于重复<br>性机械劳动比如拧螺丝钉。OKR是互联网时代下的产物，更适合用探索型工作，没有现成的指令和方法可以遵循。</li>\n</ul>\n<p>OKR与KPI结合使用：<strong>KPI 中包括的绩效指标一定是只看结果，而不看过程的，只要结果达到了就行，而 OKR 需要更多地关心过程，从结果中判断目标的具体达成情况。</strong></p>\n<h3 id=\"4-OKR的对齐\"><a href=\"#4-OKR的对齐\" class=\"headerlink\" title=\"4. OKR的对齐\"></a>4. OKR的对齐</h3><ul>\n<li>不建议将上级 KR 变成下级 O，这样会降低 OKR 系统的稳定性。比如，如果上级 KR 变化，就会导致下级 O 变化，从而导致下级 KR 变化。</li>\n<li>OKR 所提倡的“对齐”指的是在 O 上做出支撑，下级需要支撑上级的 O，平级之间也要相互支撑，然而 KR 只是为了支撑自己的 O。</li>\n</ul>\n<h3 id=\"5-OKR使用不当\"><a href=\"#5-OKR使用不当\" class=\"headerlink\" title=\"5. OKR使用不当\"></a>5. OKR使用不当</h3><p>OKR 是自驱力较强的人自我成长的利器，一定要了解 OKR 的这一特性：OKR 落地不需要让人在后面不断催促，然后才能出结果的。否则，就必然会适得其反。在这过程中，如果你用了 OKR，反而让大家产生了更大的压力，那就起反作用了，因此也失去了OKR 原本的“功效”。</p>\n<h3 id=\"6-OKR评分\"><a href=\"#6-OKR评分\" class=\"headerlink\" title=\"6. OKR评分\"></a>6. OKR评分</h3><ul>\n<li>1.0 分：不可能做到，但实际做到了。</li>\n<li>0.7 分：希望能做到，实际也做到了。</li>\n<li>0.3 分：肯定能做到，实际也做到了。</li>\n<li>0 分：肯定能做到，但实际没做到。</li>\n</ul>\n<p>OKR 评分不是跟别人比，而是跟自己的过去比，自己有没有进步？有没有超越过去的自己？</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1gbjkhb899lj20oi0by0tf.jpg\" alt=\"评分和信心指数关系.png\"></p>"},{"layout":"post","title":"TCP的拥塞控制机制","date":"2017-11-13T10:58:00.000Z","comments":1,"reward":true,"_content":"拥塞控制（congestion control)是TCP协议的一项重要功能，TCP的拥塞控制机制是从端到端的角度，推测网络是否发生拥塞，如果推断网络发生拥塞，则立即将数据发送速率降下来，以便缓解网络拥塞。\n\n<!--more--> \n\nTCP的拥塞控制算法包括了慢启动（slow start）、拥塞避免（congestion avoidance）、快速重传（fast retransmit）和快速恢复（fast recovery）四部分。\n\n\n\n**慢启动（slow start）和拥塞避免（congestion avoidance）控制过程**： \n  -[1]. TCP连接初始化，将拥塞窗口cwind设置为1个报文段，即cwind=1； \n  -[2]. 执行慢开始算法，cwind按指数规律增长，直到cwind == ssthresh时，开始执行拥塞避免算法，cwind按线性规律增长； \n  -[3]. 当网络发生拥塞，把ssthresh值更新为拥塞前ssthresh值的一半，cwind重新设置为1，再按照 [2] 执行。\n\n![慢启动和拥塞避免](http://img.blog.csdn.net/20150925124844736)\n\n**例题：**\n\n设某TCP的拥塞窗口的慢启动门限值初始为8(单位为报文段，且最大报文段长度1KB)，当拥塞窗口上升到12时，网络会发生超时。按照以上给出的条件，第12次传输网拥塞窗口的大小为( )。\n\n- A. 5\n- B. 6\n- C. 7 \n- D. 8\n\n**解析：B**\n\n在慢启动和拥塞避免算法中，拥塞窗口初始值为1，窗口大小开始按指数增长。当拥塞窗口大于慢启动门限后，停止使用慢启动算法，改用拥塞避免算法。此时，慢启动的门限值初始为8，当拥塞窗口增大到8时改用拥塞避免算法，窗口大小按线性增长，毎次增长1个报文段。当增加到12时，出现超时，重新设置门限值为6(12的一半)，拥塞窗口再重新设为1，执行慢启动算法，到门限值为6时执行拥塞避免算法。按照上面的算法，拥塞窗口的变化为1、2、4、8、9、10、11、12、1、2、4、6、7、8、9...，从该序列可以看出，第12次传输时拥塞窗口大小为6。\n\n**注意：**在以上的序列中，6被加粗，原因是很多考生直接从4增加到8，导致误选D选项。原因是拥塞窗口的大小是与门限值有关的，在慢开始算法中不能直接变化为大千门限值，所以4只能最多增加到6，之后再执行拥塞避免算法。","source":"_posts/TCP的拥塞控制机制.md","raw":"---\nlayout: post\ntitle: \"TCP的拥塞控制机制\"\ndate: 2017-11-13 18:58\ncomments: true\nreward: true\ntags: \n\t- 计算机网络\n---\n拥塞控制（congestion control)是TCP协议的一项重要功能，TCP的拥塞控制机制是从端到端的角度，推测网络是否发生拥塞，如果推断网络发生拥塞，则立即将数据发送速率降下来，以便缓解网络拥塞。\n\n<!--more--> \n\nTCP的拥塞控制算法包括了慢启动（slow start）、拥塞避免（congestion avoidance）、快速重传（fast retransmit）和快速恢复（fast recovery）四部分。\n\n\n\n**慢启动（slow start）和拥塞避免（congestion avoidance）控制过程**： \n  -[1]. TCP连接初始化，将拥塞窗口cwind设置为1个报文段，即cwind=1； \n  -[2]. 执行慢开始算法，cwind按指数规律增长，直到cwind == ssthresh时，开始执行拥塞避免算法，cwind按线性规律增长； \n  -[3]. 当网络发生拥塞，把ssthresh值更新为拥塞前ssthresh值的一半，cwind重新设置为1，再按照 [2] 执行。\n\n![慢启动和拥塞避免](http://img.blog.csdn.net/20150925124844736)\n\n**例题：**\n\n设某TCP的拥塞窗口的慢启动门限值初始为8(单位为报文段，且最大报文段长度1KB)，当拥塞窗口上升到12时，网络会发生超时。按照以上给出的条件，第12次传输网拥塞窗口的大小为( )。\n\n- A. 5\n- B. 6\n- C. 7 \n- D. 8\n\n**解析：B**\n\n在慢启动和拥塞避免算法中，拥塞窗口初始值为1，窗口大小开始按指数增长。当拥塞窗口大于慢启动门限后，停止使用慢启动算法，改用拥塞避免算法。此时，慢启动的门限值初始为8，当拥塞窗口增大到8时改用拥塞避免算法，窗口大小按线性增长，毎次增长1个报文段。当增加到12时，出现超时，重新设置门限值为6(12的一半)，拥塞窗口再重新设为1，执行慢启动算法，到门限值为6时执行拥塞避免算法。按照上面的算法，拥塞窗口的变化为1、2、4、8、9、10、11、12、1、2、4、6、7、8、9...，从该序列可以看出，第12次传输时拥塞窗口大小为6。\n\n**注意：**在以上的序列中，6被加粗，原因是很多考生直接从4增加到8，导致误选D选项。原因是拥塞窗口的大小是与门限值有关的，在慢开始算法中不能直接变化为大千门限值，所以4只能最多增加到6，之后再执行拥塞避免算法。","slug":"TCP的拥塞控制机制","published":1,"updated":"2020-08-09T05:24:13.290Z","photos":[],"link":"","_id":"ckdmsedze000jlguwdwt51ozr","content":"<p>拥塞控制（congestion control)是TCP协议的一项重要功能，TCP的拥塞控制机制是从端到端的角度，推测网络是否发生拥塞，如果推断网络发生拥塞，则立即将数据发送速率降下来，以便缓解网络拥塞。</p>\n<a id=\"more\"></a> \n<p>TCP的拥塞控制算法包括了慢启动（slow start）、拥塞避免（congestion avoidance）、快速重传（fast retransmit）和快速恢复（fast recovery）四部分。</p>\n<p><strong>慢启动（slow start）和拥塞避免（congestion avoidance）控制过程</strong>：<br>  -[1]. TCP连接初始化，将拥塞窗口cwind设置为1个报文段，即cwind=1；<br>  -[2]. 执行慢开始算法，cwind按指数规律增长，直到cwind == ssthresh时，开始执行拥塞避免算法，cwind按线性规律增长；<br>  -[3]. 当网络发生拥塞，把ssthresh值更新为拥塞前ssthresh值的一半，cwind重新设置为1，再按照 [2] 执行。</p>\n<p><img src=\"http://img.blog.csdn.net/20150925124844736\" alt=\"慢启动和拥塞避免\"></p>\n<p><strong>例题：</strong></p>\n<p>设某TCP的拥塞窗口的慢启动门限值初始为8(单位为报文段，且最大报文段长度1KB)，当拥塞窗口上升到12时，网络会发生超时。按照以上给出的条件，第12次传输网拥塞窗口的大小为( )。</p>\n<ul>\n<li>A. 5</li>\n<li>B. 6</li>\n<li>C. 7 </li>\n<li>D. 8</li>\n</ul>\n<p><strong>解析：B</strong></p>\n<p>在慢启动和拥塞避免算法中，拥塞窗口初始值为1，窗口大小开始按指数增长。当拥塞窗口大于慢启动门限后，停止使用慢启动算法，改用拥塞避免算法。此时，慢启动的门限值初始为8，当拥塞窗口增大到8时改用拥塞避免算法，窗口大小按线性增长，毎次增长1个报文段。当增加到12时，出现超时，重新设置门限值为6(12的一半)，拥塞窗口再重新设为1，执行慢启动算法，到门限值为6时执行拥塞避免算法。按照上面的算法，拥塞窗口的变化为1、2、4、8、9、10、11、12、1、2、4、6、7、8、9…，从该序列可以看出，第12次传输时拥塞窗口大小为6。</p>\n<p><strong>注意：</strong>在以上的序列中，6被加粗，原因是很多考生直接从4增加到8，导致误选D选项。原因是拥塞窗口的大小是与门限值有关的，在慢开始算法中不能直接变化为大千门限值，所以4只能最多增加到6，之后再执行拥塞避免算法。</p>\n","site":{"data":{}},"excerpt":"<p>拥塞控制（congestion control)是TCP协议的一项重要功能，TCP的拥塞控制机制是从端到端的角度，推测网络是否发生拥塞，如果推断网络发生拥塞，则立即将数据发送速率降下来，以便缓解网络拥塞。</p>","more":"<p>TCP的拥塞控制算法包括了慢启动（slow start）、拥塞避免（congestion avoidance）、快速重传（fast retransmit）和快速恢复（fast recovery）四部分。</p>\n<p><strong>慢启动（slow start）和拥塞避免（congestion avoidance）控制过程</strong>：<br>  -[1]. TCP连接初始化，将拥塞窗口cwind设置为1个报文段，即cwind=1；<br>  -[2]. 执行慢开始算法，cwind按指数规律增长，直到cwind == ssthresh时，开始执行拥塞避免算法，cwind按线性规律增长；<br>  -[3]. 当网络发生拥塞，把ssthresh值更新为拥塞前ssthresh值的一半，cwind重新设置为1，再按照 [2] 执行。</p>\n<p><img src=\"http://img.blog.csdn.net/20150925124844736\" alt=\"慢启动和拥塞避免\"></p>\n<p><strong>例题：</strong></p>\n<p>设某TCP的拥塞窗口的慢启动门限值初始为8(单位为报文段，且最大报文段长度1KB)，当拥塞窗口上升到12时，网络会发生超时。按照以上给出的条件，第12次传输网拥塞窗口的大小为( )。</p>\n<ul>\n<li>A. 5</li>\n<li>B. 6</li>\n<li>C. 7 </li>\n<li>D. 8</li>\n</ul>\n<p><strong>解析：B</strong></p>\n<p>在慢启动和拥塞避免算法中，拥塞窗口初始值为1，窗口大小开始按指数增长。当拥塞窗口大于慢启动门限后，停止使用慢启动算法，改用拥塞避免算法。此时，慢启动的门限值初始为8，当拥塞窗口增大到8时改用拥塞避免算法，窗口大小按线性增长，毎次增长1个报文段。当增加到12时，出现超时，重新设置门限值为6(12的一半)，拥塞窗口再重新设为1，执行慢启动算法，到门限值为6时执行拥塞避免算法。按照上面的算法，拥塞窗口的变化为1、2、4、8、9、10、11、12、1、2、4、6、7、8、9…，从该序列可以看出，第12次传输时拥塞窗口大小为6。</p>\n<p><strong>注意：</strong>在以上的序列中，6被加粗，原因是很多考生直接从4增加到8，导致误选D选项。原因是拥塞窗口的大小是与门限值有关的，在慢开始算法中不能直接变化为大千门限值，所以4只能最多增加到6，之后再执行拥塞避免算法。</p>"},{"title":"出生","author":"Zhang Peng","date":"2018-07-01T15:09:00.000Z","_content":"\n1996年这一年世界第一只“克隆羊”多利诞生，各种不间断的热点事件，但这些好像都无关紧要。这一年，我出生了。\n\n<!--more--> \n\n\n我出生在地球，为什么我没有出生在其他星球？难道其他星球没有和我一样的存在？我出生在中国，出生在一个商人的家庭。而与我同时出生的人在哪里了？对于出生，我没有选择权，我只知道我是由受精卵发育而来。把提供精子的叫爸爸，提供卵子的叫妈妈。我也有称呼，看来这个世界一出生就帮我安排好名称了。\n\n1996年我出生在中国，计划生育实行的时代。而在此之前，我已有两个姐姐，按照国家的政策，我的出生是无法容许的。而按照我家庭思想，一定要要出生的。就这样，我的出生有了一段故事。中国五千年历史，儒家文化尊崇。重男轻女传宗接代的封建思想不断传承，到了我父辈。家中一直没有男孩，受此影响。我妈怀孕了六胎才是男孩（PS:我对前三胎怀有深深歉意）。我妈刚要偷偷地把我生下来的时候，被人举报。政府派人抓我妈做人流，将我妈锁在妇女儿童医院六楼，我爷爷叫来黑道的人来帮忙，大伯利用妇幼医院熟人关系在医护人员交接班时，帮我妈逃出医院。逃出后，政府人员一路有人追赶。爸妈为了防止被抓，一路上辗转数次车到了黄冈舅爷家。舅爷帮我转移到安全位置，而政府人员去了我家将舅舅抓住了，将姑奶奶的门诊关了。姑奶奶向爷爷求情说：“门诊关了，没办法生存了”。爷爷心软了，发消息给爸爸：还是回来吧。爸爸回复：既然都逃出来了，就一定要生下来。躲了两月后。爸爸为了保证我安全又将我转移到大姑爹家中，在大姑爹家中的2楼躲了10天。一天都没有开灯，防止被人举报。快到临产时，就送到人民医院，用了假名字将我顺利出生。而政府人员得知后，家里上交了罚款3万元，这件事才告一段落。\n\n亲戚的帮忙，母亲怀胎十月，父亲奔波谋策。当“啊啊啊”哭声响起之时，母亲笑了，父亲笑了，大家也笑了。\n\n出生其实是一件挺麻烦的事情。母亲的十月怀胎，边流汗边咬牙生产；父亲焦急等待。\n\n既然我来到这个世界，那就好好活着！\n\n","source":"_posts/出生.md","raw":"title: 出生\nauthor: Zhang Peng\ntags:\n  - 生活\ncategories: []\ndate: 2018-07-01 23:09:00\n---\n\n1996年这一年世界第一只“克隆羊”多利诞生，各种不间断的热点事件，但这些好像都无关紧要。这一年，我出生了。\n\n<!--more--> \n\n\n我出生在地球，为什么我没有出生在其他星球？难道其他星球没有和我一样的存在？我出生在中国，出生在一个商人的家庭。而与我同时出生的人在哪里了？对于出生，我没有选择权，我只知道我是由受精卵发育而来。把提供精子的叫爸爸，提供卵子的叫妈妈。我也有称呼，看来这个世界一出生就帮我安排好名称了。\n\n1996年我出生在中国，计划生育实行的时代。而在此之前，我已有两个姐姐，按照国家的政策，我的出生是无法容许的。而按照我家庭思想，一定要要出生的。就这样，我的出生有了一段故事。中国五千年历史，儒家文化尊崇。重男轻女传宗接代的封建思想不断传承，到了我父辈。家中一直没有男孩，受此影响。我妈怀孕了六胎才是男孩（PS:我对前三胎怀有深深歉意）。我妈刚要偷偷地把我生下来的时候，被人举报。政府派人抓我妈做人流，将我妈锁在妇女儿童医院六楼，我爷爷叫来黑道的人来帮忙，大伯利用妇幼医院熟人关系在医护人员交接班时，帮我妈逃出医院。逃出后，政府人员一路有人追赶。爸妈为了防止被抓，一路上辗转数次车到了黄冈舅爷家。舅爷帮我转移到安全位置，而政府人员去了我家将舅舅抓住了，将姑奶奶的门诊关了。姑奶奶向爷爷求情说：“门诊关了，没办法生存了”。爷爷心软了，发消息给爸爸：还是回来吧。爸爸回复：既然都逃出来了，就一定要生下来。躲了两月后。爸爸为了保证我安全又将我转移到大姑爹家中，在大姑爹家中的2楼躲了10天。一天都没有开灯，防止被人举报。快到临产时，就送到人民医院，用了假名字将我顺利出生。而政府人员得知后，家里上交了罚款3万元，这件事才告一段落。\n\n亲戚的帮忙，母亲怀胎十月，父亲奔波谋策。当“啊啊啊”哭声响起之时，母亲笑了，父亲笑了，大家也笑了。\n\n出生其实是一件挺麻烦的事情。母亲的十月怀胎，边流汗边咬牙生产；父亲焦急等待。\n\n既然我来到这个世界，那就好好活着！\n\n","slug":"出生","published":1,"updated":"2020-08-09T05:24:13.292Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdmsedzf000llguwjtmrz9pa","content":"<p>1996年这一年世界第一只“克隆羊”多利诞生，各种不间断的热点事件，但这些好像都无关紧要。这一年，我出生了。</p>\n<a id=\"more\"></a> \n<p>我出生在地球，为什么我没有出生在其他星球？难道其他星球没有和我一样的存在？我出生在中国，出生在一个商人的家庭。而与我同时出生的人在哪里了？对于出生，我没有选择权，我只知道我是由受精卵发育而来。把提供精子的叫爸爸，提供卵子的叫妈妈。我也有称呼，看来这个世界一出生就帮我安排好名称了。</p>\n<p>1996年我出生在中国，计划生育实行的时代。而在此之前，我已有两个姐姐，按照国家的政策，我的出生是无法容许的。而按照我家庭思想，一定要要出生的。就这样，我的出生有了一段故事。中国五千年历史，儒家文化尊崇。重男轻女传宗接代的封建思想不断传承，到了我父辈。家中一直没有男孩，受此影响。我妈怀孕了六胎才是男孩（PS:我对前三胎怀有深深歉意）。我妈刚要偷偷地把我生下来的时候，被人举报。政府派人抓我妈做人流，将我妈锁在妇女儿童医院六楼，我爷爷叫来黑道的人来帮忙，大伯利用妇幼医院熟人关系在医护人员交接班时，帮我妈逃出医院。逃出后，政府人员一路有人追赶。爸妈为了防止被抓，一路上辗转数次车到了黄冈舅爷家。舅爷帮我转移到安全位置，而政府人员去了我家将舅舅抓住了，将姑奶奶的门诊关了。姑奶奶向爷爷求情说：“门诊关了，没办法生存了”。爷爷心软了，发消息给爸爸：还是回来吧。爸爸回复：既然都逃出来了，就一定要生下来。躲了两月后。爸爸为了保证我安全又将我转移到大姑爹家中，在大姑爹家中的2楼躲了10天。一天都没有开灯，防止被人举报。快到临产时，就送到人民医院，用了假名字将我顺利出生。而政府人员得知后，家里上交了罚款3万元，这件事才告一段落。</p>\n<p>亲戚的帮忙，母亲怀胎十月，父亲奔波谋策。当“啊啊啊”哭声响起之时，母亲笑了，父亲笑了，大家也笑了。</p>\n<p>出生其实是一件挺麻烦的事情。母亲的十月怀胎，边流汗边咬牙生产；父亲焦急等待。</p>\n<p>既然我来到这个世界，那就好好活着！</p>\n","site":{"data":{}},"excerpt":"<p>1996年这一年世界第一只“克隆羊”多利诞生，各种不间断的热点事件，但这些好像都无关紧要。这一年，我出生了。</p>","more":"<p>我出生在地球，为什么我没有出生在其他星球？难道其他星球没有和我一样的存在？我出生在中国，出生在一个商人的家庭。而与我同时出生的人在哪里了？对于出生，我没有选择权，我只知道我是由受精卵发育而来。把提供精子的叫爸爸，提供卵子的叫妈妈。我也有称呼，看来这个世界一出生就帮我安排好名称了。</p>\n<p>1996年我出生在中国，计划生育实行的时代。而在此之前，我已有两个姐姐，按照国家的政策，我的出生是无法容许的。而按照我家庭思想，一定要要出生的。就这样，我的出生有了一段故事。中国五千年历史，儒家文化尊崇。重男轻女传宗接代的封建思想不断传承，到了我父辈。家中一直没有男孩，受此影响。我妈怀孕了六胎才是男孩（PS:我对前三胎怀有深深歉意）。我妈刚要偷偷地把我生下来的时候，被人举报。政府派人抓我妈做人流，将我妈锁在妇女儿童医院六楼，我爷爷叫来黑道的人来帮忙，大伯利用妇幼医院熟人关系在医护人员交接班时，帮我妈逃出医院。逃出后，政府人员一路有人追赶。爸妈为了防止被抓，一路上辗转数次车到了黄冈舅爷家。舅爷帮我转移到安全位置，而政府人员去了我家将舅舅抓住了，将姑奶奶的门诊关了。姑奶奶向爷爷求情说：“门诊关了，没办法生存了”。爷爷心软了，发消息给爸爸：还是回来吧。爸爸回复：既然都逃出来了，就一定要生下来。躲了两月后。爸爸为了保证我安全又将我转移到大姑爹家中，在大姑爹家中的2楼躲了10天。一天都没有开灯，防止被人举报。快到临产时，就送到人民医院，用了假名字将我顺利出生。而政府人员得知后，家里上交了罚款3万元，这件事才告一段落。</p>\n<p>亲戚的帮忙，母亲怀胎十月，父亲奔波谋策。当“啊啊啊”哭声响起之时，母亲笑了，父亲笑了，大家也笑了。</p>\n<p>出生其实是一件挺麻烦的事情。母亲的十月怀胎，边流汗边咬牙生产；父亲焦急等待。</p>\n<p>既然我来到这个世界，那就好好活着！</p>"},{"title":"单体到微服务","date":"2020-01-11T14:42:57.000Z","_content":"\n最近读了《大型网站系统与Java中间件实践》，书14年的，老了点。后面的感觉没啥可看的，就讲讲学到的。\n\n从单体项目转向分布式的项目，所要解决的问题和Spring Cloud组件相对应。\n\n### 1.服务之间网络通信问题\n\n在原来的单体项目中，只需要调不同的方法就能完成业务不同的操作。到了分布式中，根据业务的不同会拆分成不同的服务，A服务依赖于B服务。这时候涉及A服务与B服务的网络通信问题（如下图）。\n\n<img src=\"http://ww1.sinaimg.cn/mw690/aacc02d8gy1gat1dnzjgpj20fv0ba0t0.jpg\" alt=\"微信截图_20200111231521.png\" style=\"zoom:80%;\" />\n\n在Spring Cloud是靠着Feign,Ribbon, Eureka注册中心得以实现。\n\n**Eureka**：各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里。Eureka Serve里面有一个注册表，保存了各服务所在的机器和端口号。\n\n**Ribbon**：首先Ribbon会从 Eureka Client里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口号。Ribbon使用负载均衡算法（默认使用的最经典的**Round Robin轮询算法**）从一个服务的多台机器中选择一台。\n\n**Feign**：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求。\n\n![undefined](http://ww1.sinaimg.cn/large/aacc02d8gy1gatmfoxtgzj20uk0cxmxw.jpg)\n\n### 2. 某个服务挂了怎么办\n\n在单体项目中，要是挂了，整个项目就用不了。在分布式架构中，A服务挂了但是不影响B服务的运行，用户依然可以进行B服务的操作。在SpringCloud中通过**Hystrix**实现。\n\n- **Hystrix**：发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。\n\n当A服务挂了，A服务会被熔断。请求A服务会立即返回。\n\n#### 参考\n\nhttps://juejin.im/post/5d56204a5188252bd409b5cb\n","source":"_posts/单体到微服务.md","raw":"---\ntitle: 单体到微服务\ndate: 2020-01-11 22:42:57\ntags: JAVA\n---\n\n最近读了《大型网站系统与Java中间件实践》，书14年的，老了点。后面的感觉没啥可看的，就讲讲学到的。\n\n从单体项目转向分布式的项目，所要解决的问题和Spring Cloud组件相对应。\n\n### 1.服务之间网络通信问题\n\n在原来的单体项目中，只需要调不同的方法就能完成业务不同的操作。到了分布式中，根据业务的不同会拆分成不同的服务，A服务依赖于B服务。这时候涉及A服务与B服务的网络通信问题（如下图）。\n\n<img src=\"http://ww1.sinaimg.cn/mw690/aacc02d8gy1gat1dnzjgpj20fv0ba0t0.jpg\" alt=\"微信截图_20200111231521.png\" style=\"zoom:80%;\" />\n\n在Spring Cloud是靠着Feign,Ribbon, Eureka注册中心得以实现。\n\n**Eureka**：各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里。Eureka Serve里面有一个注册表，保存了各服务所在的机器和端口号。\n\n**Ribbon**：首先Ribbon会从 Eureka Client里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口号。Ribbon使用负载均衡算法（默认使用的最经典的**Round Robin轮询算法**）从一个服务的多台机器中选择一台。\n\n**Feign**：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求。\n\n![undefined](http://ww1.sinaimg.cn/large/aacc02d8gy1gatmfoxtgzj20uk0cxmxw.jpg)\n\n### 2. 某个服务挂了怎么办\n\n在单体项目中，要是挂了，整个项目就用不了。在分布式架构中，A服务挂了但是不影响B服务的运行，用户依然可以进行B服务的操作。在SpringCloud中通过**Hystrix**实现。\n\n- **Hystrix**：发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。\n\n当A服务挂了，A服务会被熔断。请求A服务会立即返回。\n\n#### 参考\n\nhttps://juejin.im/post/5d56204a5188252bd409b5cb\n","slug":"单体到微服务","published":1,"updated":"2020-08-09T05:24:13.294Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdmsedzi000olguwb2qv4b08","content":"<p>最近读了《大型网站系统与Java中间件实践》，书14年的，老了点。后面的感觉没啥可看的，就讲讲学到的。</p>\n<p>从单体项目转向分布式的项目，所要解决的问题和Spring Cloud组件相对应。</p>\n<h3 id=\"1-服务之间网络通信问题\"><a href=\"#1-服务之间网络通信问题\" class=\"headerlink\" title=\"1.服务之间网络通信问题\"></a>1.服务之间网络通信问题</h3><p>在原来的单体项目中，只需要调不同的方法就能完成业务不同的操作。到了分布式中，根据业务的不同会拆分成不同的服务，A服务依赖于B服务。这时候涉及A服务与B服务的网络通信问题（如下图）。</p>\n<p><img src=\"http://ww1.sinaimg.cn/mw690/aacc02d8gy1gat1dnzjgpj20fv0ba0t0.jpg\" alt=\"微信截图_20200111231521.png\" style=\"zoom:80%;\"></p>\n<p>在Spring Cloud是靠着Feign,Ribbon, Eureka注册中心得以实现。</p>\n<p><strong>Eureka</strong>：各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里。Eureka Serve里面有一个注册表，保存了各服务所在的机器和端口号。</p>\n<p><strong>Ribbon</strong>：首先Ribbon会从 Eureka Client里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口号。Ribbon使用负载均衡算法（默认使用的最经典的<strong>Round Robin轮询算法</strong>）从一个服务的多台机器中选择一台。</p>\n<p><strong>Feign</strong>：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gatmfoxtgzj20uk0cxmxw.jpg\" alt=\"undefined\"></p>\n<h3 id=\"2-某个服务挂了怎么办\"><a href=\"#2-某个服务挂了怎么办\" class=\"headerlink\" title=\"2. 某个服务挂了怎么办\"></a>2. 某个服务挂了怎么办</h3><p>在单体项目中，要是挂了，整个项目就用不了。在分布式架构中，A服务挂了但是不影响B服务的运行，用户依然可以进行B服务的操作。在SpringCloud中通过<strong>Hystrix</strong>实现。</p>\n<ul>\n<li><strong>Hystrix</strong>：发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。</li>\n</ul>\n<p>当A服务挂了，A服务会被熔断。请求A服务会立即返回。</p>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><p><a href=\"https://juejin.im/post/5d56204a5188252bd409b5cb\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5d56204a5188252bd409b5cb</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近读了《大型网站系统与Java中间件实践》，书14年的，老了点。后面的感觉没啥可看的，就讲讲学到的。</p>\n<p>从单体项目转向分布式的项目，所要解决的问题和Spring Cloud组件相对应。</p>\n<h3 id=\"1-服务之间网络通信问题\"><a href=\"#1-服务之间网络通信问题\" class=\"headerlink\" title=\"1.服务之间网络通信问题\"></a>1.服务之间网络通信问题</h3><p>在原来的单体项目中，只需要调不同的方法就能完成业务不同的操作。到了分布式中，根据业务的不同会拆分成不同的服务，A服务依赖于B服务。这时候涉及A服务与B服务的网络通信问题（如下图）。</p>\n<p><img src=\"http://ww1.sinaimg.cn/mw690/aacc02d8gy1gat1dnzjgpj20fv0ba0t0.jpg\" alt=\"微信截图_20200111231521.png\" style=\"zoom:80%;\"></p>\n<p>在Spring Cloud是靠着Feign,Ribbon, Eureka注册中心得以实现。</p>\n<p><strong>Eureka</strong>：各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里。Eureka Serve里面有一个注册表，保存了各服务所在的机器和端口号。</p>\n<p><strong>Ribbon</strong>：首先Ribbon会从 Eureka Client里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口号。Ribbon使用负载均衡算法（默认使用的最经典的<strong>Round Robin轮询算法</strong>）从一个服务的多台机器中选择一台。</p>\n<p><strong>Feign</strong>：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gatmfoxtgzj20uk0cxmxw.jpg\" alt=\"undefined\"></p>\n<h3 id=\"2-某个服务挂了怎么办\"><a href=\"#2-某个服务挂了怎么办\" class=\"headerlink\" title=\"2. 某个服务挂了怎么办\"></a>2. 某个服务挂了怎么办</h3><p>在单体项目中，要是挂了，整个项目就用不了。在分布式架构中，A服务挂了但是不影响B服务的运行，用户依然可以进行B服务的操作。在SpringCloud中通过<strong>Hystrix</strong>实现。</p>\n<ul>\n<li><strong>Hystrix</strong>：发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。</li>\n</ul>\n<p>当A服务挂了，A服务会被熔断。请求A服务会立即返回。</p>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><p><a href=\"https://juejin.im/post/5d56204a5188252bd409b5cb\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5d56204a5188252bd409b5cb</a></p>\n"},{"layout":"post","title":"快排里的Partition应用-找第K大的数字","date":"2018-01-06T07:21:00.000Z","comments":1,"reward":true,"_content":"### Partition 算法\n\n参考自：\n\n[白话经典算法系列之六 快速排序 快速搞定](http://blog.csdn.net/morewindows/article/details/6684558)\n\n### 挖数填坑：\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1fmnsi4j20tv0kj45z.jpg)\n\n<!--more--> \n\n```c++\nint partition(vector<int>& nums, int low, int high)\n{\n    int x = nums[low];\n    int i = low;\n    int j = high-1;\n    while(i<j)\n    {\n      while(i<j&&nums[j]<=x)\n        j--;\n      if(i<j)\n        nums[i]=nums[j];\n      while(i<j&&nums[i]>=x)\n        i++;\n      if(i<j)\n        nums[j]=nums[i];\n    }\n    nums[i]=x;\n    return i;\n}\n```\n\n### FindKthNumber\n\n```c\nint findKthLargest(vector<int>& nums, int k) {\n    int begin = 0, end = nums.size();\n    int target_num = 0;\n    while (begin <= end){\n        int pos = partition(nums, begin, end);\n        if(pos == k-1){\n            target_num = nums[pos];\n            break;\n        }\n        else if(pos > k-1){\n            end = pos;\n        }\n        else{\n            begin = pos + 1;\n        }\n    }\n    return target_num;\n}\n```\n\n### 全部代码\n\n```c++\n#include<cstdio>\n#include<vector>\nusing namespace std;\n\nint partition(vector<int>& nums, int low, int high)\n{\n    int x = nums[low];\n    int i = low;\n    int j = high-1;\n    while(i<j)\n    {\n      while(i<j&&nums[j]<=x)\n        j--;\n      if(i<j)\n        nums[i]=nums[j];\n      while(i<j&&nums[i]>=x)\n        i++;\n      if(i<j)\n        nums[j]=nums[i];\n    }\n    nums[i]=x;\n    return i;\n}\n    \nint findKthLargest(vector<int>& nums, int k) {\n    int begin = 0, end = nums.size();\n    int target_num = 0;\n    while (begin <= end){\n        int pos = partition(nums, begin, end);\n        if(pos == k-1){\n            target_num = nums[pos];\n            break;\n        }\n        else if(pos > k-1){\n            end = pos;\n        }\n        else{\n            begin = pos + 1;\n        }\n    }\n    return target_num;\n}\n\n\nint main()\n{\n  vector<int> nums={2, 1};\n  printf(\"%d\", findKthLargest(nums, 2));\n  getchar();\n}\n```\n\n[例题：Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/description/)","source":"_posts/快排里的Partition应用-找第K大的数字 .md","raw":"---\nlayout: post\ntitle: \"快排里的Partition应用-找第K大的数字\"\ndate: 2018-01-06 15:21\ncomments: true\nreward: true\ntags: \n\t- leetcode\n---\n### Partition 算法\n\n参考自：\n\n[白话经典算法系列之六 快速排序 快速搞定](http://blog.csdn.net/morewindows/article/details/6684558)\n\n### 挖数填坑：\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1fmnsi4j20tv0kj45z.jpg)\n\n<!--more--> \n\n```c++\nint partition(vector<int>& nums, int low, int high)\n{\n    int x = nums[low];\n    int i = low;\n    int j = high-1;\n    while(i<j)\n    {\n      while(i<j&&nums[j]<=x)\n        j--;\n      if(i<j)\n        nums[i]=nums[j];\n      while(i<j&&nums[i]>=x)\n        i++;\n      if(i<j)\n        nums[j]=nums[i];\n    }\n    nums[i]=x;\n    return i;\n}\n```\n\n### FindKthNumber\n\n```c\nint findKthLargest(vector<int>& nums, int k) {\n    int begin = 0, end = nums.size();\n    int target_num = 0;\n    while (begin <= end){\n        int pos = partition(nums, begin, end);\n        if(pos == k-1){\n            target_num = nums[pos];\n            break;\n        }\n        else if(pos > k-1){\n            end = pos;\n        }\n        else{\n            begin = pos + 1;\n        }\n    }\n    return target_num;\n}\n```\n\n### 全部代码\n\n```c++\n#include<cstdio>\n#include<vector>\nusing namespace std;\n\nint partition(vector<int>& nums, int low, int high)\n{\n    int x = nums[low];\n    int i = low;\n    int j = high-1;\n    while(i<j)\n    {\n      while(i<j&&nums[j]<=x)\n        j--;\n      if(i<j)\n        nums[i]=nums[j];\n      while(i<j&&nums[i]>=x)\n        i++;\n      if(i<j)\n        nums[j]=nums[i];\n    }\n    nums[i]=x;\n    return i;\n}\n    \nint findKthLargest(vector<int>& nums, int k) {\n    int begin = 0, end = nums.size();\n    int target_num = 0;\n    while (begin <= end){\n        int pos = partition(nums, begin, end);\n        if(pos == k-1){\n            target_num = nums[pos];\n            break;\n        }\n        else if(pos > k-1){\n            end = pos;\n        }\n        else{\n            begin = pos + 1;\n        }\n    }\n    return target_num;\n}\n\n\nint main()\n{\n  vector<int> nums={2, 1};\n  printf(\"%d\", findKthLargest(nums, 2));\n  getchar();\n}\n```\n\n[例题：Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/description/)","slug":"快排里的Partition应用-找第K大的数字 ","published":1,"updated":"2020-08-09T05:24:13.295Z","photos":[],"link":"","_id":"ckdmsedzk000qlguwef3mxj0i","content":"<h3 id=\"Partition-算法\"><a href=\"#Partition-算法\" class=\"headerlink\" title=\"Partition 算法\"></a>Partition 算法</h3><p>参考自：</p>\n<p><a href=\"http://blog.csdn.net/morewindows/article/details/6684558\" target=\"_blank\" rel=\"noopener\">白话经典算法系列之六 快速排序 快速搞定</a></p>\n<h3 id=\"挖数填坑：\"><a href=\"#挖数填坑：\" class=\"headerlink\" title=\"挖数填坑：\"></a>挖数填坑：</h3><p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1fmnsi4j20tv0kj45z.jpg\" alt></p>\n<a id=\"more\"></a> \n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = nums[low];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = low;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = high<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&lt;j)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(i&lt;j&amp;&amp;nums[j]&lt;=x)</span><br><span class=\"line\">        j--;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(i&lt;j)</span><br><span class=\"line\">        nums[i]=nums[j];</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(i&lt;j&amp;&amp;nums[i]&gt;=x)</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(i&lt;j)</span><br><span class=\"line\">        nums[j]=nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nums[i]=x;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"FindKthNumber\"><a href=\"#FindKthNumber\" class=\"headerlink\" title=\"FindKthNumber\"></a>FindKthNumber</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> begin = <span class=\"number\">0</span>, end = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> target_num = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (begin &lt;= end)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pos = partition(nums, begin, end);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pos == k<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            target_num = nums[pos];</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(pos &gt; k<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            end = pos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            begin = pos + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target_num;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"全部代码\"><a href=\"#全部代码\" class=\"headerlink\" title=\"全部代码\"></a>全部代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = nums[low];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = low;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = high<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&lt;j)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(i&lt;j&amp;&amp;nums[j]&lt;=x)</span><br><span class=\"line\">        j--;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(i&lt;j)</span><br><span class=\"line\">        nums[i]=nums[j];</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(i&lt;j&amp;&amp;nums[i]&gt;=x)</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(i&lt;j)</span><br><span class=\"line\">        nums[j]=nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nums[i]=x;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> begin = <span class=\"number\">0</span>, end = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> target_num = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (begin &lt;= end)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pos = partition(nums, begin, end);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pos == k<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            target_num = nums[pos];</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(pos &gt; k<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            end = pos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            begin = pos + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target_num;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; nums=&#123;<span class=\"number\">2</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, findKthLargest(nums, <span class=\"number\">2</span>));</span><br><span class=\"line\">  getchar();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://leetcode.com/problems/kth-largest-element-in-an-array/description/\" target=\"_blank\" rel=\"noopener\">例题：Kth Largest Element in an Array</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"Partition-算法\"><a href=\"#Partition-算法\" class=\"headerlink\" title=\"Partition 算法\"></a>Partition 算法</h3><p>参考自：</p>\n<p><a href=\"http://blog.csdn.net/morewindows/article/details/6684558\" target=\"_blank\" rel=\"noopener\">白话经典算法系列之六 快速排序 快速搞定</a></p>\n<h3 id=\"挖数填坑：\"><a href=\"#挖数填坑：\" class=\"headerlink\" title=\"挖数填坑：\"></a>挖数填坑：</h3><p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1fmnsi4j20tv0kj45z.jpg\" alt></p>","more":"<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = nums[low];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = low;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = high<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&lt;j)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(i&lt;j&amp;&amp;nums[j]&lt;=x)</span><br><span class=\"line\">        j--;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(i&lt;j)</span><br><span class=\"line\">        nums[i]=nums[j];</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(i&lt;j&amp;&amp;nums[i]&gt;=x)</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(i&lt;j)</span><br><span class=\"line\">        nums[j]=nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nums[i]=x;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"FindKthNumber\"><a href=\"#FindKthNumber\" class=\"headerlink\" title=\"FindKthNumber\"></a>FindKthNumber</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> begin = <span class=\"number\">0</span>, end = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> target_num = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (begin &lt;= end)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pos = partition(nums, begin, end);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pos == k<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            target_num = nums[pos];</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(pos &gt; k<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            end = pos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            begin = pos + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target_num;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"全部代码\"><a href=\"#全部代码\" class=\"headerlink\" title=\"全部代码\"></a>全部代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = nums[low];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = low;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = high<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&lt;j)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(i&lt;j&amp;&amp;nums[j]&lt;=x)</span><br><span class=\"line\">        j--;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(i&lt;j)</span><br><span class=\"line\">        nums[i]=nums[j];</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(i&lt;j&amp;&amp;nums[i]&gt;=x)</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(i&lt;j)</span><br><span class=\"line\">        nums[j]=nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nums[i]=x;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> begin = <span class=\"number\">0</span>, end = nums.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> target_num = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (begin &lt;= end)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pos = partition(nums, begin, end);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pos == k<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            target_num = nums[pos];</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(pos &gt; k<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            end = pos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            begin = pos + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target_num;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; nums=&#123;<span class=\"number\">2</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, findKthLargest(nums, <span class=\"number\">2</span>));</span><br><span class=\"line\">  getchar();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://leetcode.com/problems/kth-largest-element-in-an-array/description/\" target=\"_blank\" rel=\"noopener\">例题：Kth Largest Element in an Array</a></p>"},{"layout":"post","title":"进程与线程","date":"2017-10-15T03:15:00.000Z","comments":1,"reward":true,"_content":"\n### 1.线程与进程的区别\n\n![image](https://ws1.sinaimg.cn/large/aacc02d8ly1fxvocw1d71j212p0e17i5.jpg)\n\n![image](https://ws2.sinaimg.cn/large/aacc02d8ly1fxvnlguox1j211s07w7a9.jpg)\n\n<!--more--> \n\n### 2.线程\n\n线程是程序执行流的最小单位。一个标准的线程由线程ID，当当前指令(PC)，寄存器集合和堆栈(stack)组成。另外，线程是进程中的一个实体，是系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，**但它可与同属一个进程的其他线程共享进程所拥有的资源**。\n\n线程共享的进程环境包括：**进程代码段、进程的公有数据（如全局变量，利用这些共享的数据，线程很容易的实现相互之间的通信）、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。**\n\n\n\n### 3.进程的通信方式有哪些？\n\n-  管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。\n\n-  信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。\n\n-  消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。\n\n-  信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。\n\n-  共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。\n\n-  套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。\n\n\n\n\n\n\n\n","source":"_posts/操作系统.md","raw":"---\nlayout: post\ntitle: \"进程与线程\"\ndate: 2017-10-15 11:15\ncomments: true\nreward: true\ntags: \n\t- 校招\n---\n\n### 1.线程与进程的区别\n\n![image](https://ws1.sinaimg.cn/large/aacc02d8ly1fxvocw1d71j212p0e17i5.jpg)\n\n![image](https://ws2.sinaimg.cn/large/aacc02d8ly1fxvnlguox1j211s07w7a9.jpg)\n\n<!--more--> \n\n### 2.线程\n\n线程是程序执行流的最小单位。一个标准的线程由线程ID，当当前指令(PC)，寄存器集合和堆栈(stack)组成。另外，线程是进程中的一个实体，是系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，**但它可与同属一个进程的其他线程共享进程所拥有的资源**。\n\n线程共享的进程环境包括：**进程代码段、进程的公有数据（如全局变量，利用这些共享的数据，线程很容易的实现相互之间的通信）、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。**\n\n\n\n### 3.进程的通信方式有哪些？\n\n-  管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。\n\n-  信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。\n\n-  消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。\n\n-  信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。\n\n-  共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。\n\n-  套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。\n\n\n\n\n\n\n\n","slug":"操作系统","published":1,"updated":"2020-08-09T05:24:13.295Z","photos":[],"link":"","_id":"ckdmsedzn000slguw3kulllgd","content":"<h3 id=\"1-线程与进程的区别\"><a href=\"#1-线程与进程的区别\" class=\"headerlink\" title=\"1.线程与进程的区别\"></a>1.线程与进程的区别</h3><p><img src=\"https://ws1.sinaimg.cn/large/aacc02d8ly1fxvocw1d71j212p0e17i5.jpg\" alt=\"image\"></p>\n<p><img src=\"https://ws2.sinaimg.cn/large/aacc02d8ly1fxvnlguox1j211s07w7a9.jpg\" alt=\"image\"></p>\n<a id=\"more\"></a> \n<h3 id=\"2-线程\"><a href=\"#2-线程\" class=\"headerlink\" title=\"2.线程\"></a>2.线程</h3><p>线程是程序执行流的最小单位。一个标准的线程由线程ID，当当前指令(PC)，寄存器集合和堆栈(stack)组成。另外，线程是进程中的一个实体，是系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，<strong>但它可与同属一个进程的其他线程共享进程所拥有的资源</strong>。</p>\n<p>线程共享的进程环境包括：<strong>进程代码段、进程的公有数据（如全局变量，利用这些共享的数据，线程很容易的实现相互之间的通信）、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。</strong></p>\n<h3 id=\"3-进程的通信方式有哪些？\"><a href=\"#3-进程的通信方式有哪些？\" class=\"headerlink\" title=\"3.进程的通信方式有哪些？\"></a>3.进程的通信方式有哪些？</h3><ul>\n<li><p>管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p>\n</li>\n<li><p>信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>\n</li>\n<li><p>消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>\n</li>\n<li><p>信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>\n</li>\n<li><p>共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p>\n</li>\n<li><p>套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-线程与进程的区别\"><a href=\"#1-线程与进程的区别\" class=\"headerlink\" title=\"1.线程与进程的区别\"></a>1.线程与进程的区别</h3><p><img src=\"https://ws1.sinaimg.cn/large/aacc02d8ly1fxvocw1d71j212p0e17i5.jpg\" alt=\"image\"></p>\n<p><img src=\"https://ws2.sinaimg.cn/large/aacc02d8ly1fxvnlguox1j211s07w7a9.jpg\" alt=\"image\"></p>","more":"<h3 id=\"2-线程\"><a href=\"#2-线程\" class=\"headerlink\" title=\"2.线程\"></a>2.线程</h3><p>线程是程序执行流的最小单位。一个标准的线程由线程ID，当当前指令(PC)，寄存器集合和堆栈(stack)组成。另外，线程是进程中的一个实体，是系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，<strong>但它可与同属一个进程的其他线程共享进程所拥有的资源</strong>。</p>\n<p>线程共享的进程环境包括：<strong>进程代码段、进程的公有数据（如全局变量，利用这些共享的数据，线程很容易的实现相互之间的通信）、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。</strong></p>\n<h3 id=\"3-进程的通信方式有哪些？\"><a href=\"#3-进程的通信方式有哪些？\" class=\"headerlink\" title=\"3.进程的通信方式有哪些？\"></a>3.进程的通信方式有哪些？</h3><ul>\n<li><p>管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p>\n</li>\n<li><p>信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>\n</li>\n<li><p>消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>\n</li>\n<li><p>信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>\n</li>\n<li><p>共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p>\n</li>\n<li><p>套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p>\n</li>\n</ul>"},{"layout":"post","title":"校招笔试题目总结(二)","date":"2017-09-07T13:58:00.000Z","comments":1,"reward":true,"_content":"\n### 1.中缀表达式求前缀与后缀表达式\n\n#### 摘自于(http://blog.csdn.net/dreamzuora/article/details/53384174)\n\n给出一个中缀表达式如下：a+b*c-(d+e) \n第一步：按照运算符的优先级对所有的运算单位加括号，\n​         式子变成了：((a+(b*c))-(d+e)) \n第二步：转换前缀与后缀表达式 \n​         **前缀**：把运算符号移动到对应的括号前面 \n​                     则变成了：-( +(a *(bc)) +(de)) \n​                     把括号去掉：-+a*bc+de   前缀式子出现 \n​         **后缀**：把运算符号移动到对应的括号后面 \n​                    则变成了：((a(bc)* )+ (de)+ )- \n​                     把括号去掉：abc*+de+-   后缀式子出现\n\n<!--more--> \n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1gkgmuej20qi07pwo2.jpg)\n\n## 2.共用体union\n\n- 共用体占用内存为各成员中最大者内存，各成员共享这一段空间。\n- 对于共用体的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了。\n\n### 3.AVL和红黑树\n\n#### **AVL平衡二叉搜索树**\n\n定义：平衡二叉树或为空树,或为如下性质的二叉排序树:\n  （1）左右子树深度之差的绝对值不超过1;\n  （2）左右子树仍然为平衡二叉树.\n平衡因子BF=左子树深度－右子树深度.\n平衡二叉树每个结点的平衡因子只能是1，0，-1。若其绝对值超过1，则该二叉排序树就是不平衡的。\n如图所示为平衡树和非平衡树示意图：\n\n![img](http://img.blog.csdn.net/20140916121239199?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU3VwX0hlYXZlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n \n\n#### **RBT 红黑树**\n\n**AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；**\n**红黑是弱平衡的，用非严格的平衡来换取增删节点时候旋转次数的降低；**\n**所以简单说，搜索的次数远远大于插入和删除，那么选择AVL树，如果搜索，插入删除次数几乎差不多，应该选择RB树。**\n\n红黑树上每个结点内含五个域，color，key，left，right，p。如果相应的指针域没有，则设为NIL。\n一般的，红黑树，满足以下性质，即只有满足以下全部性质的树，我们才称之为红黑树：\n1）每个结点要么是红的，要么是黑的。\n2）根结点是黑的。\n3）每个叶结点，即空结点（NIL）是黑的。\n4）如果一个结点是红的，那么它的俩个儿子都是黑的。\n5）对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。\n下图所示，即是一颗红黑树：\n\n![img](http://hi.csdn.net/attachment/201012/29/8394323_1293613306CGzE.jpg)\n\n\n\n### 4.小端模式与大端模式\n\n![image](https://ws1.sinaimg.cn/large/aacc02d8ly1fxvoup244rj21180gj0v2.jpg)","source":"_posts/校招笔试题目总结(二).md","raw":"---\nlayout: post\ntitle: \"校招笔试题目总结(二)\"\ndate: 2017-9-7 21:58\ncomments: true\nreward: true\ntags: \n\t- 校招\n---\n\n### 1.中缀表达式求前缀与后缀表达式\n\n#### 摘自于(http://blog.csdn.net/dreamzuora/article/details/53384174)\n\n给出一个中缀表达式如下：a+b*c-(d+e) \n第一步：按照运算符的优先级对所有的运算单位加括号，\n​         式子变成了：((a+(b*c))-(d+e)) \n第二步：转换前缀与后缀表达式 \n​         **前缀**：把运算符号移动到对应的括号前面 \n​                     则变成了：-( +(a *(bc)) +(de)) \n​                     把括号去掉：-+a*bc+de   前缀式子出现 \n​         **后缀**：把运算符号移动到对应的括号后面 \n​                    则变成了：((a(bc)* )+ (de)+ )- \n​                     把括号去掉：abc*+de+-   后缀式子出现\n\n<!--more--> \n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1gkgmuej20qi07pwo2.jpg)\n\n## 2.共用体union\n\n- 共用体占用内存为各成员中最大者内存，各成员共享这一段空间。\n- 对于共用体的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了。\n\n### 3.AVL和红黑树\n\n#### **AVL平衡二叉搜索树**\n\n定义：平衡二叉树或为空树,或为如下性质的二叉排序树:\n  （1）左右子树深度之差的绝对值不超过1;\n  （2）左右子树仍然为平衡二叉树.\n平衡因子BF=左子树深度－右子树深度.\n平衡二叉树每个结点的平衡因子只能是1，0，-1。若其绝对值超过1，则该二叉排序树就是不平衡的。\n如图所示为平衡树和非平衡树示意图：\n\n![img](http://img.blog.csdn.net/20140916121239199?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU3VwX0hlYXZlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n \n\n#### **RBT 红黑树**\n\n**AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；**\n**红黑是弱平衡的，用非严格的平衡来换取增删节点时候旋转次数的降低；**\n**所以简单说，搜索的次数远远大于插入和删除，那么选择AVL树，如果搜索，插入删除次数几乎差不多，应该选择RB树。**\n\n红黑树上每个结点内含五个域，color，key，left，right，p。如果相应的指针域没有，则设为NIL。\n一般的，红黑树，满足以下性质，即只有满足以下全部性质的树，我们才称之为红黑树：\n1）每个结点要么是红的，要么是黑的。\n2）根结点是黑的。\n3）每个叶结点，即空结点（NIL）是黑的。\n4）如果一个结点是红的，那么它的俩个儿子都是黑的。\n5）对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。\n下图所示，即是一颗红黑树：\n\n![img](http://hi.csdn.net/attachment/201012/29/8394323_1293613306CGzE.jpg)\n\n\n\n### 4.小端模式与大端模式\n\n![image](https://ws1.sinaimg.cn/large/aacc02d8ly1fxvoup244rj21180gj0v2.jpg)","slug":"校招笔试题目总结(二)","published":1,"updated":"2020-08-09T05:24:13.296Z","photos":[],"link":"","_id":"ckdmsedzp000ulguwu7d224w1","content":"<h3 id=\"1-中缀表达式求前缀与后缀表达式\"><a href=\"#1-中缀表达式求前缀与后缀表达式\" class=\"headerlink\" title=\"1.中缀表达式求前缀与后缀表达式\"></a>1.中缀表达式求前缀与后缀表达式</h3><h4 id=\"摘自于-http-blog-csdn-net-dreamzuora-article-details-53384174\"><a href=\"#摘自于-http-blog-csdn-net-dreamzuora-article-details-53384174\" class=\"headerlink\" title=\"摘自于(http://blog.csdn.net/dreamzuora/article/details/53384174)\"></a>摘自于(<a href=\"http://blog.csdn.net/dreamzuora/article/details/53384174\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/dreamzuora/article/details/53384174</a>)</h4><p>给出一个中缀表达式如下：a+b<em>c-(d+e)<br>第一步：按照运算符的优先级对所有的运算单位加括号，<br>​         式子变成了：((a+(b</em>c))-(d+e))<br>第二步：转换前缀与后缀表达式<br>​         <strong>前缀</strong>：把运算符号移动到对应的括号前面<br>​                     则变成了：-( +(a <em>(bc)) +(de))<br>​                     把括号去掉：-+a</em>bc+de   前缀式子出现<br>​         <strong>后缀</strong>：把运算符号移动到对应的括号后面<br>​                    则变成了：((a(bc)<em> )+ (de)+ )-<br>​                     把括号去掉：abc</em>+de+-   后缀式子出现</p>\n<a id=\"more\"></a> \n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1gkgmuej20qi07pwo2.jpg\" alt></p>\n<h2 id=\"2-共用体union\"><a href=\"#2-共用体union\" class=\"headerlink\" title=\"2.共用体union\"></a>2.共用体union</h2><ul>\n<li>共用体占用内存为各成员中最大者内存，各成员共享这一段空间。</li>\n<li>对于共用体的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了。</li>\n</ul>\n<h3 id=\"3-AVL和红黑树\"><a href=\"#3-AVL和红黑树\" class=\"headerlink\" title=\"3.AVL和红黑树\"></a>3.AVL和红黑树</h3><h4 id=\"AVL平衡二叉搜索树\"><a href=\"#AVL平衡二叉搜索树\" class=\"headerlink\" title=\"AVL平衡二叉搜索树\"></a><strong>AVL平衡二叉搜索树</strong></h4><p>定义：平衡二叉树或为空树,或为如下性质的二叉排序树:<br>  （1）左右子树深度之差的绝对值不超过1;<br>  （2）左右子树仍然为平衡二叉树.<br>平衡因子BF=左子树深度－右子树深度.<br>平衡二叉树每个结点的平衡因子只能是1，0，-1。若其绝对值超过1，则该二叉排序树就是不平衡的。<br>如图所示为平衡树和非平衡树示意图：</p>\n<p><img src=\"http://img.blog.csdn.net/20140916121239199?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU3VwX0hlYXZlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"img\"></p>\n<h4 id=\"RBT-红黑树\"><a href=\"#RBT-红黑树\" class=\"headerlink\" title=\"RBT 红黑树\"></a><strong>RBT 红黑树</strong></h4><p><strong>AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；</strong><br><strong>红黑是弱平衡的，用非严格的平衡来换取增删节点时候旋转次数的降低；</strong><br><strong>所以简单说，搜索的次数远远大于插入和删除，那么选择AVL树，如果搜索，插入删除次数几乎差不多，应该选择RB树。</strong></p>\n<p>红黑树上每个结点内含五个域，color，key，left，right，p。如果相应的指针域没有，则设为NIL。<br>一般的，红黑树，满足以下性质，即只有满足以下全部性质的树，我们才称之为红黑树：<br>1）每个结点要么是红的，要么是黑的。<br>2）根结点是黑的。<br>3）每个叶结点，即空结点（NIL）是黑的。<br>4）如果一个结点是红的，那么它的俩个儿子都是黑的。<br>5）对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。<br>下图所示，即是一颗红黑树：</p>\n<p><img src=\"http://hi.csdn.net/attachment/201012/29/8394323_1293613306CGzE.jpg\" alt=\"img\"></p>\n<h3 id=\"4-小端模式与大端模式\"><a href=\"#4-小端模式与大端模式\" class=\"headerlink\" title=\"4.小端模式与大端模式\"></a>4.小端模式与大端模式</h3><p><img src=\"https://ws1.sinaimg.cn/large/aacc02d8ly1fxvoup244rj21180gj0v2.jpg\" alt=\"image\"></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-中缀表达式求前缀与后缀表达式\"><a href=\"#1-中缀表达式求前缀与后缀表达式\" class=\"headerlink\" title=\"1.中缀表达式求前缀与后缀表达式\"></a>1.中缀表达式求前缀与后缀表达式</h3><h4 id=\"摘自于-http-blog-csdn-net-dreamzuora-article-details-53384174\"><a href=\"#摘自于-http-blog-csdn-net-dreamzuora-article-details-53384174\" class=\"headerlink\" title=\"摘自于(http://blog.csdn.net/dreamzuora/article/details/53384174)\"></a>摘自于(<a href=\"http://blog.csdn.net/dreamzuora/article/details/53384174\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/dreamzuora/article/details/53384174</a>)</h4><p>给出一个中缀表达式如下：a+b<em>c-(d+e)<br>第一步：按照运算符的优先级对所有的运算单位加括号，<br>​         式子变成了：((a+(b</em>c))-(d+e))<br>第二步：转换前缀与后缀表达式<br>​         <strong>前缀</strong>：把运算符号移动到对应的括号前面<br>​                     则变成了：-( +(a <em>(bc)) +(de))<br>​                     把括号去掉：-+a</em>bc+de   前缀式子出现<br>​         <strong>后缀</strong>：把运算符号移动到对应的括号后面<br>​                    则变成了：((a(bc)<em> )+ (de)+ )-<br>​                     把括号去掉：abc</em>+de+-   后缀式子出现</p>","more":"<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1gkgmuej20qi07pwo2.jpg\" alt></p>\n<h2 id=\"2-共用体union\"><a href=\"#2-共用体union\" class=\"headerlink\" title=\"2.共用体union\"></a>2.共用体union</h2><ul>\n<li>共用体占用内存为各成员中最大者内存，各成员共享这一段空间。</li>\n<li>对于共用体的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了。</li>\n</ul>\n<h3 id=\"3-AVL和红黑树\"><a href=\"#3-AVL和红黑树\" class=\"headerlink\" title=\"3.AVL和红黑树\"></a>3.AVL和红黑树</h3><h4 id=\"AVL平衡二叉搜索树\"><a href=\"#AVL平衡二叉搜索树\" class=\"headerlink\" title=\"AVL平衡二叉搜索树\"></a><strong>AVL平衡二叉搜索树</strong></h4><p>定义：平衡二叉树或为空树,或为如下性质的二叉排序树:<br>  （1）左右子树深度之差的绝对值不超过1;<br>  （2）左右子树仍然为平衡二叉树.<br>平衡因子BF=左子树深度－右子树深度.<br>平衡二叉树每个结点的平衡因子只能是1，0，-1。若其绝对值超过1，则该二叉排序树就是不平衡的。<br>如图所示为平衡树和非平衡树示意图：</p>\n<p><img src=\"http://img.blog.csdn.net/20140916121239199?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU3VwX0hlYXZlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"img\"></p>\n<h4 id=\"RBT-红黑树\"><a href=\"#RBT-红黑树\" class=\"headerlink\" title=\"RBT 红黑树\"></a><strong>RBT 红黑树</strong></h4><p><strong>AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；</strong><br><strong>红黑是弱平衡的，用非严格的平衡来换取增删节点时候旋转次数的降低；</strong><br><strong>所以简单说，搜索的次数远远大于插入和删除，那么选择AVL树，如果搜索，插入删除次数几乎差不多，应该选择RB树。</strong></p>\n<p>红黑树上每个结点内含五个域，color，key，left，right，p。如果相应的指针域没有，则设为NIL。<br>一般的，红黑树，满足以下性质，即只有满足以下全部性质的树，我们才称之为红黑树：<br>1）每个结点要么是红的，要么是黑的。<br>2）根结点是黑的。<br>3）每个叶结点，即空结点（NIL）是黑的。<br>4）如果一个结点是红的，那么它的俩个儿子都是黑的。<br>5）对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。<br>下图所示，即是一颗红黑树：</p>\n<p><img src=\"http://hi.csdn.net/attachment/201012/29/8394323_1293613306CGzE.jpg\" alt=\"img\"></p>\n<h3 id=\"4-小端模式与大端模式\"><a href=\"#4-小端模式与大端模式\" class=\"headerlink\" title=\"4.小端模式与大端模式\"></a>4.小端模式与大端模式</h3><p><img src=\"https://ws1.sinaimg.cn/large/aacc02d8ly1fxvoup244rj21180gj0v2.jpg\" alt=\"image\"></p>"},{"layout":"post","title":"校招笔试题目总结(一)","date":"2017-09-04T11:58:00.000Z","comments":1,"reward":true,"_content":"\n8月26号辞去实习，回学校准备校招，刷了一些题目。在此做个自己认为常考题的总结。\n\n### 1.在32位系统下char* p[10]; char(*p1)[10]，sizeof(p)和sizeof (p1)分别值为？\n\n![image](https://wx4.sinaimg.cn/large/aacc02d8ly1fxvowcbqaqj20ie0b6dgo.jpg)\n\n<!--more--> \n\n### 2.C++类的内存大小计算\n\n![image](https://wx2.sinaimg.cn/large/aacc02d8ly1fxvowk1t20j20tx0gnjva.jpg)\n\n![image](https://ws3.sinaimg.cn/large/aacc02d8ly1fxvowq8xj4j20tg076myx.jpg)\n\n\n\n### 3.排序算法性能的比较及应用\n\n**时间复杂度**：简单选择排序、直接插入排序和冒泡排序的平均情况下的时间复杂度都为O(n^2),实现过程较简单，但直接插入排序和冒泡排序在最好的情况下时间复杂度可以达到O(n)，而简单选择排序则与序列的初始状态无关。希尔排序作为插入排序的拓展，对较大规模的排序都可以达到很高的效率，但是目前未得出其精确的渐近时间。堆排序是利用了一种称为堆，可以在线性时间内完成建堆，并且在O(nlog2n)内完成排序过程。快速排序是基于分治的思想，最坏情况下快速排序时间会达到O(n^2)，但快速排序平均性能可以达到O(nlog2n)，实际应用中常常优于其他排序算法。归并排序同样是基于分治的思想，最坏和平均时间复杂度均为O(nlog2n)。\n\n**空间复杂度**：简单选择排序、插入排序、冒泡排序、希尔排序和堆排序仅需借助常数个辅助空间。快速排序在空间上只使用一个小的辅助栈，用于实现递归，平均情况大小为O(log2n)，最坏的情况下可能会增长到O(n)。二路归并排序需要借助较多的辅助空间用于元素复制，大小为O(n)。\n\n**稳定性**：插入排序、冒泡排序、归并排序和基数排序是稳定的排序方法，而简单选择排序、快速排序、希尔排序和堆排序都是不稳定的排序方法。对排序方法的稳定性，应从本身的原理上去理解，而不应拘泥于死记硬背。\n\n**应用**：\n\n1. 若n较小时(n<=50)，则可以采用直接插入排序或简单选择排序。\n2. 若文件的初始状态已按关键字基本有序，则选用直接插入或冒泡排序。\n3. 若n较大，则应采用时同复杂度为O(nlog2n)的排序方法快速排序、堆排序、归并排序。快速排序被认为是目前基于比较的内部排序法中最好的方法。若要求排序稳定且时间复杂度为O(nlog2n),则可选用归并排序。\n4. 若n很大，记录的关键字位数较少且可以分解时，采用基数排序较好。\n5. 当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结\n\n### 4.二叉树前序、中序、后序遍历相互求法\n\n例：\n\n前序遍历:         GDAFEMHZ\n\n中序遍历:         ADEFGHMZ\n\n**画树求法：**第一步，根据前序遍历的特点，我们知道根结点为G\n\n第二步，观察中序遍历ADEFGHMZ。其中root节点G左侧的ADEF必然是root的左子树，G右侧的HMZ必然是root的右子树。\n\n 第三步，观察左子树ADEF，左子树的中的根节点必然是大树的root的leftchild。在前序遍历中，大树的root的leftchild位于root之后，所以左子树的根节点为D。\n\n第四步，同样的道理，root的右子树节点HMZ中的根节点也可以通过前序遍历求得。在前序遍历中，一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。\n\n第五步，观察发现，上面的过程是递归的。先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了。该步递归的过程可以简洁表达如下：\n\n1 确定根,确定左子树，确定右子树。\n\n2 在左子树中递归。\n\n3 在右子树中递归。\n\n4 打印当前根。\n\n那么，我们可以画出这个二叉树的形状：\n\n![img](http://www.cr173.com/up/2013-1/2013010715404717978.jpg)\n\n那么，根据后序的遍历规则，我们可以知道，后序遍历顺序为：AEFDHZMG.","source":"_posts/校招笔试题目总结（一）.md","raw":"---\nlayout: post\ntitle: \"校招笔试题目总结(一)\"\ndate: 2017-9-4 19:58\ncomments: true\nreward: true\ntags: \n\t- 校招\n---\n\n8月26号辞去实习，回学校准备校招，刷了一些题目。在此做个自己认为常考题的总结。\n\n### 1.在32位系统下char* p[10]; char(*p1)[10]，sizeof(p)和sizeof (p1)分别值为？\n\n![image](https://wx4.sinaimg.cn/large/aacc02d8ly1fxvowcbqaqj20ie0b6dgo.jpg)\n\n<!--more--> \n\n### 2.C++类的内存大小计算\n\n![image](https://wx2.sinaimg.cn/large/aacc02d8ly1fxvowk1t20j20tx0gnjva.jpg)\n\n![image](https://ws3.sinaimg.cn/large/aacc02d8ly1fxvowq8xj4j20tg076myx.jpg)\n\n\n\n### 3.排序算法性能的比较及应用\n\n**时间复杂度**：简单选择排序、直接插入排序和冒泡排序的平均情况下的时间复杂度都为O(n^2),实现过程较简单，但直接插入排序和冒泡排序在最好的情况下时间复杂度可以达到O(n)，而简单选择排序则与序列的初始状态无关。希尔排序作为插入排序的拓展，对较大规模的排序都可以达到很高的效率，但是目前未得出其精确的渐近时间。堆排序是利用了一种称为堆，可以在线性时间内完成建堆，并且在O(nlog2n)内完成排序过程。快速排序是基于分治的思想，最坏情况下快速排序时间会达到O(n^2)，但快速排序平均性能可以达到O(nlog2n)，实际应用中常常优于其他排序算法。归并排序同样是基于分治的思想，最坏和平均时间复杂度均为O(nlog2n)。\n\n**空间复杂度**：简单选择排序、插入排序、冒泡排序、希尔排序和堆排序仅需借助常数个辅助空间。快速排序在空间上只使用一个小的辅助栈，用于实现递归，平均情况大小为O(log2n)，最坏的情况下可能会增长到O(n)。二路归并排序需要借助较多的辅助空间用于元素复制，大小为O(n)。\n\n**稳定性**：插入排序、冒泡排序、归并排序和基数排序是稳定的排序方法，而简单选择排序、快速排序、希尔排序和堆排序都是不稳定的排序方法。对排序方法的稳定性，应从本身的原理上去理解，而不应拘泥于死记硬背。\n\n**应用**：\n\n1. 若n较小时(n<=50)，则可以采用直接插入排序或简单选择排序。\n2. 若文件的初始状态已按关键字基本有序，则选用直接插入或冒泡排序。\n3. 若n较大，则应采用时同复杂度为O(nlog2n)的排序方法快速排序、堆排序、归并排序。快速排序被认为是目前基于比较的内部排序法中最好的方法。若要求排序稳定且时间复杂度为O(nlog2n),则可选用归并排序。\n4. 若n很大，记录的关键字位数较少且可以分解时，采用基数排序较好。\n5. 当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结\n\n### 4.二叉树前序、中序、后序遍历相互求法\n\n例：\n\n前序遍历:         GDAFEMHZ\n\n中序遍历:         ADEFGHMZ\n\n**画树求法：**第一步，根据前序遍历的特点，我们知道根结点为G\n\n第二步，观察中序遍历ADEFGHMZ。其中root节点G左侧的ADEF必然是root的左子树，G右侧的HMZ必然是root的右子树。\n\n 第三步，观察左子树ADEF，左子树的中的根节点必然是大树的root的leftchild。在前序遍历中，大树的root的leftchild位于root之后，所以左子树的根节点为D。\n\n第四步，同样的道理，root的右子树节点HMZ中的根节点也可以通过前序遍历求得。在前序遍历中，一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。\n\n第五步，观察发现，上面的过程是递归的。先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了。该步递归的过程可以简洁表达如下：\n\n1 确定根,确定左子树，确定右子树。\n\n2 在左子树中递归。\n\n3 在右子树中递归。\n\n4 打印当前根。\n\n那么，我们可以画出这个二叉树的形状：\n\n![img](http://www.cr173.com/up/2013-1/2013010715404717978.jpg)\n\n那么，根据后序的遍历规则，我们可以知道，后序遍历顺序为：AEFDHZMG.","slug":"校招笔试题目总结（一）","published":1,"updated":"2020-08-09T05:24:13.297Z","photos":[],"link":"","_id":"ckdmsedzt000xlguw2m3csp5y","content":"<p>8月26号辞去实习，回学校准备校招，刷了一些题目。在此做个自己认为常考题的总结。</p>\n<h3 id=\"1-在32位系统下char-p-10-char-p1-10-，sizeof-p-和sizeof-p1-分别值为？\"><a href=\"#1-在32位系统下char-p-10-char-p1-10-，sizeof-p-和sizeof-p1-分别值为？\" class=\"headerlink\" title=\"1.在32位系统下char p[10]; char(p1)[10]，sizeof(p)和sizeof (p1)分别值为？\"></a>1.在32位系统下char<em> p[10]; char(</em>p1)[10]，sizeof(p)和sizeof (p1)分别值为？</h3><p><img src=\"https://wx4.sinaimg.cn/large/aacc02d8ly1fxvowcbqaqj20ie0b6dgo.jpg\" alt=\"image\"></p>\n<a id=\"more\"></a> \n<h3 id=\"2-C-类的内存大小计算\"><a href=\"#2-C-类的内存大小计算\" class=\"headerlink\" title=\"2.C++类的内存大小计算\"></a>2.C++类的内存大小计算</h3><p><img src=\"https://wx2.sinaimg.cn/large/aacc02d8ly1fxvowk1t20j20tx0gnjva.jpg\" alt=\"image\"></p>\n<p><img src=\"https://ws3.sinaimg.cn/large/aacc02d8ly1fxvowq8xj4j20tg076myx.jpg\" alt=\"image\"></p>\n<h3 id=\"3-排序算法性能的比较及应用\"><a href=\"#3-排序算法性能的比较及应用\" class=\"headerlink\" title=\"3.排序算法性能的比较及应用\"></a>3.排序算法性能的比较及应用</h3><p><strong>时间复杂度</strong>：简单选择排序、直接插入排序和冒泡排序的平均情况下的时间复杂度都为O(n^2),实现过程较简单，但直接插入排序和冒泡排序在最好的情况下时间复杂度可以达到O(n)，而简单选择排序则与序列的初始状态无关。希尔排序作为插入排序的拓展，对较大规模的排序都可以达到很高的效率，但是目前未得出其精确的渐近时间。堆排序是利用了一种称为堆，可以在线性时间内完成建堆，并且在O(nlog2n)内完成排序过程。快速排序是基于分治的思想，最坏情况下快速排序时间会达到O(n^2)，但快速排序平均性能可以达到O(nlog2n)，实际应用中常常优于其他排序算法。归并排序同样是基于分治的思想，最坏和平均时间复杂度均为O(nlog2n)。</p>\n<p><strong>空间复杂度</strong>：简单选择排序、插入排序、冒泡排序、希尔排序和堆排序仅需借助常数个辅助空间。快速排序在空间上只使用一个小的辅助栈，用于实现递归，平均情况大小为O(log2n)，最坏的情况下可能会增长到O(n)。二路归并排序需要借助较多的辅助空间用于元素复制，大小为O(n)。</p>\n<p><strong>稳定性</strong>：插入排序、冒泡排序、归并排序和基数排序是稳定的排序方法，而简单选择排序、快速排序、希尔排序和堆排序都是不稳定的排序方法。对排序方法的稳定性，应从本身的原理上去理解，而不应拘泥于死记硬背。</p>\n<p><strong>应用</strong>：</p>\n<ol>\n<li>若n较小时(n&lt;=50)，则可以采用直接插入排序或简单选择排序。</li>\n<li>若文件的初始状态已按关键字基本有序，则选用直接插入或冒泡排序。</li>\n<li>若n较大，则应采用时同复杂度为O(nlog2n)的排序方法快速排序、堆排序、归并排序。快速排序被认为是目前基于比较的内部排序法中最好的方法。若要求排序稳定且时间复杂度为O(nlog2n),则可选用归并排序。</li>\n<li>若n很大，记录的关键字位数较少且可以分解时，采用基数排序较好。</li>\n<li>当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结</li>\n</ol>\n<h3 id=\"4-二叉树前序、中序、后序遍历相互求法\"><a href=\"#4-二叉树前序、中序、后序遍历相互求法\" class=\"headerlink\" title=\"4.二叉树前序、中序、后序遍历相互求法\"></a>4.二叉树前序、中序、后序遍历相互求法</h3><p>例：</p>\n<p>前序遍历:         GDAFEMHZ</p>\n<p>中序遍历:         ADEFGHMZ</p>\n<p><strong>画树求法：</strong>第一步，根据前序遍历的特点，我们知道根结点为G</p>\n<p>第二步，观察中序遍历ADEFGHMZ。其中root节点G左侧的ADEF必然是root的左子树，G右侧的HMZ必然是root的右子树。</p>\n<p> 第三步，观察左子树ADEF，左子树的中的根节点必然是大树的root的leftchild。在前序遍历中，大树的root的leftchild位于root之后，所以左子树的根节点为D。</p>\n<p>第四步，同样的道理，root的右子树节点HMZ中的根节点也可以通过前序遍历求得。在前序遍历中，一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。</p>\n<p>第五步，观察发现，上面的过程是递归的。先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了。该步递归的过程可以简洁表达如下：</p>\n<p>1 确定根,确定左子树，确定右子树。</p>\n<p>2 在左子树中递归。</p>\n<p>3 在右子树中递归。</p>\n<p>4 打印当前根。</p>\n<p>那么，我们可以画出这个二叉树的形状：</p>\n<p><img src=\"http://www.cr173.com/up/2013-1/2013010715404717978.jpg\" alt=\"img\"></p>\n<p>那么，根据后序的遍历规则，我们可以知道，后序遍历顺序为：AEFDHZMG.</p>\n","site":{"data":{}},"excerpt":"<p>8月26号辞去实习，回学校准备校招，刷了一些题目。在此做个自己认为常考题的总结。</p>\n<h3 id=\"1-在32位系统下char-p-10-char-p1-10-，sizeof-p-和sizeof-p1-分别值为？\"><a href=\"#1-在32位系统下char-p-10-char-p1-10-，sizeof-p-和sizeof-p1-分别值为？\" class=\"headerlink\" title=\"1.在32位系统下char p[10]; char(p1)[10]，sizeof(p)和sizeof (p1)分别值为？\"></a>1.在32位系统下char<em> p[10]; char(</em>p1)[10]，sizeof(p)和sizeof (p1)分别值为？</h3><p><img src=\"https://wx4.sinaimg.cn/large/aacc02d8ly1fxvowcbqaqj20ie0b6dgo.jpg\" alt=\"image\"></p>","more":"<h3 id=\"2-C-类的内存大小计算\"><a href=\"#2-C-类的内存大小计算\" class=\"headerlink\" title=\"2.C++类的内存大小计算\"></a>2.C++类的内存大小计算</h3><p><img src=\"https://wx2.sinaimg.cn/large/aacc02d8ly1fxvowk1t20j20tx0gnjva.jpg\" alt=\"image\"></p>\n<p><img src=\"https://ws3.sinaimg.cn/large/aacc02d8ly1fxvowq8xj4j20tg076myx.jpg\" alt=\"image\"></p>\n<h3 id=\"3-排序算法性能的比较及应用\"><a href=\"#3-排序算法性能的比较及应用\" class=\"headerlink\" title=\"3.排序算法性能的比较及应用\"></a>3.排序算法性能的比较及应用</h3><p><strong>时间复杂度</strong>：简单选择排序、直接插入排序和冒泡排序的平均情况下的时间复杂度都为O(n^2),实现过程较简单，但直接插入排序和冒泡排序在最好的情况下时间复杂度可以达到O(n)，而简单选择排序则与序列的初始状态无关。希尔排序作为插入排序的拓展，对较大规模的排序都可以达到很高的效率，但是目前未得出其精确的渐近时间。堆排序是利用了一种称为堆，可以在线性时间内完成建堆，并且在O(nlog2n)内完成排序过程。快速排序是基于分治的思想，最坏情况下快速排序时间会达到O(n^2)，但快速排序平均性能可以达到O(nlog2n)，实际应用中常常优于其他排序算法。归并排序同样是基于分治的思想，最坏和平均时间复杂度均为O(nlog2n)。</p>\n<p><strong>空间复杂度</strong>：简单选择排序、插入排序、冒泡排序、希尔排序和堆排序仅需借助常数个辅助空间。快速排序在空间上只使用一个小的辅助栈，用于实现递归，平均情况大小为O(log2n)，最坏的情况下可能会增长到O(n)。二路归并排序需要借助较多的辅助空间用于元素复制，大小为O(n)。</p>\n<p><strong>稳定性</strong>：插入排序、冒泡排序、归并排序和基数排序是稳定的排序方法，而简单选择排序、快速排序、希尔排序和堆排序都是不稳定的排序方法。对排序方法的稳定性，应从本身的原理上去理解，而不应拘泥于死记硬背。</p>\n<p><strong>应用</strong>：</p>\n<ol>\n<li>若n较小时(n&lt;=50)，则可以采用直接插入排序或简单选择排序。</li>\n<li>若文件的初始状态已按关键字基本有序，则选用直接插入或冒泡排序。</li>\n<li>若n较大，则应采用时同复杂度为O(nlog2n)的排序方法快速排序、堆排序、归并排序。快速排序被认为是目前基于比较的内部排序法中最好的方法。若要求排序稳定且时间复杂度为O(nlog2n),则可选用归并排序。</li>\n<li>若n很大，记录的关键字位数较少且可以分解时，采用基数排序较好。</li>\n<li>当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结</li>\n</ol>\n<h3 id=\"4-二叉树前序、中序、后序遍历相互求法\"><a href=\"#4-二叉树前序、中序、后序遍历相互求法\" class=\"headerlink\" title=\"4.二叉树前序、中序、后序遍历相互求法\"></a>4.二叉树前序、中序、后序遍历相互求法</h3><p>例：</p>\n<p>前序遍历:         GDAFEMHZ</p>\n<p>中序遍历:         ADEFGHMZ</p>\n<p><strong>画树求法：</strong>第一步，根据前序遍历的特点，我们知道根结点为G</p>\n<p>第二步，观察中序遍历ADEFGHMZ。其中root节点G左侧的ADEF必然是root的左子树，G右侧的HMZ必然是root的右子树。</p>\n<p> 第三步，观察左子树ADEF，左子树的中的根节点必然是大树的root的leftchild。在前序遍历中，大树的root的leftchild位于root之后，所以左子树的根节点为D。</p>\n<p>第四步，同样的道理，root的右子树节点HMZ中的根节点也可以通过前序遍历求得。在前序遍历中，一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。</p>\n<p>第五步，观察发现，上面的过程是递归的。先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了。该步递归的过程可以简洁表达如下：</p>\n<p>1 确定根,确定左子树，确定右子树。</p>\n<p>2 在左子树中递归。</p>\n<p>3 在右子树中递归。</p>\n<p>4 打印当前根。</p>\n<p>那么，我们可以画出这个二叉树的形状：</p>\n<p><img src=\"http://www.cr173.com/up/2013-1/2013010715404717978.jpg\" alt=\"img\"></p>\n<p>那么，根据后序的遍历规则，我们可以知道，后序遍历顺序为：AEFDHZMG.</p>"},{"title":"泛型类与泛型方法","author":"Zhang Peng","date":"2018-07-09T01:03:00.000Z","_content":"### 1 泛型类\n\n泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。 \n\n设计这个类的时候，在类的声明上，加上一个<T>，表示该类支持泛型。 T是type的缩写，也可以使用任何其他的合法的变量，比如A,B,X都可以，但是一般约定成俗使用T，代表类型。 \n\n<!--more--> \n\n#### 实例\n\n如下实例演示了我们如何定义一个泛型类:\n\n```java\npublic class Box<T> {\n   \n  private T t;\n \n  public void add(T t) {\n    this.t = t;\n  }\n \n  public T get() {\n    return t;\n  }\n \n  public static void main(String[] args) {\n    Box<Integer> integerBox = new Box<Integer>();\n    Box<String> stringBox = new Box<String>();\n \n    integerBox.add(new Integer(10));\n    stringBox.add(new String(\"菜鸟教程\"));\n \n    System.out.printf(\"整型值为 :%d\\n\\n\", integerBox.get());\n    System.out.printf(\"字符串为 :%s\\n\", stringBox.get());\n  }\n}\n\n```\n\n### 2 泛型方法\n\n- 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的< T > ）。\n\n```java\n    public static <T> T jsonToEntity (String json, Class<T> targertClass) {\n\n        if(!StringUtils.isEmpty(json)) {\n            T entity = JSON.parseObject(json, targertClass);\n            return entity;\n        }\n        return null;\n    }\n```\n\n### 3 T与？区别\n\n大家可能会有疑问，那无边界通配符？与泛型变量T有什么区别呢？\n答案是：他们俩没有任何联系！！！！！\n泛型变量T不能在代码用于创建变量，只能在类，接口，函数中声明以后，才能使用。\n\n而无边界通配符？则只能用于填充泛型变量T，表示通配任何类型！！！！再重复一遍：？只能用于填充泛型变量T。它是用来填充T的！！！！只是填充方式的一种！！！\n\n```\n//无边界通配符填充  \nBox<?> box;  \n//其它类型填充  \nBox<String> stringBox;  \n```\n\n类型参数“<T>”主要用于第一种，声明泛型类或泛型方法。\n\n无界通配符“<?>”主要用于第二种，使用泛型类或泛型方法。","source":"_posts/泛型类与泛型方法.md","raw":"title: 泛型类与泛型方法\nauthor: Zhang Peng\ntags:\n  - JAVA\ncategories: []\ndate: 2018-07-09 09:03:00\n---\n### 1 泛型类\n\n泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。 \n\n设计这个类的时候，在类的声明上，加上一个<T>，表示该类支持泛型。 T是type的缩写，也可以使用任何其他的合法的变量，比如A,B,X都可以，但是一般约定成俗使用T，代表类型。 \n\n<!--more--> \n\n#### 实例\n\n如下实例演示了我们如何定义一个泛型类:\n\n```java\npublic class Box<T> {\n   \n  private T t;\n \n  public void add(T t) {\n    this.t = t;\n  }\n \n  public T get() {\n    return t;\n  }\n \n  public static void main(String[] args) {\n    Box<Integer> integerBox = new Box<Integer>();\n    Box<String> stringBox = new Box<String>();\n \n    integerBox.add(new Integer(10));\n    stringBox.add(new String(\"菜鸟教程\"));\n \n    System.out.printf(\"整型值为 :%d\\n\\n\", integerBox.get());\n    System.out.printf(\"字符串为 :%s\\n\", stringBox.get());\n  }\n}\n\n```\n\n### 2 泛型方法\n\n- 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的< T > ）。\n\n```java\n    public static <T> T jsonToEntity (String json, Class<T> targertClass) {\n\n        if(!StringUtils.isEmpty(json)) {\n            T entity = JSON.parseObject(json, targertClass);\n            return entity;\n        }\n        return null;\n    }\n```\n\n### 3 T与？区别\n\n大家可能会有疑问，那无边界通配符？与泛型变量T有什么区别呢？\n答案是：他们俩没有任何联系！！！！！\n泛型变量T不能在代码用于创建变量，只能在类，接口，函数中声明以后，才能使用。\n\n而无边界通配符？则只能用于填充泛型变量T，表示通配任何类型！！！！再重复一遍：？只能用于填充泛型变量T。它是用来填充T的！！！！只是填充方式的一种！！！\n\n```\n//无边界通配符填充  \nBox<?> box;  \n//其它类型填充  \nBox<String> stringBox;  \n```\n\n类型参数“<T>”主要用于第一种，声明泛型类或泛型方法。\n\n无界通配符“<?>”主要用于第二种，使用泛型类或泛型方法。","slug":"泛型类与泛型方法","published":1,"updated":"2020-08-09T05:24:13.297Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdmsedzv000zlguw8544adeo","content":"<h3 id=\"1-泛型类\"><a href=\"#1-泛型类\" class=\"headerlink\" title=\"1 泛型类\"></a>1 泛型类</h3><p>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。 </p>\n<p>设计这个类的时候，在类的声明上，加上一个<t>，表示该类支持泛型。 T是type的缩写，也可以使用任何其他的合法的变量，比如A,B,X都可以，但是一般约定成俗使用T，代表类型。 </t></p>\n<a id=\"more\"></a> \n<h4 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h4><p>如下实例演示了我们如何定义一个泛型类:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">  <span class=\"keyword\">private</span> T t;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.t = t;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Box&lt;Integer&gt; integerBox = <span class=\"keyword\">new</span> Box&lt;Integer&gt;();</span><br><span class=\"line\">    Box&lt;String&gt; stringBox = <span class=\"keyword\">new</span> Box&lt;String&gt;();</span><br><span class=\"line\"> </span><br><span class=\"line\">    integerBox.add(<span class=\"keyword\">new</span> Integer(<span class=\"number\">10</span>));</span><br><span class=\"line\">    stringBox.add(<span class=\"keyword\">new</span> String(<span class=\"string\">\"菜鸟教程\"</span>));</span><br><span class=\"line\"> </span><br><span class=\"line\">    System.out.printf(<span class=\"string\">\"整型值为 :%d\\n\\n\"</span>, integerBox.get());</span><br><span class=\"line\">    System.out.printf(<span class=\"string\">\"字符串为 :%s\\n\"</span>, stringBox.get());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-泛型方法\"><a href=\"#2-泛型方法\" class=\"headerlink\" title=\"2 泛型方法\"></a>2 泛型方法</h3><ul>\n<li>所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的&lt; T &gt; ）。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">jsonToEntity</span> <span class=\"params\">(String json, Class&lt;T&gt; targertClass)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!StringUtils.isEmpty(json)) &#123;</span><br><span class=\"line\">        T entity = JSON.parseObject(json, targertClass);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> entity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-T与？区别\"><a href=\"#3-T与？区别\" class=\"headerlink\" title=\"3 T与？区别\"></a>3 T与？区别</h3><p>大家可能会有疑问，那无边界通配符？与泛型变量T有什么区别呢？<br>答案是：他们俩没有任何联系！！！！！<br>泛型变量T不能在代码用于创建变量，只能在类，接口，函数中声明以后，才能使用。</p>\n<p>而无边界通配符？则只能用于填充泛型变量T，表示通配任何类型！！！！再重复一遍：？只能用于填充泛型变量T。它是用来填充T的！！！！只是填充方式的一种！！！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//无边界通配符填充  </span><br><span class=\"line\">Box&lt;?&gt; box;  </span><br><span class=\"line\">//其它类型填充  </span><br><span class=\"line\">Box&lt;String&gt; stringBox;</span><br></pre></td></tr></table></figure>\n<p>类型参数“<t>”主要用于第一种，声明泛型类或泛型方法。</t></p>\n<p>无界通配符“&lt;?&gt;”主要用于第二种，使用泛型类或泛型方法。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-泛型类\"><a href=\"#1-泛型类\" class=\"headerlink\" title=\"1 泛型类\"></a>1 泛型类</h3><p>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。 </p>\n<p>设计这个类的时候，在类的声明上，加上一个<t>，表示该类支持泛型。 T是type的缩写，也可以使用任何其他的合法的变量，比如A,B,X都可以，但是一般约定成俗使用T，代表类型。 </t></p>","more":"<h4 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h4><p>如下实例演示了我们如何定义一个泛型类:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">  <span class=\"keyword\">private</span> T t;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.t = t;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Box&lt;Integer&gt; integerBox = <span class=\"keyword\">new</span> Box&lt;Integer&gt;();</span><br><span class=\"line\">    Box&lt;String&gt; stringBox = <span class=\"keyword\">new</span> Box&lt;String&gt;();</span><br><span class=\"line\"> </span><br><span class=\"line\">    integerBox.add(<span class=\"keyword\">new</span> Integer(<span class=\"number\">10</span>));</span><br><span class=\"line\">    stringBox.add(<span class=\"keyword\">new</span> String(<span class=\"string\">\"菜鸟教程\"</span>));</span><br><span class=\"line\"> </span><br><span class=\"line\">    System.out.printf(<span class=\"string\">\"整型值为 :%d\\n\\n\"</span>, integerBox.get());</span><br><span class=\"line\">    System.out.printf(<span class=\"string\">\"字符串为 :%s\\n\"</span>, stringBox.get());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-泛型方法\"><a href=\"#2-泛型方法\" class=\"headerlink\" title=\"2 泛型方法\"></a>2 泛型方法</h3><ul>\n<li>所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的&lt; T &gt; ）。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">jsonToEntity</span> <span class=\"params\">(String json, Class&lt;T&gt; targertClass)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!StringUtils.isEmpty(json)) &#123;</span><br><span class=\"line\">        T entity = JSON.parseObject(json, targertClass);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> entity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-T与？区别\"><a href=\"#3-T与？区别\" class=\"headerlink\" title=\"3 T与？区别\"></a>3 T与？区别</h3><p>大家可能会有疑问，那无边界通配符？与泛型变量T有什么区别呢？<br>答案是：他们俩没有任何联系！！！！！<br>泛型变量T不能在代码用于创建变量，只能在类，接口，函数中声明以后，才能使用。</p>\n<p>而无边界通配符？则只能用于填充泛型变量T，表示通配任何类型！！！！再重复一遍：？只能用于填充泛型变量T。它是用来填充T的！！！！只是填充方式的一种！！！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//无边界通配符填充  </span><br><span class=\"line\">Box&lt;?&gt; box;  </span><br><span class=\"line\">//其它类型填充  </span><br><span class=\"line\">Box&lt;String&gt; stringBox;</span><br></pre></td></tr></table></figure>\n<p>类型参数“<t>”主要用于第一种，声明泛型类或泛型方法。</t></p>\n<p>无界通配符“&lt;?&gt;”主要用于第二种，使用泛型类或泛型方法。</p>"},{"layout":"post","title":"编程笔面试题","date":"2017-10-05T06:58:00.000Z","comments":1,"reward":true,"_content":"\n### 1.字符串复制函数(strcpy)\n\n```c++\nchar* strcpy(char* dst, const char* src)   \n{\n\tassert(dst != NULL && src != NULL);    \n\tchar *ret = dst;  \n\twhile ((*dst++ = *src++) != '\\0'); \n\treturn ret;\n}\n```\n\n<!--more--> \n\n### 2.内存复制函数(memcpy)\n\n```c++\nvoid* memcpy2(void* dest, const void* src, int count)\n{\n\tchar* d;\n\tconst char* s;\n\tif (dest >= ((char *)src + count) || dest <= src)\n\t{\n\t\td = (char *)dest;\n\t\ts = (char *)src;\n\t\twhile (count--)\n\t\t\t*d++ = *s++;\n\t}\n\telse //memory overlap\n\t{\n\t\td = (char*)dest + count - 1;\n\t\ts = (char*)src + count - 1;\n\t\twhile (count--)\n\t\t\t*d-- = *s--;\n\t}\n\treturn dest;\n}\n```\n\n### 3.合并两个有序的链表\n\n```c++\nNode* listMerge(Node* head1, Node* head2)\n{\n\tif(head1 == NULL)\n  \t\treturn head2;\n  \tif(head2 == NULL)\n  \t\treturn head1\n  \tNode* head = NULL;\n  \tif(head1.val > head2.val)\n  \t{\n      head = head2;\n      head->next = listMerge(head1, head2->next);\n  \t}else\n  \t{\n      head = head1;\n      head->next = listMerge(head1->next, head2);\n  \t}\n  \treturn head;\n}\n```\n\n### 4.逆转链表\n\n```c++\nNode* reverseList(Node* head)\n{\n\tNode* pre = NULL;\n\tNode* res = NULL;\n  \twhile(head != NULL)\n  \t{\n  \t\tres = head->next;\n  \t\thead->next = pre;\n  \t\tpre = head;\n  \t\thead = res;\n  \t}\n  return pre;\n}\n```\n\n","source":"_posts/编程笔面试题.md","raw":"---\nlayout: post\ntitle: \"编程笔面试题\"\ndate: 2017-10-05 14:58\ncomments: true\nreward: true\ntags: \n\t- 校招\n---\n\n### 1.字符串复制函数(strcpy)\n\n```c++\nchar* strcpy(char* dst, const char* src)   \n{\n\tassert(dst != NULL && src != NULL);    \n\tchar *ret = dst;  \n\twhile ((*dst++ = *src++) != '\\0'); \n\treturn ret;\n}\n```\n\n<!--more--> \n\n### 2.内存复制函数(memcpy)\n\n```c++\nvoid* memcpy2(void* dest, const void* src, int count)\n{\n\tchar* d;\n\tconst char* s;\n\tif (dest >= ((char *)src + count) || dest <= src)\n\t{\n\t\td = (char *)dest;\n\t\ts = (char *)src;\n\t\twhile (count--)\n\t\t\t*d++ = *s++;\n\t}\n\telse //memory overlap\n\t{\n\t\td = (char*)dest + count - 1;\n\t\ts = (char*)src + count - 1;\n\t\twhile (count--)\n\t\t\t*d-- = *s--;\n\t}\n\treturn dest;\n}\n```\n\n### 3.合并两个有序的链表\n\n```c++\nNode* listMerge(Node* head1, Node* head2)\n{\n\tif(head1 == NULL)\n  \t\treturn head2;\n  \tif(head2 == NULL)\n  \t\treturn head1\n  \tNode* head = NULL;\n  \tif(head1.val > head2.val)\n  \t{\n      head = head2;\n      head->next = listMerge(head1, head2->next);\n  \t}else\n  \t{\n      head = head1;\n      head->next = listMerge(head1->next, head2);\n  \t}\n  \treturn head;\n}\n```\n\n### 4.逆转链表\n\n```c++\nNode* reverseList(Node* head)\n{\n\tNode* pre = NULL;\n\tNode* res = NULL;\n  \twhile(head != NULL)\n  \t{\n  \t\tres = head->next;\n  \t\thead->next = pre;\n  \t\tpre = head;\n  \t\thead = res;\n  \t}\n  return pre;\n}\n```\n\n","slug":"编程笔面试题","published":1,"updated":"2020-08-09T05:24:13.299Z","photos":[],"link":"","_id":"ckdmsedzx0012lguwz2pggvqp","content":"<h3 id=\"1-字符串复制函数-strcpy\"><a href=\"#1-字符串复制函数-strcpy\" class=\"headerlink\" title=\"1.字符串复制函数(strcpy)\"></a>1.字符串复制函数(strcpy)</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">strcpy</span><span class=\"params\">(<span class=\"keyword\">char</span>* dst, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* src)</span>   </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tassert(dst != <span class=\"literal\">NULL</span> &amp;&amp; src != <span class=\"literal\">NULL</span>);    </span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *ret = dst;  </span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((*dst++ = *src++) != <span class=\"string\">'\\0'</span>); </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a> \n<h3 id=\"2-内存复制函数-memcpy\"><a href=\"#2-内存复制函数-memcpy\" class=\"headerlink\" title=\"2.内存复制函数(memcpy)\"></a>2.内存复制函数(memcpy)</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">memcpy2</span><span class=\"params\">(<span class=\"keyword\">void</span>* dest, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* src, <span class=\"keyword\">int</span> count)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* d;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dest &gt;= ((<span class=\"keyword\">char</span> *)src + count) || dest &lt;= src)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\td = (<span class=\"keyword\">char</span> *)dest;</span><br><span class=\"line\">\t\ts = (<span class=\"keyword\">char</span> *)src;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (count--)</span><br><span class=\"line\">\t\t\t*d++ = *s++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"comment\">//memory overlap</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\td = (<span class=\"keyword\">char</span>*)dest + count - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\ts = (<span class=\"keyword\">char</span>*)src + count - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (count--)</span><br><span class=\"line\">\t\t\t*d-- = *s--;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-合并两个有序的链表\"><a href=\"#3-合并两个有序的链表\" class=\"headerlink\" title=\"3.合并两个有序的链表\"></a>3.合并两个有序的链表</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Node* <span class=\"title\">listMerge</span><span class=\"params\">(Node* head1, Node* head2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(head1 == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">  \t\t<span class=\"keyword\">return</span> head2;</span><br><span class=\"line\">  \t<span class=\"keyword\">if</span>(head2 == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">  \t\t<span class=\"keyword\">return</span> head1</span><br><span class=\"line\">  \tNode* head = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  \t<span class=\"keyword\">if</span>(head1.val &gt; head2.val)</span><br><span class=\"line\">  \t&#123;</span><br><span class=\"line\">      head = head2;</span><br><span class=\"line\">      head-&gt;next = listMerge(head1, head2-&gt;next);</span><br><span class=\"line\">  \t&#125;<span class=\"keyword\">else</span></span><br><span class=\"line\">  \t&#123;</span><br><span class=\"line\">      head = head1;</span><br><span class=\"line\">      head-&gt;next = listMerge(head1-&gt;next, head2);</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">  \t<span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-逆转链表\"><a href=\"#4-逆转链表\" class=\"headerlink\" title=\"4.逆转链表\"></a>4.逆转链表</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Node* <span class=\"title\">reverseList</span><span class=\"params\">(Node* head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tNode* pre = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tNode* res = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  \t<span class=\"keyword\">while</span>(head != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">  \t&#123;</span><br><span class=\"line\">  \t\tres = head-&gt;next;</span><br><span class=\"line\">  \t\thead-&gt;next = pre;</span><br><span class=\"line\">  \t\tpre = head;</span><br><span class=\"line\">  \t\thead = res;</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-字符串复制函数-strcpy\"><a href=\"#1-字符串复制函数-strcpy\" class=\"headerlink\" title=\"1.字符串复制函数(strcpy)\"></a>1.字符串复制函数(strcpy)</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">strcpy</span><span class=\"params\">(<span class=\"keyword\">char</span>* dst, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* src)</span>   </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tassert(dst != <span class=\"literal\">NULL</span> &amp;&amp; src != <span class=\"literal\">NULL</span>);    </span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *ret = dst;  </span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((*dst++ = *src++) != <span class=\"string\">'\\0'</span>); </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<h3 id=\"2-内存复制函数-memcpy\"><a href=\"#2-内存复制函数-memcpy\" class=\"headerlink\" title=\"2.内存复制函数(memcpy)\"></a>2.内存复制函数(memcpy)</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">memcpy2</span><span class=\"params\">(<span class=\"keyword\">void</span>* dest, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* src, <span class=\"keyword\">int</span> count)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* d;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dest &gt;= ((<span class=\"keyword\">char</span> *)src + count) || dest &lt;= src)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\td = (<span class=\"keyword\">char</span> *)dest;</span><br><span class=\"line\">\t\ts = (<span class=\"keyword\">char</span> *)src;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (count--)</span><br><span class=\"line\">\t\t\t*d++ = *s++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"comment\">//memory overlap</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\td = (<span class=\"keyword\">char</span>*)dest + count - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\ts = (<span class=\"keyword\">char</span>*)src + count - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (count--)</span><br><span class=\"line\">\t\t\t*d-- = *s--;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-合并两个有序的链表\"><a href=\"#3-合并两个有序的链表\" class=\"headerlink\" title=\"3.合并两个有序的链表\"></a>3.合并两个有序的链表</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Node* <span class=\"title\">listMerge</span><span class=\"params\">(Node* head1, Node* head2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(head1 == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">  \t\t<span class=\"keyword\">return</span> head2;</span><br><span class=\"line\">  \t<span class=\"keyword\">if</span>(head2 == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">  \t\t<span class=\"keyword\">return</span> head1</span><br><span class=\"line\">  \tNode* head = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  \t<span class=\"keyword\">if</span>(head1.val &gt; head2.val)</span><br><span class=\"line\">  \t&#123;</span><br><span class=\"line\">      head = head2;</span><br><span class=\"line\">      head-&gt;next = listMerge(head1, head2-&gt;next);</span><br><span class=\"line\">  \t&#125;<span class=\"keyword\">else</span></span><br><span class=\"line\">  \t&#123;</span><br><span class=\"line\">      head = head1;</span><br><span class=\"line\">      head-&gt;next = listMerge(head1-&gt;next, head2);</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">  \t<span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-逆转链表\"><a href=\"#4-逆转链表\" class=\"headerlink\" title=\"4.逆转链表\"></a>4.逆转链表</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Node* <span class=\"title\">reverseList</span><span class=\"params\">(Node* head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tNode* pre = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tNode* res = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  \t<span class=\"keyword\">while</span>(head != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">  \t&#123;</span><br><span class=\"line\">  \t\tres = head-&gt;next;</span><br><span class=\"line\">  \t\thead-&gt;next = pre;</span><br><span class=\"line\">  \t\tpre = head;</span><br><span class=\"line\">  \t\thead = res;</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"自我提升总结","author":"Zhang Peng","date":"2018-07-26T03:13:00.000Z","_content":"说明：文章是基于结构性思维写出的，下图将文章进行高度概括，详细内容可见全文（选择性阅读即可）。\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1at98fsj21dy096dga.jpg)\n\n#### **序言**\n\n随着公司的规模的扩大，应届生的数量也逐渐增长。然而，从学校刚进入公司的我们，难免会有多多少少的不适应。我们如何能尽快的适应职场环境和更好的成长了？上个星期，公司特与智联教育学院合作，为我们制定了为期5天的培训课程，取得了非常好的效果。\n\n#### **结论**\n\n在这5天的培训课程中，使我的认知、沟通和思考方式得以提升。\n\n#### **1. 学校到职场的转变**\n<!--more--> \n**1.1 个人与团队**\n\n在学校更多的是以个体为单位，我们以自我为中心去上课，心情不好就直接翘课，没有约束。在公司更多是以团队为单位，自己的服务的客户会影响整个团队的绩效，自己写的代码会影响整个团队的开发效率。**自己做的事情将不再再仅仅影响个人，还会影响整个团队**。同时，个人积极的作用会带动起整个团队，反之，则会拖团队的后退。\n\n**1.2 兴趣与职业**\n\n学生的生活更多是凭借自己的兴趣与情绪，我们往往会对自己感兴趣的课程认真听讲，而对无聊乏味的课程则在下面玩手机。但是在公司，我们从事相应的职业，是为他人服务，形成绩效。这是我们职责所在而不在是凭借兴趣，并且**我们应当从追求快乐转变为追求责任**。\n\n**1.3 思维与行动**\n\n学生的思维都很活跃，新点子层出不穷。学校中学习知识，往往是以训练思维为主，注重的是成绩。而在公司，是需要将我们的思维转换为产品，将知识转为绩效，注重的是可行性和商业价值。\n\n**1.4 性格自知**\n\n通过性格色彩测试，了解自己，改变自己。人生嘛，本就是一场提升心智的旅程。\n\n#### **2.时间管理**\n\n**2.1 重要紧急理论**\n\n​\t我们生活中所碰到的事情可以分为以下四类：\n\n​\t重要且紧急—立刻亲自处理\n\n​\t重要但不紧急（这一点最重要）—计划性处理\n\n​\t紧急但不重要—授权委任\n\n​\t不重要且不紧急—当作没看见\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxv0xopdelj20iq0estfl.jpg)\n\n**2.2 为什么重要但不紧急的事是最需要关注的了？**\n\n我们在生活中会遇到这种场景，每天都很忙碌。但忙完一阵子会发现，自己都不知道在忙什么了，然后心里有时候会安慰自己：反正我没有在玩，我在忙就行了。静下心来就会觉得我们是在沉溺于这种虚幻的充实满足感，做事时依靠的是自己的偏好和外界压力。根据重要紧急理论分析，这种情况就是一直在做重要且紧急的事情和紧急但不重要的事情。为了解除这种困境，对于重要且紧急的事情尽量减少，重要但不紧急的是通过列清单（To do list）来解决。重要但不紧急的事情则要规划好，有了规划，就知道了自己昨天完成了什么，今天在做什么，明天要干什么。每完成规划中的一个阶段，都可以明确知道，还可以知道距离多久能完成这个规划。其本质就是**让规划的事情可视化**。\n\n#### **3.目标管理**\n\n**3.1目标分析法**\n\n说到目标也是说白了也是要规划，要**对目标有全局的考虑**。最常见的误区是碰到一件事时拿起来就干；订下目标后，一来就开始朝着目标前进。可以根据鱼骨分析法按照先整体后细节对目标进行分解，根据SMART原则制定出具体的（Specific），可测量的（Measurable ），可达到的（Attainable），相关的（Relevant），有时间的（Time based ）的目标。当目标产生冲突时，根据目标矩阵发来选择最优解。通过上述3种方法，这样会清楚的知道自己要按照怎样的流程来朝着目标前进。\n\n**3.2 三个Flag**\n\n​\ta.四周时间看完剩下的《SpringBoot微信点餐系统》\n\n​\tb.每天中午休息时间看5分钟的书\n\n​\tc.每天10个深蹲\n\n#### **4.结构性思维**\n\n有时候我说话会了一堆，可是很多人还是不明白。其背后的主要原因是自己没有想清楚，就开口说了，想到哪里就说到哪里。结构性思维会是很好的解决方法。结构性思维是采用的总分形式，其结构就像高中的议论文一样。先进行背景介绍（即序言）提出主要观点，然后对其展开并进行论证。在与他人沟通时，会**想的清楚，说的明白**。让听者也会清楚的知道你想表达的意思。\n\n#### **5.高品质沟通**\n\n每个人来自不同的地方，成长于不同的环境。当然两人会对一件事情会有不同的看法。当双方都怀着：你听我的，你听我的！这种心态来沟通，想必双方彼此都不能了解对方的想法，甚至可能会导致不愉快的事情出现。如果将”你听我的“转换成”**我知道了你的观点，我的观点**“，同时想一下对方所说的话其原因是什么？最终彼此都会很好的知道了对方的想法。\n\n#### 6.心态管理\n\n**6.1 心态的三驾马车**\n\n我们平常所说的**心态，其具体表现形式是认知，情感，行为**。这三者相辅相存，互相影响。例如：当做一件事情时，我们觉得很无聊，接着就会想到这件事没有意义，最终结果就是不去做这件事情。我们再细想一下这个情景：如果当感到无聊的时，我们想到的是做这件事情可以磨砺我们，使我们成长，其最终结果是我们把这件事做完。\n\n同样的事情，认知的不同产生了不同的结果。这让我想到ABC理论。\n\n**6.2 情绪ABC理论** \n\n![http://s3.sinaimg.cn/mw690/86499eb1ge0f71c009592&690](http://s3.sinaimg.cn/mw690/86499eb1ge0f71c009592&690)\n\n情绪ABC理论框架：A（Antecedent）指事情的前因，C（Consequence）指事情的后果，有前因必有后果，但是有同样的前因A，产生了不一样的后果C1和C2。这是因为从前因到后果之间，一定会透过一座桥梁B（Bridge），这座桥梁就是认知和我们对情境的评价与解释。又因为，同一情境之下（A），不同的人的认知以及评价与解释不同（B1和B2），所以会得到不同结果（C1和C2）。\n\n因此，事情发生的一切根源缘于我们的认知(认知是指人们对事件的想法，解释和评价等）。**事物的本身并不影响人，人们只受对事物看法的影响。**\n\n\n\n听了这么多道理，**好好去做才是正道**。成功不必在我，而功力必不唐捐。\n\n#### 参考资料：\n\n​        1. [从学校到职场的转变](https://wenku.baidu.com/view/028ca126376baf1ffc4fad5a.html)\n\n​        2. [为什么时间管理上讲优先做的事情是最重要但不紧急的事情？By黛西瓜](https://www.zhihu.com/question/20247508/answer/41385012)\n\n​        3. [湖畔大学梁宁将情绪ABC理论神谕为“人的底层操作系统”，比能力强大100倍！By水伯](https://zhuanlan.zhihu.com/p/38532813)\n\n​        4. [结构性思维 By浩翊](https://zhuanlan.zhihu.com/p/22035979)\n\n​        5. [赠与今年的大学毕业生(1932年6月27日) By胡适](https://www.douban.com/note/86761045/)\n\n","source":"_posts/自我提升总结.md","raw":"---\ntitle: 自我提升总结\nauthor: Zhang Peng\ntags: \n\t- 个人提升\ndate: 2018-07-26 11:13:00\n---\n说明：文章是基于结构性思维写出的，下图将文章进行高度概括，详细内容可见全文（选择性阅读即可）。\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1at98fsj21dy096dga.jpg)\n\n#### **序言**\n\n随着公司的规模的扩大，应届生的数量也逐渐增长。然而，从学校刚进入公司的我们，难免会有多多少少的不适应。我们如何能尽快的适应职场环境和更好的成长了？上个星期，公司特与智联教育学院合作，为我们制定了为期5天的培训课程，取得了非常好的效果。\n\n#### **结论**\n\n在这5天的培训课程中，使我的认知、沟通和思考方式得以提升。\n\n#### **1. 学校到职场的转变**\n<!--more--> \n**1.1 个人与团队**\n\n在学校更多的是以个体为单位，我们以自我为中心去上课，心情不好就直接翘课，没有约束。在公司更多是以团队为单位，自己的服务的客户会影响整个团队的绩效，自己写的代码会影响整个团队的开发效率。**自己做的事情将不再再仅仅影响个人，还会影响整个团队**。同时，个人积极的作用会带动起整个团队，反之，则会拖团队的后退。\n\n**1.2 兴趣与职业**\n\n学生的生活更多是凭借自己的兴趣与情绪，我们往往会对自己感兴趣的课程认真听讲，而对无聊乏味的课程则在下面玩手机。但是在公司，我们从事相应的职业，是为他人服务，形成绩效。这是我们职责所在而不在是凭借兴趣，并且**我们应当从追求快乐转变为追求责任**。\n\n**1.3 思维与行动**\n\n学生的思维都很活跃，新点子层出不穷。学校中学习知识，往往是以训练思维为主，注重的是成绩。而在公司，是需要将我们的思维转换为产品，将知识转为绩效，注重的是可行性和商业价值。\n\n**1.4 性格自知**\n\n通过性格色彩测试，了解自己，改变自己。人生嘛，本就是一场提升心智的旅程。\n\n#### **2.时间管理**\n\n**2.1 重要紧急理论**\n\n​\t我们生活中所碰到的事情可以分为以下四类：\n\n​\t重要且紧急—立刻亲自处理\n\n​\t重要但不紧急（这一点最重要）—计划性处理\n\n​\t紧急但不重要—授权委任\n\n​\t不重要且不紧急—当作没看见\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxv0xopdelj20iq0estfl.jpg)\n\n**2.2 为什么重要但不紧急的事是最需要关注的了？**\n\n我们在生活中会遇到这种场景，每天都很忙碌。但忙完一阵子会发现，自己都不知道在忙什么了，然后心里有时候会安慰自己：反正我没有在玩，我在忙就行了。静下心来就会觉得我们是在沉溺于这种虚幻的充实满足感，做事时依靠的是自己的偏好和外界压力。根据重要紧急理论分析，这种情况就是一直在做重要且紧急的事情和紧急但不重要的事情。为了解除这种困境，对于重要且紧急的事情尽量减少，重要但不紧急的是通过列清单（To do list）来解决。重要但不紧急的事情则要规划好，有了规划，就知道了自己昨天完成了什么，今天在做什么，明天要干什么。每完成规划中的一个阶段，都可以明确知道，还可以知道距离多久能完成这个规划。其本质就是**让规划的事情可视化**。\n\n#### **3.目标管理**\n\n**3.1目标分析法**\n\n说到目标也是说白了也是要规划，要**对目标有全局的考虑**。最常见的误区是碰到一件事时拿起来就干；订下目标后，一来就开始朝着目标前进。可以根据鱼骨分析法按照先整体后细节对目标进行分解，根据SMART原则制定出具体的（Specific），可测量的（Measurable ），可达到的（Attainable），相关的（Relevant），有时间的（Time based ）的目标。当目标产生冲突时，根据目标矩阵发来选择最优解。通过上述3种方法，这样会清楚的知道自己要按照怎样的流程来朝着目标前进。\n\n**3.2 三个Flag**\n\n​\ta.四周时间看完剩下的《SpringBoot微信点餐系统》\n\n​\tb.每天中午休息时间看5分钟的书\n\n​\tc.每天10个深蹲\n\n#### **4.结构性思维**\n\n有时候我说话会了一堆，可是很多人还是不明白。其背后的主要原因是自己没有想清楚，就开口说了，想到哪里就说到哪里。结构性思维会是很好的解决方法。结构性思维是采用的总分形式，其结构就像高中的议论文一样。先进行背景介绍（即序言）提出主要观点，然后对其展开并进行论证。在与他人沟通时，会**想的清楚，说的明白**。让听者也会清楚的知道你想表达的意思。\n\n#### **5.高品质沟通**\n\n每个人来自不同的地方，成长于不同的环境。当然两人会对一件事情会有不同的看法。当双方都怀着：你听我的，你听我的！这种心态来沟通，想必双方彼此都不能了解对方的想法，甚至可能会导致不愉快的事情出现。如果将”你听我的“转换成”**我知道了你的观点，我的观点**“，同时想一下对方所说的话其原因是什么？最终彼此都会很好的知道了对方的想法。\n\n#### 6.心态管理\n\n**6.1 心态的三驾马车**\n\n我们平常所说的**心态，其具体表现形式是认知，情感，行为**。这三者相辅相存，互相影响。例如：当做一件事情时，我们觉得很无聊，接着就会想到这件事没有意义，最终结果就是不去做这件事情。我们再细想一下这个情景：如果当感到无聊的时，我们想到的是做这件事情可以磨砺我们，使我们成长，其最终结果是我们把这件事做完。\n\n同样的事情，认知的不同产生了不同的结果。这让我想到ABC理论。\n\n**6.2 情绪ABC理论** \n\n![http://s3.sinaimg.cn/mw690/86499eb1ge0f71c009592&690](http://s3.sinaimg.cn/mw690/86499eb1ge0f71c009592&690)\n\n情绪ABC理论框架：A（Antecedent）指事情的前因，C（Consequence）指事情的后果，有前因必有后果，但是有同样的前因A，产生了不一样的后果C1和C2。这是因为从前因到后果之间，一定会透过一座桥梁B（Bridge），这座桥梁就是认知和我们对情境的评价与解释。又因为，同一情境之下（A），不同的人的认知以及评价与解释不同（B1和B2），所以会得到不同结果（C1和C2）。\n\n因此，事情发生的一切根源缘于我们的认知(认知是指人们对事件的想法，解释和评价等）。**事物的本身并不影响人，人们只受对事物看法的影响。**\n\n\n\n听了这么多道理，**好好去做才是正道**。成功不必在我，而功力必不唐捐。\n\n#### 参考资料：\n\n​        1. [从学校到职场的转变](https://wenku.baidu.com/view/028ca126376baf1ffc4fad5a.html)\n\n​        2. [为什么时间管理上讲优先做的事情是最重要但不紧急的事情？By黛西瓜](https://www.zhihu.com/question/20247508/answer/41385012)\n\n​        3. [湖畔大学梁宁将情绪ABC理论神谕为“人的底层操作系统”，比能力强大100倍！By水伯](https://zhuanlan.zhihu.com/p/38532813)\n\n​        4. [结构性思维 By浩翊](https://zhuanlan.zhihu.com/p/22035979)\n\n​        5. [赠与今年的大学毕业生(1932年6月27日) By胡适](https://www.douban.com/note/86761045/)\n\n","slug":"自我提升总结","published":1,"updated":"2020-08-09T05:24:13.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdmsedzy0014lguw2hal4z0i","content":"<p>说明：文章是基于结构性思维写出的，下图将文章进行高度概括，详细内容可见全文（选择性阅读即可）。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1at98fsj21dy096dga.jpg\" alt></p>\n<h4 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a><strong>序言</strong></h4><p>随着公司的规模的扩大，应届生的数量也逐渐增长。然而，从学校刚进入公司的我们，难免会有多多少少的不适应。我们如何能尽快的适应职场环境和更好的成长了？上个星期，公司特与智联教育学院合作，为我们制定了为期5天的培训课程，取得了非常好的效果。</p>\n<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a><strong>结论</strong></h4><p>在这5天的培训课程中，使我的认知、沟通和思考方式得以提升。</p>\n<h4 id=\"1-学校到职场的转变\"><a href=\"#1-学校到职场的转变\" class=\"headerlink\" title=\"1. 学校到职场的转变\"></a><strong>1. 学校到职场的转变</strong></h4><a id=\"more\"></a> \n<p><strong>1.1 个人与团队</strong></p>\n<p>在学校更多的是以个体为单位，我们以自我为中心去上课，心情不好就直接翘课，没有约束。在公司更多是以团队为单位，自己的服务的客户会影响整个团队的绩效，自己写的代码会影响整个团队的开发效率。<strong>自己做的事情将不再再仅仅影响个人，还会影响整个团队</strong>。同时，个人积极的作用会带动起整个团队，反之，则会拖团队的后退。</p>\n<p><strong>1.2 兴趣与职业</strong></p>\n<p>学生的生活更多是凭借自己的兴趣与情绪，我们往往会对自己感兴趣的课程认真听讲，而对无聊乏味的课程则在下面玩手机。但是在公司，我们从事相应的职业，是为他人服务，形成绩效。这是我们职责所在而不在是凭借兴趣，并且<strong>我们应当从追求快乐转变为追求责任</strong>。</p>\n<p><strong>1.3 思维与行动</strong></p>\n<p>学生的思维都很活跃，新点子层出不穷。学校中学习知识，往往是以训练思维为主，注重的是成绩。而在公司，是需要将我们的思维转换为产品，将知识转为绩效，注重的是可行性和商业价值。</p>\n<p><strong>1.4 性格自知</strong></p>\n<p>通过性格色彩测试，了解自己，改变自己。人生嘛，本就是一场提升心智的旅程。</p>\n<h4 id=\"2-时间管理\"><a href=\"#2-时间管理\" class=\"headerlink\" title=\"2.时间管理\"></a><strong>2.时间管理</strong></h4><p><strong>2.1 重要紧急理论</strong></p>\n<p>​    我们生活中所碰到的事情可以分为以下四类：</p>\n<p>​    重要且紧急—立刻亲自处理</p>\n<p>​    重要但不紧急（这一点最重要）—计划性处理</p>\n<p>​    紧急但不重要—授权委任</p>\n<p>​    不重要且不紧急—当作没看见</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1fxv0xopdelj20iq0estfl.jpg\" alt></p>\n<p><strong>2.2 为什么重要但不紧急的事是最需要关注的了？</strong></p>\n<p>我们在生活中会遇到这种场景，每天都很忙碌。但忙完一阵子会发现，自己都不知道在忙什么了，然后心里有时候会安慰自己：反正我没有在玩，我在忙就行了。静下心来就会觉得我们是在沉溺于这种虚幻的充实满足感，做事时依靠的是自己的偏好和外界压力。根据重要紧急理论分析，这种情况就是一直在做重要且紧急的事情和紧急但不重要的事情。为了解除这种困境，对于重要且紧急的事情尽量减少，重要但不紧急的是通过列清单（To do list）来解决。重要但不紧急的事情则要规划好，有了规划，就知道了自己昨天完成了什么，今天在做什么，明天要干什么。每完成规划中的一个阶段，都可以明确知道，还可以知道距离多久能完成这个规划。其本质就是<strong>让规划的事情可视化</strong>。</p>\n<h4 id=\"3-目标管理\"><a href=\"#3-目标管理\" class=\"headerlink\" title=\"3.目标管理\"></a><strong>3.目标管理</strong></h4><p><strong>3.1目标分析法</strong></p>\n<p>说到目标也是说白了也是要规划，要<strong>对目标有全局的考虑</strong>。最常见的误区是碰到一件事时拿起来就干；订下目标后，一来就开始朝着目标前进。可以根据鱼骨分析法按照先整体后细节对目标进行分解，根据SMART原则制定出具体的（Specific），可测量的（Measurable ），可达到的（Attainable），相关的（Relevant），有时间的（Time based ）的目标。当目标产生冲突时，根据目标矩阵发来选择最优解。通过上述3种方法，这样会清楚的知道自己要按照怎样的流程来朝着目标前进。</p>\n<p><strong>3.2 三个Flag</strong></p>\n<p>​    a.四周时间看完剩下的《SpringBoot微信点餐系统》</p>\n<p>​    b.每天中午休息时间看5分钟的书</p>\n<p>​    c.每天10个深蹲</p>\n<h4 id=\"4-结构性思维\"><a href=\"#4-结构性思维\" class=\"headerlink\" title=\"4.结构性思维\"></a><strong>4.结构性思维</strong></h4><p>有时候我说话会了一堆，可是很多人还是不明白。其背后的主要原因是自己没有想清楚，就开口说了，想到哪里就说到哪里。结构性思维会是很好的解决方法。结构性思维是采用的总分形式，其结构就像高中的议论文一样。先进行背景介绍（即序言）提出主要观点，然后对其展开并进行论证。在与他人沟通时，会<strong>想的清楚，说的明白</strong>。让听者也会清楚的知道你想表达的意思。</p>\n<h4 id=\"5-高品质沟通\"><a href=\"#5-高品质沟通\" class=\"headerlink\" title=\"5.高品质沟通\"></a><strong>5.高品质沟通</strong></h4><p>每个人来自不同的地方，成长于不同的环境。当然两人会对一件事情会有不同的看法。当双方都怀着：你听我的，你听我的！这种心态来沟通，想必双方彼此都不能了解对方的想法，甚至可能会导致不愉快的事情出现。如果将”你听我的“转换成”<strong>我知道了你的观点，我的观点</strong>“，同时想一下对方所说的话其原因是什么？最终彼此都会很好的知道了对方的想法。</p>\n<h4 id=\"6-心态管理\"><a href=\"#6-心态管理\" class=\"headerlink\" title=\"6.心态管理\"></a>6.心态管理</h4><p><strong>6.1 心态的三驾马车</strong></p>\n<p>我们平常所说的<strong>心态，其具体表现形式是认知，情感，行为</strong>。这三者相辅相存，互相影响。例如：当做一件事情时，我们觉得很无聊，接着就会想到这件事没有意义，最终结果就是不去做这件事情。我们再细想一下这个情景：如果当感到无聊的时，我们想到的是做这件事情可以磨砺我们，使我们成长，其最终结果是我们把这件事做完。</p>\n<p>同样的事情，认知的不同产生了不同的结果。这让我想到ABC理论。</p>\n<p><strong>6.2 情绪ABC理论</strong> </p>\n<p><img src=\"http://s3.sinaimg.cn/mw690/86499eb1ge0f71c009592&amp;690\" alt=\"http://s3.sinaimg.cn/mw690/86499eb1ge0f71c009592&amp;690\"></p>\n<p>情绪ABC理论框架：A（Antecedent）指事情的前因，C（Consequence）指事情的后果，有前因必有后果，但是有同样的前因A，产生了不一样的后果C1和C2。这是因为从前因到后果之间，一定会透过一座桥梁B（Bridge），这座桥梁就是认知和我们对情境的评价与解释。又因为，同一情境之下（A），不同的人的认知以及评价与解释不同（B1和B2），所以会得到不同结果（C1和C2）。</p>\n<p>因此，事情发生的一切根源缘于我们的认知(认知是指人们对事件的想法，解释和评价等）。<strong>事物的本身并不影响人，人们只受对事物看法的影响。</strong></p>\n<p>听了这么多道理，<strong>好好去做才是正道</strong>。成功不必在我，而功力必不唐捐。</p>\n<h4 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h4><p>​        1. <a href=\"https://wenku.baidu.com/view/028ca126376baf1ffc4fad5a.html\" target=\"_blank\" rel=\"noopener\">从学校到职场的转变</a></p>\n<p>​        2. <a href=\"https://www.zhihu.com/question/20247508/answer/41385012\" target=\"_blank\" rel=\"noopener\">为什么时间管理上讲优先做的事情是最重要但不紧急的事情？By黛西瓜</a></p>\n<p>​        3. <a href=\"https://zhuanlan.zhihu.com/p/38532813\" target=\"_blank\" rel=\"noopener\">湖畔大学梁宁将情绪ABC理论神谕为“人的底层操作系统”，比能力强大100倍！By水伯</a></p>\n<p>​        4. <a href=\"https://zhuanlan.zhihu.com/p/22035979\" target=\"_blank\" rel=\"noopener\">结构性思维 By浩翊</a></p>\n<p>​        5. <a href=\"https://www.douban.com/note/86761045/\" target=\"_blank\" rel=\"noopener\">赠与今年的大学毕业生(1932年6月27日) By胡适</a></p>\n","site":{"data":{}},"excerpt":"<p>说明：文章是基于结构性思维写出的，下图将文章进行高度概括，详细内容可见全文（选择性阅读即可）。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1at98fsj21dy096dga.jpg\" alt></p>\n<h4 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a><strong>序言</strong></h4><p>随着公司的规模的扩大，应届生的数量也逐渐增长。然而，从学校刚进入公司的我们，难免会有多多少少的不适应。我们如何能尽快的适应职场环境和更好的成长了？上个星期，公司特与智联教育学院合作，为我们制定了为期5天的培训课程，取得了非常好的效果。</p>\n<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a><strong>结论</strong></h4><p>在这5天的培训课程中，使我的认知、沟通和思考方式得以提升。</p>\n<h4 id=\"1-学校到职场的转变\"><a href=\"#1-学校到职场的转变\" class=\"headerlink\" title=\"1. 学校到职场的转变\"></a><strong>1. 学校到职场的转变</strong></h4>","more":"<p><strong>1.1 个人与团队</strong></p>\n<p>在学校更多的是以个体为单位，我们以自我为中心去上课，心情不好就直接翘课，没有约束。在公司更多是以团队为单位，自己的服务的客户会影响整个团队的绩效，自己写的代码会影响整个团队的开发效率。<strong>自己做的事情将不再再仅仅影响个人，还会影响整个团队</strong>。同时，个人积极的作用会带动起整个团队，反之，则会拖团队的后退。</p>\n<p><strong>1.2 兴趣与职业</strong></p>\n<p>学生的生活更多是凭借自己的兴趣与情绪，我们往往会对自己感兴趣的课程认真听讲，而对无聊乏味的课程则在下面玩手机。但是在公司，我们从事相应的职业，是为他人服务，形成绩效。这是我们职责所在而不在是凭借兴趣，并且<strong>我们应当从追求快乐转变为追求责任</strong>。</p>\n<p><strong>1.3 思维与行动</strong></p>\n<p>学生的思维都很活跃，新点子层出不穷。学校中学习知识，往往是以训练思维为主，注重的是成绩。而在公司，是需要将我们的思维转换为产品，将知识转为绩效，注重的是可行性和商业价值。</p>\n<p><strong>1.4 性格自知</strong></p>\n<p>通过性格色彩测试，了解自己，改变自己。人生嘛，本就是一场提升心智的旅程。</p>\n<h4 id=\"2-时间管理\"><a href=\"#2-时间管理\" class=\"headerlink\" title=\"2.时间管理\"></a><strong>2.时间管理</strong></h4><p><strong>2.1 重要紧急理论</strong></p>\n<p>​    我们生活中所碰到的事情可以分为以下四类：</p>\n<p>​    重要且紧急—立刻亲自处理</p>\n<p>​    重要但不紧急（这一点最重要）—计划性处理</p>\n<p>​    紧急但不重要—授权委任</p>\n<p>​    不重要且不紧急—当作没看见</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1fxv0xopdelj20iq0estfl.jpg\" alt></p>\n<p><strong>2.2 为什么重要但不紧急的事是最需要关注的了？</strong></p>\n<p>我们在生活中会遇到这种场景，每天都很忙碌。但忙完一阵子会发现，自己都不知道在忙什么了，然后心里有时候会安慰自己：反正我没有在玩，我在忙就行了。静下心来就会觉得我们是在沉溺于这种虚幻的充实满足感，做事时依靠的是自己的偏好和外界压力。根据重要紧急理论分析，这种情况就是一直在做重要且紧急的事情和紧急但不重要的事情。为了解除这种困境，对于重要且紧急的事情尽量减少，重要但不紧急的是通过列清单（To do list）来解决。重要但不紧急的事情则要规划好，有了规划，就知道了自己昨天完成了什么，今天在做什么，明天要干什么。每完成规划中的一个阶段，都可以明确知道，还可以知道距离多久能完成这个规划。其本质就是<strong>让规划的事情可视化</strong>。</p>\n<h4 id=\"3-目标管理\"><a href=\"#3-目标管理\" class=\"headerlink\" title=\"3.目标管理\"></a><strong>3.目标管理</strong></h4><p><strong>3.1目标分析法</strong></p>\n<p>说到目标也是说白了也是要规划，要<strong>对目标有全局的考虑</strong>。最常见的误区是碰到一件事时拿起来就干；订下目标后，一来就开始朝着目标前进。可以根据鱼骨分析法按照先整体后细节对目标进行分解，根据SMART原则制定出具体的（Specific），可测量的（Measurable ），可达到的（Attainable），相关的（Relevant），有时间的（Time based ）的目标。当目标产生冲突时，根据目标矩阵发来选择最优解。通过上述3种方法，这样会清楚的知道自己要按照怎样的流程来朝着目标前进。</p>\n<p><strong>3.2 三个Flag</strong></p>\n<p>​    a.四周时间看完剩下的《SpringBoot微信点餐系统》</p>\n<p>​    b.每天中午休息时间看5分钟的书</p>\n<p>​    c.每天10个深蹲</p>\n<h4 id=\"4-结构性思维\"><a href=\"#4-结构性思维\" class=\"headerlink\" title=\"4.结构性思维\"></a><strong>4.结构性思维</strong></h4><p>有时候我说话会了一堆，可是很多人还是不明白。其背后的主要原因是自己没有想清楚，就开口说了，想到哪里就说到哪里。结构性思维会是很好的解决方法。结构性思维是采用的总分形式，其结构就像高中的议论文一样。先进行背景介绍（即序言）提出主要观点，然后对其展开并进行论证。在与他人沟通时，会<strong>想的清楚，说的明白</strong>。让听者也会清楚的知道你想表达的意思。</p>\n<h4 id=\"5-高品质沟通\"><a href=\"#5-高品质沟通\" class=\"headerlink\" title=\"5.高品质沟通\"></a><strong>5.高品质沟通</strong></h4><p>每个人来自不同的地方，成长于不同的环境。当然两人会对一件事情会有不同的看法。当双方都怀着：你听我的，你听我的！这种心态来沟通，想必双方彼此都不能了解对方的想法，甚至可能会导致不愉快的事情出现。如果将”你听我的“转换成”<strong>我知道了你的观点，我的观点</strong>“，同时想一下对方所说的话其原因是什么？最终彼此都会很好的知道了对方的想法。</p>\n<h4 id=\"6-心态管理\"><a href=\"#6-心态管理\" class=\"headerlink\" title=\"6.心态管理\"></a>6.心态管理</h4><p><strong>6.1 心态的三驾马车</strong></p>\n<p>我们平常所说的<strong>心态，其具体表现形式是认知，情感，行为</strong>。这三者相辅相存，互相影响。例如：当做一件事情时，我们觉得很无聊，接着就会想到这件事没有意义，最终结果就是不去做这件事情。我们再细想一下这个情景：如果当感到无聊的时，我们想到的是做这件事情可以磨砺我们，使我们成长，其最终结果是我们把这件事做完。</p>\n<p>同样的事情，认知的不同产生了不同的结果。这让我想到ABC理论。</p>\n<p><strong>6.2 情绪ABC理论</strong> </p>\n<p><img src=\"http://s3.sinaimg.cn/mw690/86499eb1ge0f71c009592&amp;690\" alt=\"http://s3.sinaimg.cn/mw690/86499eb1ge0f71c009592&amp;690\"></p>\n<p>情绪ABC理论框架：A（Antecedent）指事情的前因，C（Consequence）指事情的后果，有前因必有后果，但是有同样的前因A，产生了不一样的后果C1和C2。这是因为从前因到后果之间，一定会透过一座桥梁B（Bridge），这座桥梁就是认知和我们对情境的评价与解释。又因为，同一情境之下（A），不同的人的认知以及评价与解释不同（B1和B2），所以会得到不同结果（C1和C2）。</p>\n<p>因此，事情发生的一切根源缘于我们的认知(认知是指人们对事件的想法，解释和评价等）。<strong>事物的本身并不影响人，人们只受对事物看法的影响。</strong></p>\n<p>听了这么多道理，<strong>好好去做才是正道</strong>。成功不必在我，而功力必不唐捐。</p>\n<h4 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h4><p>​        1. <a href=\"https://wenku.baidu.com/view/028ca126376baf1ffc4fad5a.html\" target=\"_blank\" rel=\"noopener\">从学校到职场的转变</a></p>\n<p>​        2. <a href=\"https://www.zhihu.com/question/20247508/answer/41385012\" target=\"_blank\" rel=\"noopener\">为什么时间管理上讲优先做的事情是最重要但不紧急的事情？By黛西瓜</a></p>\n<p>​        3. <a href=\"https://zhuanlan.zhihu.com/p/38532813\" target=\"_blank\" rel=\"noopener\">湖畔大学梁宁将情绪ABC理论神谕为“人的底层操作系统”，比能力强大100倍！By水伯</a></p>\n<p>​        4. <a href=\"https://zhuanlan.zhihu.com/p/22035979\" target=\"_blank\" rel=\"noopener\">结构性思维 By浩翊</a></p>\n<p>​        5. <a href=\"https://www.douban.com/note/86761045/\" target=\"_blank\" rel=\"noopener\">赠与今年的大学毕业生(1932年6月27日) By胡适</a></p>"},{"layout":"post","title":"计算机网络面试题","date":"2017-09-08T13:58:00.000Z","comments":1,"_content":"\n### 1.OSI和TCP/IP的体系结构，以及各层协议\n\nOSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。\nTCP/IP分层（4层）：数据链路层、 传输层、网络层、 应用层。\n\n分层的好处：\n\n- 各层之间的接口部分规划好之后，每个层次内部的设计就能自由改动了。\n- 设计变得相对简单，每一层只考虑自己的分配任务。\n\n<!--more--> \n\n每一层的协议如下：\n物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）\n数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）\n网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）\n传输层：TCP、UDP、SPX\n会话层：NFS、SQL、NETBIOS、RPC\n表示层：JPEG、MPEG、ASII\n应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS\n每一层的作用如下：\n物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）\n数据链路层：将比特组装成帧和点到点的传递（帧Frame）\n网络层：负责数据包从源到宿的传递和网际互连（包PackeT）\n传输层：提供端到端的可靠报文传递和错误恢复（段Segment）\n会话层：建立、管理和终止会话（会话协议数据单元SPDU）\n表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）\n应用层：允许访问OSI环境的手段（应用协议数据单元APDU）\n\n### 2.TCP的三次握手与四次分手\n\n#### 摘自于http://www.jellythink.com/archives/705\n\n#### 三次握手是什么？\n\nTCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。这就是面试中经常会被问到的**TCP三次握手**。只是了解TCP三次握手的概念，对你获得一份工作是没有任何帮助的，你需要去了解TCP三次握手中的一些细节。先来看图说话。\n\n![三次握手.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gce7qfxhnzj20lt0c2jyk.jpg)\n\n多么清晰的一张图，当然了，也不是我画的，我也只是引用过来说明问题了。\n\n1. 第一次握手：建立连接。客户端发送连接请求报文段，将`SYN`位置为1，`Sequence Number`为x；然后，客户端进入`SYN_SEND`状态，等待服务器的确认；\n2. 第二次握手：服务器收到`SYN`报文段。服务器收到客户端的`SYN`报文段，需要对这个`SYN`报文段进行确 认，设置`Acknowledgment Number`为x+1(`Sequence Number`+1)；同时，自己自己还要发送`SYN`请求信息，将`SYN`位置为1，`Sequence Number`为y；服务器端将上述所有信息放到一个报文段（即`SYN+ACK`报文段）中，一并发送给客户端，此时服务器进入`SYN_RECV`状态；\n3. 第三次握手：客户端收到服务器的`SYN+ACK`报文段。然后将`Acknowledgment Number`设置为y+1，向服务器发送`ACK`报文段，这个报文段发送完毕以后，客户端和服务器端都进入`ESTABLISHED`状态，完成TCP三次握手。\n\n![三次握手-.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gdajkp4qdxj21hc0t4why.jpg)\n\n完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。\n\n**为了加深理解，举个例子。**\n\n**A和B之间建立了TCP连接，A向B发送报文段，其中序号字段seq=300，确认号字段ACK =101，数据部分包含7个字节，那么在B对该报文的确认报文段中（）。**\n\n**A. seq=301, ACK=101  B. seq=301, ACK=108  C.seq=101, ACK =107  D .seq=101, ACK= 307**\n\n**解析：**\n\nA向B发送报文段，其中序号字段seq=300，确认号字段ACK =101。\n\nA对B说：“我已经收到你第100个序列号了，下个序列号要从101开始。我现在给你要以300序列号开始，给7个字节数据。“\n\nB这时应该对A说：”好的，我这就给你发送101的序列号，我这里收到了以300为起点，306为终点的数据了，我现在要307序列号了。“\n\n所以B对该报文的确认报文段中 seq=101, ACK= 307. 选D.\n\n#### 那四次分手呢？\n\n当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。\n\n![四次挥手.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gce9y14bkgj20uy0i9n5x.jpg)\n\n1. 第一次分手：主机1（可以使客户端，也可以是服务器端），设置`Sequence Number`和`Acknowledgment Number`，向主机2发送一个`FIN`报文段；此时，主机1进入`FIN_WAIT_1`状态；这表示主机1没有数据要发送给主机2了；\n2. 第二次分手：主机2收到了主机1发送的`FIN`报文段，向主机1回一个`ACK`报文段，`Acknowledgment Number`为`Sequence Number`加1；主机1进入`FIN_WAIT_2`状态；主机2告诉主机1，我“同意”你的关闭请求；\n3. 第三次分手：主机2向主机1发送`FIN`报文段，请求关闭连接，同时主机2进入`LAST_ACK`状态；\n4. 第四次分手：主机1收到主机2发送的`FIN`报文段，向主机2发送`ACK`报文段，然后主机1进入`TIME_WAIT`状态；主机2收到主机1的`ACK`报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。\n\n![四次挥手-抓包.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gdajm38dtdj21hc0t4gpa.jpg)\n\n**等待2MSL才CLOSED的原因是：**\n\n- 要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。\n- 使已失效的连接请求报文段消失。\n\n**为什么连接的时候是三次握手，关闭的时候却是四次握手？**\n\n因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，\"你发的FIN报文我收到了\"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。\n\n### 3.子网划分\n\n#### 现有两个 C 类网，202.203.204.0 ，把它平均分成 4 个子网，写出每个子网的起始、终结 IP 和子网掩码。\n\n202.203.204.0 分成4 个平均的子网，这是个C类的网络 ，平均分成4个的话，也就是每个子网有64台机器。\n\n2的2次方=4 ，所以需要借2个主机位表示 网络 ，等于是26位的子网掩码.\n\n子网掩码: 202.203.204.192\n\n子网号 **00** 202.203.204.1 ~ 202.203.204.63\n\n子网号 **01** 202.203.204.64 ~ 202.203.204.127\n\n子网号 **10** 202.203.204.128 ~ 202.203.204.191\n\n子网号 **11** 202.203.204.192 ~ 202.203.204.254\n","source":"_posts/计算机网络面试题.md","raw":"---\nlayout: post\ntitle: \"计算机网络面试题\"\ndate: 2017-9-8 21:58\ncomments: true\ntags: \n\t- 计算机网络\n---\n\n### 1.OSI和TCP/IP的体系结构，以及各层协议\n\nOSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。\nTCP/IP分层（4层）：数据链路层、 传输层、网络层、 应用层。\n\n分层的好处：\n\n- 各层之间的接口部分规划好之后，每个层次内部的设计就能自由改动了。\n- 设计变得相对简单，每一层只考虑自己的分配任务。\n\n<!--more--> \n\n每一层的协议如下：\n物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）\n数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）\n网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）\n传输层：TCP、UDP、SPX\n会话层：NFS、SQL、NETBIOS、RPC\n表示层：JPEG、MPEG、ASII\n应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS\n每一层的作用如下：\n物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）\n数据链路层：将比特组装成帧和点到点的传递（帧Frame）\n网络层：负责数据包从源到宿的传递和网际互连（包PackeT）\n传输层：提供端到端的可靠报文传递和错误恢复（段Segment）\n会话层：建立、管理和终止会话（会话协议数据单元SPDU）\n表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）\n应用层：允许访问OSI环境的手段（应用协议数据单元APDU）\n\n### 2.TCP的三次握手与四次分手\n\n#### 摘自于http://www.jellythink.com/archives/705\n\n#### 三次握手是什么？\n\nTCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。这就是面试中经常会被问到的**TCP三次握手**。只是了解TCP三次握手的概念，对你获得一份工作是没有任何帮助的，你需要去了解TCP三次握手中的一些细节。先来看图说话。\n\n![三次握手.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gce7qfxhnzj20lt0c2jyk.jpg)\n\n多么清晰的一张图，当然了，也不是我画的，我也只是引用过来说明问题了。\n\n1. 第一次握手：建立连接。客户端发送连接请求报文段，将`SYN`位置为1，`Sequence Number`为x；然后，客户端进入`SYN_SEND`状态，等待服务器的确认；\n2. 第二次握手：服务器收到`SYN`报文段。服务器收到客户端的`SYN`报文段，需要对这个`SYN`报文段进行确 认，设置`Acknowledgment Number`为x+1(`Sequence Number`+1)；同时，自己自己还要发送`SYN`请求信息，将`SYN`位置为1，`Sequence Number`为y；服务器端将上述所有信息放到一个报文段（即`SYN+ACK`报文段）中，一并发送给客户端，此时服务器进入`SYN_RECV`状态；\n3. 第三次握手：客户端收到服务器的`SYN+ACK`报文段。然后将`Acknowledgment Number`设置为y+1，向服务器发送`ACK`报文段，这个报文段发送完毕以后，客户端和服务器端都进入`ESTABLISHED`状态，完成TCP三次握手。\n\n![三次握手-.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gdajkp4qdxj21hc0t4why.jpg)\n\n完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。\n\n**为了加深理解，举个例子。**\n\n**A和B之间建立了TCP连接，A向B发送报文段，其中序号字段seq=300，确认号字段ACK =101，数据部分包含7个字节，那么在B对该报文的确认报文段中（）。**\n\n**A. seq=301, ACK=101  B. seq=301, ACK=108  C.seq=101, ACK =107  D .seq=101, ACK= 307**\n\n**解析：**\n\nA向B发送报文段，其中序号字段seq=300，确认号字段ACK =101。\n\nA对B说：“我已经收到你第100个序列号了，下个序列号要从101开始。我现在给你要以300序列号开始，给7个字节数据。“\n\nB这时应该对A说：”好的，我这就给你发送101的序列号，我这里收到了以300为起点，306为终点的数据了，我现在要307序列号了。“\n\n所以B对该报文的确认报文段中 seq=101, ACK= 307. 选D.\n\n#### 那四次分手呢？\n\n当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。\n\n![四次挥手.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gce9y14bkgj20uy0i9n5x.jpg)\n\n1. 第一次分手：主机1（可以使客户端，也可以是服务器端），设置`Sequence Number`和`Acknowledgment Number`，向主机2发送一个`FIN`报文段；此时，主机1进入`FIN_WAIT_1`状态；这表示主机1没有数据要发送给主机2了；\n2. 第二次分手：主机2收到了主机1发送的`FIN`报文段，向主机1回一个`ACK`报文段，`Acknowledgment Number`为`Sequence Number`加1；主机1进入`FIN_WAIT_2`状态；主机2告诉主机1，我“同意”你的关闭请求；\n3. 第三次分手：主机2向主机1发送`FIN`报文段，请求关闭连接，同时主机2进入`LAST_ACK`状态；\n4. 第四次分手：主机1收到主机2发送的`FIN`报文段，向主机2发送`ACK`报文段，然后主机1进入`TIME_WAIT`状态；主机2收到主机1的`ACK`报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。\n\n![四次挥手-抓包.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gdajm38dtdj21hc0t4gpa.jpg)\n\n**等待2MSL才CLOSED的原因是：**\n\n- 要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。\n- 使已失效的连接请求报文段消失。\n\n**为什么连接的时候是三次握手，关闭的时候却是四次握手？**\n\n因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，\"你发的FIN报文我收到了\"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。\n\n### 3.子网划分\n\n#### 现有两个 C 类网，202.203.204.0 ，把它平均分成 4 个子网，写出每个子网的起始、终结 IP 和子网掩码。\n\n202.203.204.0 分成4 个平均的子网，这是个C类的网络 ，平均分成4个的话，也就是每个子网有64台机器。\n\n2的2次方=4 ，所以需要借2个主机位表示 网络 ，等于是26位的子网掩码.\n\n子网掩码: 202.203.204.192\n\n子网号 **00** 202.203.204.1 ~ 202.203.204.63\n\n子网号 **01** 202.203.204.64 ~ 202.203.204.127\n\n子网号 **10** 202.203.204.128 ~ 202.203.204.191\n\n子网号 **11** 202.203.204.192 ~ 202.203.204.254\n","slug":"计算机网络面试题","published":1,"updated":"2020-08-09T05:24:13.301Z","photos":[],"link":"","_id":"ckdmsedzz0016lguw75lzq7gg","content":"<h3 id=\"1-OSI和TCP-IP的体系结构，以及各层协议\"><a href=\"#1-OSI和TCP-IP的体系结构，以及各层协议\" class=\"headerlink\" title=\"1.OSI和TCP/IP的体系结构，以及各层协议\"></a>1.OSI和TCP/IP的体系结构，以及各层协议</h3><p>OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br>TCP/IP分层（4层）：数据链路层、 传输层、网络层、 应用层。</p>\n<p>分层的好处：</p>\n<ul>\n<li>各层之间的接口部分规划好之后，每个层次内部的设计就能自由改动了。</li>\n<li>设计变得相对简单，每一层只考虑自己的分配任务。</li>\n</ul>\n<a id=\"more\"></a> \n<p>每一层的协议如下：<br>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）<br>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）<br>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）<br>传输层：TCP、UDP、SPX<br>会话层：NFS、SQL、NETBIOS、RPC<br>表示层：JPEG、MPEG、ASII<br>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS<br>每一层的作用如下：<br>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）<br>数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br>会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）<br>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p>\n<h3 id=\"2-TCP的三次握手与四次分手\"><a href=\"#2-TCP的三次握手与四次分手\" class=\"headerlink\" title=\"2.TCP的三次握手与四次分手\"></a>2.TCP的三次握手与四次分手</h3><h4 id=\"摘自于http-www-jellythink-com-archives-705\"><a href=\"#摘自于http-www-jellythink-com-archives-705\" class=\"headerlink\" title=\"摘自于http://www.jellythink.com/archives/705\"></a>摘自于<a href=\"http://www.jellythink.com/archives/705\" target=\"_blank\" rel=\"noopener\">http://www.jellythink.com/archives/705</a></h4><h4 id=\"三次握手是什么？\"><a href=\"#三次握手是什么？\" class=\"headerlink\" title=\"三次握手是什么？\"></a>三次握手是什么？</h4><p>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。这就是面试中经常会被问到的<strong>TCP三次握手</strong>。只是了解TCP三次握手的概念，对你获得一份工作是没有任何帮助的，你需要去了解TCP三次握手中的一些细节。先来看图说话。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gce7qfxhnzj20lt0c2jyk.jpg\" alt=\"三次握手.png\"></p>\n<p>多么清晰的一张图，当然了，也不是我画的，我也只是引用过来说明问题了。</p>\n<ol>\n<li>第一次握手：建立连接。客户端发送连接请求报文段，将<code>SYN</code>位置为1，<code>Sequence Number</code>为x；然后，客户端进入<code>SYN_SEND</code>状态，等待服务器的确认；</li>\n<li>第二次握手：服务器收到<code>SYN</code>报文段。服务器收到客户端的<code>SYN</code>报文段，需要对这个<code>SYN</code>报文段进行确 认，设置<code>Acknowledgment Number</code>为x+1(<code>Sequence Number</code>+1)；同时，自己自己还要发送<code>SYN</code>请求信息，将<code>SYN</code>位置为1，<code>Sequence Number</code>为y；服务器端将上述所有信息放到一个报文段（即<code>SYN+ACK</code>报文段）中，一并发送给客户端，此时服务器进入<code>SYN_RECV</code>状态；</li>\n<li>第三次握手：客户端收到服务器的<code>SYN+ACK</code>报文段。然后将<code>Acknowledgment Number</code>设置为y+1，向服务器发送<code>ACK</code>报文段，这个报文段发送完毕以后，客户端和服务器端都进入<code>ESTABLISHED</code>状态，完成TCP三次握手。</li>\n</ol>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gdajkp4qdxj21hc0t4why.jpg\" alt=\"三次握手-.png\"></p>\n<p>完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。</p>\n<p><strong>为了加深理解，举个例子。</strong></p>\n<p><strong>A和B之间建立了TCP连接，A向B发送报文段，其中序号字段seq=300，确认号字段ACK =101，数据部分包含7个字节，那么在B对该报文的确认报文段中（）。</strong></p>\n<p><strong>A. seq=301, ACK=101  B. seq=301, ACK=108  C.seq=101, ACK =107  D .seq=101, ACK= 307</strong></p>\n<p><strong>解析：</strong></p>\n<p>A向B发送报文段，其中序号字段seq=300，确认号字段ACK =101。</p>\n<p>A对B说：“我已经收到你第100个序列号了，下个序列号要从101开始。我现在给你要以300序列号开始，给7个字节数据。“</p>\n<p>B这时应该对A说：”好的，我这就给你发送101的序列号，我这里收到了以300为起点，306为终点的数据了，我现在要307序列号了。“</p>\n<p>所以B对该报文的确认报文段中 seq=101, ACK= 307. 选D.</p>\n<h4 id=\"那四次分手呢？\"><a href=\"#那四次分手呢？\" class=\"headerlink\" title=\"那四次分手呢？\"></a>那四次分手呢？</h4><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gce9y14bkgj20uy0i9n5x.jpg\" alt=\"四次挥手.png\"></p>\n<ol>\n<li>第一次分手：主机1（可以使客户端，也可以是服务器端），设置<code>Sequence Number</code>和<code>Acknowledgment Number</code>，向主机2发送一个<code>FIN</code>报文段；此时，主机1进入<code>FIN_WAIT_1</code>状态；这表示主机1没有数据要发送给主机2了；</li>\n<li>第二次分手：主机2收到了主机1发送的<code>FIN</code>报文段，向主机1回一个<code>ACK</code>报文段，<code>Acknowledgment Number</code>为<code>Sequence Number</code>加1；主机1进入<code>FIN_WAIT_2</code>状态；主机2告诉主机1，我“同意”你的关闭请求；</li>\n<li>第三次分手：主机2向主机1发送<code>FIN</code>报文段，请求关闭连接，同时主机2进入<code>LAST_ACK</code>状态；</li>\n<li>第四次分手：主机1收到主机2发送的<code>FIN</code>报文段，向主机2发送<code>ACK</code>报文段，然后主机1进入<code>TIME_WAIT</code>状态；主机2收到主机1的<code>ACK</code>报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</li>\n</ol>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gdajm38dtdj21hc0t4gpa.jpg\" alt=\"四次挥手-抓包.png\"></p>\n<p><strong>等待2MSL才CLOSED的原因是：</strong></p>\n<ul>\n<li>要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。</li>\n<li>使已失效的连接请求报文段消失。</li>\n</ul>\n<p><strong>为什么连接的时候是三次握手，关闭的时候却是四次握手？</strong></p>\n<p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>\n<h3 id=\"3-子网划分\"><a href=\"#3-子网划分\" class=\"headerlink\" title=\"3.子网划分\"></a>3.子网划分</h3><h4 id=\"现有两个-C-类网，202-203-204-0-，把它平均分成-4-个子网，写出每个子网的起始、终结-IP-和子网掩码。\"><a href=\"#现有两个-C-类网，202-203-204-0-，把它平均分成-4-个子网，写出每个子网的起始、终结-IP-和子网掩码。\" class=\"headerlink\" title=\"现有两个 C 类网，202.203.204.0 ，把它平均分成 4 个子网，写出每个子网的起始、终结 IP 和子网掩码。\"></a>现有两个 C 类网，202.203.204.0 ，把它平均分成 4 个子网，写出每个子网的起始、终结 IP 和子网掩码。</h4><p>202.203.204.0 分成4 个平均的子网，这是个C类的网络 ，平均分成4个的话，也就是每个子网有64台机器。</p>\n<p>2的2次方=4 ，所以需要借2个主机位表示 网络 ，等于是26位的子网掩码.</p>\n<p>子网掩码: 202.203.204.192</p>\n<p>子网号 <strong>00</strong> 202.203.204.1 ~ 202.203.204.63</p>\n<p>子网号 <strong>01</strong> 202.203.204.64 ~ 202.203.204.127</p>\n<p>子网号 <strong>10</strong> 202.203.204.128 ~ 202.203.204.191</p>\n<p>子网号 <strong>11</strong> 202.203.204.192 ~ 202.203.204.254</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-OSI和TCP-IP的体系结构，以及各层协议\"><a href=\"#1-OSI和TCP-IP的体系结构，以及各层协议\" class=\"headerlink\" title=\"1.OSI和TCP/IP的体系结构，以及各层协议\"></a>1.OSI和TCP/IP的体系结构，以及各层协议</h3><p>OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br>TCP/IP分层（4层）：数据链路层、 传输层、网络层、 应用层。</p>\n<p>分层的好处：</p>\n<ul>\n<li>各层之间的接口部分规划好之后，每个层次内部的设计就能自由改动了。</li>\n<li>设计变得相对简单，每一层只考虑自己的分配任务。</li>\n</ul>","more":"<p>每一层的协议如下：<br>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）<br>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）<br>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）<br>传输层：TCP、UDP、SPX<br>会话层：NFS、SQL、NETBIOS、RPC<br>表示层：JPEG、MPEG、ASII<br>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS<br>每一层的作用如下：<br>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）<br>数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br>会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）<br>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p>\n<h3 id=\"2-TCP的三次握手与四次分手\"><a href=\"#2-TCP的三次握手与四次分手\" class=\"headerlink\" title=\"2.TCP的三次握手与四次分手\"></a>2.TCP的三次握手与四次分手</h3><h4 id=\"摘自于http-www-jellythink-com-archives-705\"><a href=\"#摘自于http-www-jellythink-com-archives-705\" class=\"headerlink\" title=\"摘自于http://www.jellythink.com/archives/705\"></a>摘自于<a href=\"http://www.jellythink.com/archives/705\" target=\"_blank\" rel=\"noopener\">http://www.jellythink.com/archives/705</a></h4><h4 id=\"三次握手是什么？\"><a href=\"#三次握手是什么？\" class=\"headerlink\" title=\"三次握手是什么？\"></a>三次握手是什么？</h4><p>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。这就是面试中经常会被问到的<strong>TCP三次握手</strong>。只是了解TCP三次握手的概念，对你获得一份工作是没有任何帮助的，你需要去了解TCP三次握手中的一些细节。先来看图说话。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gce7qfxhnzj20lt0c2jyk.jpg\" alt=\"三次握手.png\"></p>\n<p>多么清晰的一张图，当然了，也不是我画的，我也只是引用过来说明问题了。</p>\n<ol>\n<li>第一次握手：建立连接。客户端发送连接请求报文段，将<code>SYN</code>位置为1，<code>Sequence Number</code>为x；然后，客户端进入<code>SYN_SEND</code>状态，等待服务器的确认；</li>\n<li>第二次握手：服务器收到<code>SYN</code>报文段。服务器收到客户端的<code>SYN</code>报文段，需要对这个<code>SYN</code>报文段进行确 认，设置<code>Acknowledgment Number</code>为x+1(<code>Sequence Number</code>+1)；同时，自己自己还要发送<code>SYN</code>请求信息，将<code>SYN</code>位置为1，<code>Sequence Number</code>为y；服务器端将上述所有信息放到一个报文段（即<code>SYN+ACK</code>报文段）中，一并发送给客户端，此时服务器进入<code>SYN_RECV</code>状态；</li>\n<li>第三次握手：客户端收到服务器的<code>SYN+ACK</code>报文段。然后将<code>Acknowledgment Number</code>设置为y+1，向服务器发送<code>ACK</code>报文段，这个报文段发送完毕以后，客户端和服务器端都进入<code>ESTABLISHED</code>状态，完成TCP三次握手。</li>\n</ol>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gdajkp4qdxj21hc0t4why.jpg\" alt=\"三次握手-.png\"></p>\n<p>完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。</p>\n<p><strong>为了加深理解，举个例子。</strong></p>\n<p><strong>A和B之间建立了TCP连接，A向B发送报文段，其中序号字段seq=300，确认号字段ACK =101，数据部分包含7个字节，那么在B对该报文的确认报文段中（）。</strong></p>\n<p><strong>A. seq=301, ACK=101  B. seq=301, ACK=108  C.seq=101, ACK =107  D .seq=101, ACK= 307</strong></p>\n<p><strong>解析：</strong></p>\n<p>A向B发送报文段，其中序号字段seq=300，确认号字段ACK =101。</p>\n<p>A对B说：“我已经收到你第100个序列号了，下个序列号要从101开始。我现在给你要以300序列号开始，给7个字节数据。“</p>\n<p>B这时应该对A说：”好的，我这就给你发送101的序列号，我这里收到了以300为起点，306为终点的数据了，我现在要307序列号了。“</p>\n<p>所以B对该报文的确认报文段中 seq=101, ACK= 307. 选D.</p>\n<h4 id=\"那四次分手呢？\"><a href=\"#那四次分手呢？\" class=\"headerlink\" title=\"那四次分手呢？\"></a>那四次分手呢？</h4><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gce9y14bkgj20uy0i9n5x.jpg\" alt=\"四次挥手.png\"></p>\n<ol>\n<li>第一次分手：主机1（可以使客户端，也可以是服务器端），设置<code>Sequence Number</code>和<code>Acknowledgment Number</code>，向主机2发送一个<code>FIN</code>报文段；此时，主机1进入<code>FIN_WAIT_1</code>状态；这表示主机1没有数据要发送给主机2了；</li>\n<li>第二次分手：主机2收到了主机1发送的<code>FIN</code>报文段，向主机1回一个<code>ACK</code>报文段，<code>Acknowledgment Number</code>为<code>Sequence Number</code>加1；主机1进入<code>FIN_WAIT_2</code>状态；主机2告诉主机1，我“同意”你的关闭请求；</li>\n<li>第三次分手：主机2向主机1发送<code>FIN</code>报文段，请求关闭连接，同时主机2进入<code>LAST_ACK</code>状态；</li>\n<li>第四次分手：主机1收到主机2发送的<code>FIN</code>报文段，向主机2发送<code>ACK</code>报文段，然后主机1进入<code>TIME_WAIT</code>状态；主机2收到主机1的<code>ACK</code>报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</li>\n</ol>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gdajm38dtdj21hc0t4gpa.jpg\" alt=\"四次挥手-抓包.png\"></p>\n<p><strong>等待2MSL才CLOSED的原因是：</strong></p>\n<ul>\n<li>要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。</li>\n<li>使已失效的连接请求报文段消失。</li>\n</ul>\n<p><strong>为什么连接的时候是三次握手，关闭的时候却是四次握手？</strong></p>\n<p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>\n<h3 id=\"3-子网划分\"><a href=\"#3-子网划分\" class=\"headerlink\" title=\"3.子网划分\"></a>3.子网划分</h3><h4 id=\"现有两个-C-类网，202-203-204-0-，把它平均分成-4-个子网，写出每个子网的起始、终结-IP-和子网掩码。\"><a href=\"#现有两个-C-类网，202-203-204-0-，把它平均分成-4-个子网，写出每个子网的起始、终结-IP-和子网掩码。\" class=\"headerlink\" title=\"现有两个 C 类网，202.203.204.0 ，把它平均分成 4 个子网，写出每个子网的起始、终结 IP 和子网掩码。\"></a>现有两个 C 类网，202.203.204.0 ，把它平均分成 4 个子网，写出每个子网的起始、终结 IP 和子网掩码。</h4><p>202.203.204.0 分成4 个平均的子网，这是个C类的网络 ，平均分成4个的话，也就是每个子网有64台机器。</p>\n<p>2的2次方=4 ，所以需要借2个主机位表示 网络 ，等于是26位的子网掩码.</p>\n<p>子网掩码: 202.203.204.192</p>\n<p>子网号 <strong>00</strong> 202.203.204.1 ~ 202.203.204.63</p>\n<p>子网号 <strong>01</strong> 202.203.204.64 ~ 202.203.204.127</p>\n<p>子网号 <strong>10</strong> 202.203.204.128 ~ 202.203.204.191</p>\n<p>子网号 <strong>11</strong> 202.203.204.192 ~ 202.203.204.254</p>"},{"title":"财务分析和决策","date":"2020-02-24T14:13:12.000Z","_content":"一个企业所做的事情就是3件事情：经营，投资，融资。资产负债表，利润表，现金流量表这3大报表反映了一个企业的情况。\n\n现金流量表这个维度，这个维度它描述了这个企业的未来是不是能够持续经营。\n\n资产负债表和利润表，它们共同构成另一个维度，假设这个企业能够继续生存下去，那么它的状况会是什么样子的？\n\n### 1.资产负债表(Balance Sheet)\n\n![资产负债表.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gc6n9gabqsj20ic0mz78a.jpg)\n\n<!--more--> \n\n**资产与费用的区别** Difference between Asset & Cost\n花一笔钱出去，换来一个未来有用额东西，这就是资产，如果钱花完后什么都没有留下，那就是费用\n\n**净资产=股东权益=资产-负债**\n\n每股净资产 = 净资产/股本数\n\n市值 = 每股价格*股本数\n\n市净率（PB） = 市值/净资产 = 每股价格/每股净资产\n\n### 2.利润表 (Income Statement)\n\n![利润表.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gc6opfa0taj20nn0cewgf.jpg)\n\n每股利润 = 净利润/股本数。\n\n市盈率（PE）= 每股价格/每股利润。\n\n利润表两大作用\n\n- 现在公司赚多少钱\n- 形成对公司未来赢利预期的基础\n\n### 3.现金流量表(Cash Flow Statement)\n\n![现金流量表.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gc7u1izh6xj20vq0k0whf.jpg)\n\n现金流量表作用\n\n告诉我们现金增减变化如何发生的？（是经营活动？是融资活动？是投资活动？）\n\n### 4.总资产报酬率\n\n![总资产报酬率 (2).png](http://ww1.sinaimg.cn/large/aacc02d8gy1gca5xxj3jdj20jk0cxwf6.jpg)","source":"_posts/财务分析和决策.md","raw":"---\ntitle: 财务分析和决策\ndate: 2020-02-24 22:13:12\ntags:\n---\n一个企业所做的事情就是3件事情：经营，投资，融资。资产负债表，利润表，现金流量表这3大报表反映了一个企业的情况。\n\n现金流量表这个维度，这个维度它描述了这个企业的未来是不是能够持续经营。\n\n资产负债表和利润表，它们共同构成另一个维度，假设这个企业能够继续生存下去，那么它的状况会是什么样子的？\n\n### 1.资产负债表(Balance Sheet)\n\n![资产负债表.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gc6n9gabqsj20ic0mz78a.jpg)\n\n<!--more--> \n\n**资产与费用的区别** Difference between Asset & Cost\n花一笔钱出去，换来一个未来有用额东西，这就是资产，如果钱花完后什么都没有留下，那就是费用\n\n**净资产=股东权益=资产-负债**\n\n每股净资产 = 净资产/股本数\n\n市值 = 每股价格*股本数\n\n市净率（PB） = 市值/净资产 = 每股价格/每股净资产\n\n### 2.利润表 (Income Statement)\n\n![利润表.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gc6opfa0taj20nn0cewgf.jpg)\n\n每股利润 = 净利润/股本数。\n\n市盈率（PE）= 每股价格/每股利润。\n\n利润表两大作用\n\n- 现在公司赚多少钱\n- 形成对公司未来赢利预期的基础\n\n### 3.现金流量表(Cash Flow Statement)\n\n![现金流量表.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gc7u1izh6xj20vq0k0whf.jpg)\n\n现金流量表作用\n\n告诉我们现金增减变化如何发生的？（是经营活动？是融资活动？是投资活动？）\n\n### 4.总资产报酬率\n\n![总资产报酬率 (2).png](http://ww1.sinaimg.cn/large/aacc02d8gy1gca5xxj3jdj20jk0cxwf6.jpg)","slug":"财务分析和决策","published":1,"updated":"2020-08-09T05:24:13.303Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdmsee020019lguw1wy397xv","content":"<p>一个企业所做的事情就是3件事情：经营，投资，融资。资产负债表，利润表，现金流量表这3大报表反映了一个企业的情况。</p>\n<p>现金流量表这个维度，这个维度它描述了这个企业的未来是不是能够持续经营。</p>\n<p>资产负债表和利润表，它们共同构成另一个维度，假设这个企业能够继续生存下去，那么它的状况会是什么样子的？</p>\n<h3 id=\"1-资产负债表-Balance-Sheet\"><a href=\"#1-资产负债表-Balance-Sheet\" class=\"headerlink\" title=\"1.资产负债表(Balance Sheet)\"></a>1.资产负债表(Balance Sheet)</h3><p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gc6n9gabqsj20ic0mz78a.jpg\" alt=\"资产负债表.png\"></p>\n<a id=\"more\"></a> \n<p><strong>资产与费用的区别</strong> Difference between Asset &amp; Cost<br>花一笔钱出去，换来一个未来有用额东西，这就是资产，如果钱花完后什么都没有留下，那就是费用</p>\n<p><strong>净资产=股东权益=资产-负债</strong></p>\n<p>每股净资产 = 净资产/股本数</p>\n<p>市值 = 每股价格*股本数</p>\n<p>市净率（PB） = 市值/净资产 = 每股价格/每股净资产</p>\n<h3 id=\"2-利润表-Income-Statement\"><a href=\"#2-利润表-Income-Statement\" class=\"headerlink\" title=\"2.利润表 (Income Statement)\"></a>2.利润表 (Income Statement)</h3><p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gc6opfa0taj20nn0cewgf.jpg\" alt=\"利润表.png\"></p>\n<p>每股利润 = 净利润/股本数。</p>\n<p>市盈率（PE）= 每股价格/每股利润。</p>\n<p>利润表两大作用</p>\n<ul>\n<li>现在公司赚多少钱</li>\n<li>形成对公司未来赢利预期的基础</li>\n</ul>\n<h3 id=\"3-现金流量表-Cash-Flow-Statement\"><a href=\"#3-现金流量表-Cash-Flow-Statement\" class=\"headerlink\" title=\"3.现金流量表(Cash Flow Statement)\"></a>3.现金流量表(Cash Flow Statement)</h3><p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gc7u1izh6xj20vq0k0whf.jpg\" alt=\"现金流量表.png\"></p>\n<p>现金流量表作用</p>\n<p>告诉我们现金增减变化如何发生的？（是经营活动？是融资活动？是投资活动？）</p>\n<h3 id=\"4-总资产报酬率\"><a href=\"#4-总资产报酬率\" class=\"headerlink\" title=\"4.总资产报酬率\"></a>4.总资产报酬率</h3><p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gca5xxj3jdj20jk0cxwf6.jpg\" alt=\"总资产报酬率 (2).png\"></p>\n","site":{"data":{}},"excerpt":"<p>一个企业所做的事情就是3件事情：经营，投资，融资。资产负债表，利润表，现金流量表这3大报表反映了一个企业的情况。</p>\n<p>现金流量表这个维度，这个维度它描述了这个企业的未来是不是能够持续经营。</p>\n<p>资产负债表和利润表，它们共同构成另一个维度，假设这个企业能够继续生存下去，那么它的状况会是什么样子的？</p>\n<h3 id=\"1-资产负债表-Balance-Sheet\"><a href=\"#1-资产负债表-Balance-Sheet\" class=\"headerlink\" title=\"1.资产负债表(Balance Sheet)\"></a>1.资产负债表(Balance Sheet)</h3><p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gc6n9gabqsj20ic0mz78a.jpg\" alt=\"资产负债表.png\"></p>","more":"<p><strong>资产与费用的区别</strong> Difference between Asset &amp; Cost<br>花一笔钱出去，换来一个未来有用额东西，这就是资产，如果钱花完后什么都没有留下，那就是费用</p>\n<p><strong>净资产=股东权益=资产-负债</strong></p>\n<p>每股净资产 = 净资产/股本数</p>\n<p>市值 = 每股价格*股本数</p>\n<p>市净率（PB） = 市值/净资产 = 每股价格/每股净资产</p>\n<h3 id=\"2-利润表-Income-Statement\"><a href=\"#2-利润表-Income-Statement\" class=\"headerlink\" title=\"2.利润表 (Income Statement)\"></a>2.利润表 (Income Statement)</h3><p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gc6opfa0taj20nn0cewgf.jpg\" alt=\"利润表.png\"></p>\n<p>每股利润 = 净利润/股本数。</p>\n<p>市盈率（PE）= 每股价格/每股利润。</p>\n<p>利润表两大作用</p>\n<ul>\n<li>现在公司赚多少钱</li>\n<li>形成对公司未来赢利预期的基础</li>\n</ul>\n<h3 id=\"3-现金流量表-Cash-Flow-Statement\"><a href=\"#3-现金流量表-Cash-Flow-Statement\" class=\"headerlink\" title=\"3.现金流量表(Cash Flow Statement)\"></a>3.现金流量表(Cash Flow Statement)</h3><p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gc7u1izh6xj20vq0k0whf.jpg\" alt=\"现金流量表.png\"></p>\n<p>现金流量表作用</p>\n<p>告诉我们现金增减变化如何发生的？（是经营活动？是融资活动？是投资活动？）</p>\n<h3 id=\"4-总资产报酬率\"><a href=\"#4-总资产报酬率\" class=\"headerlink\" title=\"4.总资产报酬率\"></a>4.总资产报酬率</h3><p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gca5xxj3jdj20jk0cxwf6.jpg\" alt=\"总资产报酬率 (2).png\"></p>"},{"title":"领域驱动设计（DDD）","date":"2020-02-03T14:07:32.000Z","_content":"### 1. 名词解释\n\n- 领域：将业务根据不同范围细分，当细分到一定的程度后，不同业务会有不同范围，\n  在这个范围内解决业务问题就是领域。\n\n- 实体：就是业务对象，具有业务行为，业务逻辑和唯一ID。实体类通常采用充血模型，包含了实体的属性和实体相关的所有业务逻辑方法，跨多个实体的领域逻辑则在领域服务中实现。\n\n- 值对象：是若干个属性的集合，没有ID，不包含业务逻辑，可以被其他实体共享，采用贫血模型。**实体和值对象是微服务底层的最基础的对象，一起实现实体最基本的核心领域逻辑。**\n\n  > 传统的数据建模是根据数据库范式设计的，每一个数据库表对应一个实体，每一个实体的属性值用单独\n  > 的一列来存储，一个实体主表会对应N个实体从表。值对象在数据库持久化做了简化了设计，它的数据库\n  > 设计大多采用非数据库范式，值对象的属性值和实体对象的属性值可以保存在不同表中。\n\n- 聚合：是由业务和逻辑紧密关联的实体和值对象组合的，聚合是数据修改和持久化的\n  基本单元，每一个聚合对应一个仓储，实现数据的持久化。\n\n- 聚合根：是实体，有实体的特点，具有全局唯一标识，是聚合的入口，聚合根与聚合根之间通\n  过ID关联的方式实现聚合之间的协同。\n\n- 领域事件（Domain Event）：这种事件发生后通常会导致进一步的业务操作。\n\n<!--more--> \n\n### 2. 分层\n\n- 用户接口层：面向前端提供服务适配，面向资源层提供资源适配。这一层聚集了接口适配相关的功能。\n- 应用层：实现服务组合和编排，适应业务流程快速变化的需求。这一层聚集了应用服务和事件相关的\n  功能。\n- 领域层：实现领域的核心业务逻辑。这一层聚集了领域模型的聚合、聚合根、实体、值对象、领域服务和\n  事件等领域对象，以及它们组合所形成的业务能力。\n- 基础层：贯穿所有层，为各层提供基础资源服务。这一层聚集了各种底层资源相关的服务和能力。\n\n<img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1gbjk949oskj20qg0nfgqp.jpg\" alt=\"DDD分层.png\" style=\"zoom: 67%;\" />\n\n<img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1gbjkbj1kmtj20r20jtafu.jpg\" alt=\"传统分层和DDD分层.png\" style=\"zoom: 67%;\" />\n\n<img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1gbjkbndlalj20db0jc74p.jpg\" alt=\"代码实现.png\" style=\"zoom: 80%;\" />","source":"_posts/领域驱动设计（DDD）.md","raw":"---\ntitle: 领域驱动设计（DDD）\ndate: 2020-02-03 22:07:32\ntags:\n---\n### 1. 名词解释\n\n- 领域：将业务根据不同范围细分，当细分到一定的程度后，不同业务会有不同范围，\n  在这个范围内解决业务问题就是领域。\n\n- 实体：就是业务对象，具有业务行为，业务逻辑和唯一ID。实体类通常采用充血模型，包含了实体的属性和实体相关的所有业务逻辑方法，跨多个实体的领域逻辑则在领域服务中实现。\n\n- 值对象：是若干个属性的集合，没有ID，不包含业务逻辑，可以被其他实体共享，采用贫血模型。**实体和值对象是微服务底层的最基础的对象，一起实现实体最基本的核心领域逻辑。**\n\n  > 传统的数据建模是根据数据库范式设计的，每一个数据库表对应一个实体，每一个实体的属性值用单独\n  > 的一列来存储，一个实体主表会对应N个实体从表。值对象在数据库持久化做了简化了设计，它的数据库\n  > 设计大多采用非数据库范式，值对象的属性值和实体对象的属性值可以保存在不同表中。\n\n- 聚合：是由业务和逻辑紧密关联的实体和值对象组合的，聚合是数据修改和持久化的\n  基本单元，每一个聚合对应一个仓储，实现数据的持久化。\n\n- 聚合根：是实体，有实体的特点，具有全局唯一标识，是聚合的入口，聚合根与聚合根之间通\n  过ID关联的方式实现聚合之间的协同。\n\n- 领域事件（Domain Event）：这种事件发生后通常会导致进一步的业务操作。\n\n<!--more--> \n\n### 2. 分层\n\n- 用户接口层：面向前端提供服务适配，面向资源层提供资源适配。这一层聚集了接口适配相关的功能。\n- 应用层：实现服务组合和编排，适应业务流程快速变化的需求。这一层聚集了应用服务和事件相关的\n  功能。\n- 领域层：实现领域的核心业务逻辑。这一层聚集了领域模型的聚合、聚合根、实体、值对象、领域服务和\n  事件等领域对象，以及它们组合所形成的业务能力。\n- 基础层：贯穿所有层，为各层提供基础资源服务。这一层聚集了各种底层资源相关的服务和能力。\n\n<img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1gbjk949oskj20qg0nfgqp.jpg\" alt=\"DDD分层.png\" style=\"zoom: 67%;\" />\n\n<img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1gbjkbj1kmtj20r20jtafu.jpg\" alt=\"传统分层和DDD分层.png\" style=\"zoom: 67%;\" />\n\n<img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1gbjkbndlalj20db0jc74p.jpg\" alt=\"代码实现.png\" style=\"zoom: 80%;\" />","slug":"领域驱动设计（DDD）","published":1,"updated":"2020-08-09T05:24:13.303Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdmsee03001blguwtb1lvb1r","content":"<h3 id=\"1-名词解释\"><a href=\"#1-名词解释\" class=\"headerlink\" title=\"1. 名词解释\"></a>1. 名词解释</h3><ul>\n<li><p>领域：将业务根据不同范围细分，当细分到一定的程度后，不同业务会有不同范围，<br>在这个范围内解决业务问题就是领域。</p>\n</li>\n<li><p>实体：就是业务对象，具有业务行为，业务逻辑和唯一ID。实体类通常采用充血模型，包含了实体的属性和实体相关的所有业务逻辑方法，跨多个实体的领域逻辑则在领域服务中实现。</p>\n</li>\n<li><p>值对象：是若干个属性的集合，没有ID，不包含业务逻辑，可以被其他实体共享，采用贫血模型。<strong>实体和值对象是微服务底层的最基础的对象，一起实现实体最基本的核心领域逻辑。</strong></p>\n<blockquote>\n<p>传统的数据建模是根据数据库范式设计的，每一个数据库表对应一个实体，每一个实体的属性值用单独<br>的一列来存储，一个实体主表会对应N个实体从表。值对象在数据库持久化做了简化了设计，它的数据库<br>设计大多采用非数据库范式，值对象的属性值和实体对象的属性值可以保存在不同表中。</p>\n</blockquote>\n</li>\n<li><p>聚合：是由业务和逻辑紧密关联的实体和值对象组合的，聚合是数据修改和持久化的<br>基本单元，每一个聚合对应一个仓储，实现数据的持久化。</p>\n</li>\n<li><p>聚合根：是实体，有实体的特点，具有全局唯一标识，是聚合的入口，聚合根与聚合根之间通<br>过ID关联的方式实现聚合之间的协同。</p>\n</li>\n<li><p>领域事件（Domain Event）：这种事件发生后通常会导致进一步的业务操作。</p>\n</li>\n</ul>\n<a id=\"more\"></a> \n<h3 id=\"2-分层\"><a href=\"#2-分层\" class=\"headerlink\" title=\"2. 分层\"></a>2. 分层</h3><ul>\n<li>用户接口层：面向前端提供服务适配，面向资源层提供资源适配。这一层聚集了接口适配相关的功能。</li>\n<li>应用层：实现服务组合和编排，适应业务流程快速变化的需求。这一层聚集了应用服务和事件相关的<br>功能。</li>\n<li>领域层：实现领域的核心业务逻辑。这一层聚集了领域模型的聚合、聚合根、实体、值对象、领域服务和<br>事件等领域对象，以及它们组合所形成的业务能力。</li>\n<li>基础层：贯穿所有层，为各层提供基础资源服务。这一层聚集了各种底层资源相关的服务和能力。</li>\n</ul>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1gbjk949oskj20qg0nfgqp.jpg\" alt=\"DDD分层.png\" style=\"zoom: 67%;\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1gbjkbj1kmtj20r20jtafu.jpg\" alt=\"传统分层和DDD分层.png\" style=\"zoom: 67%;\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1gbjkbndlalj20db0jc74p.jpg\" alt=\"代码实现.png\" style=\"zoom: 80%;\"></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-名词解释\"><a href=\"#1-名词解释\" class=\"headerlink\" title=\"1. 名词解释\"></a>1. 名词解释</h3><ul>\n<li><p>领域：将业务根据不同范围细分，当细分到一定的程度后，不同业务会有不同范围，<br>在这个范围内解决业务问题就是领域。</p>\n</li>\n<li><p>实体：就是业务对象，具有业务行为，业务逻辑和唯一ID。实体类通常采用充血模型，包含了实体的属性和实体相关的所有业务逻辑方法，跨多个实体的领域逻辑则在领域服务中实现。</p>\n</li>\n<li><p>值对象：是若干个属性的集合，没有ID，不包含业务逻辑，可以被其他实体共享，采用贫血模型。<strong>实体和值对象是微服务底层的最基础的对象，一起实现实体最基本的核心领域逻辑。</strong></p>\n<blockquote>\n<p>传统的数据建模是根据数据库范式设计的，每一个数据库表对应一个实体，每一个实体的属性值用单独<br>的一列来存储，一个实体主表会对应N个实体从表。值对象在数据库持久化做了简化了设计，它的数据库<br>设计大多采用非数据库范式，值对象的属性值和实体对象的属性值可以保存在不同表中。</p>\n</blockquote>\n</li>\n<li><p>聚合：是由业务和逻辑紧密关联的实体和值对象组合的，聚合是数据修改和持久化的<br>基本单元，每一个聚合对应一个仓储，实现数据的持久化。</p>\n</li>\n<li><p>聚合根：是实体，有实体的特点，具有全局唯一标识，是聚合的入口，聚合根与聚合根之间通<br>过ID关联的方式实现聚合之间的协同。</p>\n</li>\n<li><p>领域事件（Domain Event）：这种事件发生后通常会导致进一步的业务操作。</p>\n</li>\n</ul>","more":"<h3 id=\"2-分层\"><a href=\"#2-分层\" class=\"headerlink\" title=\"2. 分层\"></a>2. 分层</h3><ul>\n<li>用户接口层：面向前端提供服务适配，面向资源层提供资源适配。这一层聚集了接口适配相关的功能。</li>\n<li>应用层：实现服务组合和编排，适应业务流程快速变化的需求。这一层聚集了应用服务和事件相关的<br>功能。</li>\n<li>领域层：实现领域的核心业务逻辑。这一层聚集了领域模型的聚合、聚合根、实体、值对象、领域服务和<br>事件等领域对象，以及它们组合所形成的业务能力。</li>\n<li>基础层：贯穿所有层，为各层提供基础资源服务。这一层聚集了各种底层资源相关的服务和能力。</li>\n</ul>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1gbjk949oskj20qg0nfgqp.jpg\" alt=\"DDD分层.png\" style=\"zoom: 67%;\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1gbjkbj1kmtj20r20jtafu.jpg\" alt=\"传统分层和DDD分层.png\" style=\"zoom: 67%;\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1gbjkbndlalj20db0jc74p.jpg\" alt=\"代码实现.png\" style=\"zoom: 80%;\"></p>"},{"title":"ELK初识","date":"2020-02-09T14:43:36.000Z","_content":"\nELK是**E**lasticsearch，**L**ogstash，**K**ibana三个组件组合起来的缩写。\n\n**E**lasticsearch是搜索引擎，**L**ogstash是收集数据输出到elasticsearch中。**K**ibana是**E**lasticsearch数据的可视化，类比于navicat是Mysql数据的可视化。\n\n### 1. ElasticSearch概念\n\n画一个对比图来类比传统关系型数据库：\n\n- 关系型数据库 -> Databases(库) -> Tables(表) -> Rows(行) -> Columns(列)。\n- Elasticsearch -> Indeces(索引) -> Types(类型) -> Documents(文档) -> Fields(属性)。\n\n**索引**\n\n一个索引(index)就像是传统关系数据库中的数据库，它是相关文档存储的地方。\n\n**文档**\n\n就是一个对象Json串。\n\n**分片（shards）**\n\n索引可能存储大量可能超过单个节点的硬件限制的数据，需要将索引细分，细分后的部分是分片。\n\n**副本（Replicasedit）**\n\n副本，是对分片的复制。\n\n**倒排索引**\n\n就是通过文档中的字段反查到文档的id。\n\nES的JSON文档中的每个字段，都有自己的倒排索引。\n\n组成：单词字典（单词到倒排列表的关系）和倒排列表（记录了单词对应文档的结合）。\n\n<!--more--> \n\n### 2. 搭建ELK环境读取数据库\n\n1. 下载版本相同的elasticsearch，logstash，kibana。\n2. logstash安装logstash-jdbc-input插件。\n3. 配置logstash.conf\n\n```json\ninput {\n  #beats {\n  #  port => 5044\n  #}\n  jdbc {\n      # 数据库  数据库名称为elk，表名为book_table\n      jdbc_connection_string => \"jdbc:mysql://127.0.0.1:3306/tmall_springboot?characterEncoding=UTF-8\"\n      # 用户名密码\n      jdbc_user => \"root\"\n      jdbc_password => \"123456\"\n      # jar包的位置\n      jdbc_driver_library => \"E:\\ELK\\logstash-7.5.2\\mysql-connector-java-5.1.30.jar\"\n      # mysql的Driver\n      jdbc_driver_class => \"com.mysql.jdbc.Driver\"\n      jdbc_paging_enabled => \"true\"\n      jdbc_page_size => \"100\"\n      #statement_filepath => \"E:\\logstash-7.3.0\\config\\viewlogs.sql\"\n      statement => \"select * from category where id > :sql_last_value\"\n      schedule => \"* * * * *\"\n      #是否记录上次执行结果, 如果为真,将会把上次执行到的 tracking_column 字段的值记录下来,保存到 last_run_metadata_path 指定的文件中\n      record_last_run => true\n \n      #是否需要记录某个column 的值,如果 record_last_run 为真,可以自定义我们需要 track 的 column 名称，此时该参数就要为 true. 否则默认 track 的是 timestamp 的值.\n      use_column_value => true\n \n      #如果 use_column_value 为真,需配置此参数. track 的数据库 column 名,该 column 必须是递增的.比如：ID.\n      tracking_column => id\n \n      #指定文件,来记录上次执行到的 tracking_column 字段的值\n      #比如上次数据库有 10000 条记录,查询完后该文件中就会有数字 10000 这样的记录,下次执行 SQL 查询可以从 10001 条处开始.\n      #我们只需要在 SQL 语句中 WHERE MY_ID > :last_sql_value 即可. 其中 :last_sql_value 取得就是该文件中的值(10000).\n      #last_run_metadata_path => \"E:\\ELK\\logstash-7.5.2\\viewlogs\"\n \n      #是否清除 last_run_metadata_path 的记录,如果为真那么每次都相当于从头开始查询所有的数据库记录\n      clean_run => false\n \n      #是否将 column 名称转小写\n      #lowercase_column_names => false\n    }\n}\n \noutput {\n \n  elasticsearch {\n    hosts => [\"http://localhost:9200\"]\n    #按分钟\n    #index => \"mysql-%{+YYYY.MM.dd.HH.mm}\"\n    #按小时\n    index => \"logstashmysql\"\n    #index => \"wdnmd\"\n    #index => \"%{[servicename]}\"\n    #index => \"logstash-%{[fields][document_type]}-%{+YYYY.MM.dd}\"\n    #index => \"%{[@metadata][beat]}-%{[@metadata][version]}-%{+YYYY.MM.dd}\"\n    #user => \"elastic\"\n    #password => \"changeme\"\n  }\n   stdout {\n        codec => rubydebug\n    }\n}\n```\n\n在logstash当前目录下启动logstash\n\n```shell\nbin/logstash -f logstash.conf\n```\n\n### 3. 用sql语句查询elasticsearch\n\n安装的elasticsearch是7.5.2版本，可以用sql语句查询elasticsearch。\n\n```\nPOST /_sql?format=txt\n{\n    \"query\": \"SELECT order_id  FROM goodslist WHERE goods_list like '%抽纸%' group by order_id\"\n}\n```\n\n![微信截图_20200209223923.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gbqj3fulqgj211h0er0vp.jpg)\n\nSQL转DSL\n\n```\nPOST /_sql/translate?format=txt\n{\n    \"query\": \"SELECT *  FROM mobile_index WHERE mobile like '%760714206%'\"\n}\n\n```\n\n![DSL.png](http://ww1.sinaimg.cn/large/aacc02d8ly1gckaw3oez9j212b0gp759.jpg)","source":"_posts/ELK初识.md","raw":"---\ntitle: ELK初识\ndate: 2020-02-09 22:43:36\ntags:\n---\n\nELK是**E**lasticsearch，**L**ogstash，**K**ibana三个组件组合起来的缩写。\n\n**E**lasticsearch是搜索引擎，**L**ogstash是收集数据输出到elasticsearch中。**K**ibana是**E**lasticsearch数据的可视化，类比于navicat是Mysql数据的可视化。\n\n### 1. ElasticSearch概念\n\n画一个对比图来类比传统关系型数据库：\n\n- 关系型数据库 -> Databases(库) -> Tables(表) -> Rows(行) -> Columns(列)。\n- Elasticsearch -> Indeces(索引) -> Types(类型) -> Documents(文档) -> Fields(属性)。\n\n**索引**\n\n一个索引(index)就像是传统关系数据库中的数据库，它是相关文档存储的地方。\n\n**文档**\n\n就是一个对象Json串。\n\n**分片（shards）**\n\n索引可能存储大量可能超过单个节点的硬件限制的数据，需要将索引细分，细分后的部分是分片。\n\n**副本（Replicasedit）**\n\n副本，是对分片的复制。\n\n**倒排索引**\n\n就是通过文档中的字段反查到文档的id。\n\nES的JSON文档中的每个字段，都有自己的倒排索引。\n\n组成：单词字典（单词到倒排列表的关系）和倒排列表（记录了单词对应文档的结合）。\n\n<!--more--> \n\n### 2. 搭建ELK环境读取数据库\n\n1. 下载版本相同的elasticsearch，logstash，kibana。\n2. logstash安装logstash-jdbc-input插件。\n3. 配置logstash.conf\n\n```json\ninput {\n  #beats {\n  #  port => 5044\n  #}\n  jdbc {\n      # 数据库  数据库名称为elk，表名为book_table\n      jdbc_connection_string => \"jdbc:mysql://127.0.0.1:3306/tmall_springboot?characterEncoding=UTF-8\"\n      # 用户名密码\n      jdbc_user => \"root\"\n      jdbc_password => \"123456\"\n      # jar包的位置\n      jdbc_driver_library => \"E:\\ELK\\logstash-7.5.2\\mysql-connector-java-5.1.30.jar\"\n      # mysql的Driver\n      jdbc_driver_class => \"com.mysql.jdbc.Driver\"\n      jdbc_paging_enabled => \"true\"\n      jdbc_page_size => \"100\"\n      #statement_filepath => \"E:\\logstash-7.3.0\\config\\viewlogs.sql\"\n      statement => \"select * from category where id > :sql_last_value\"\n      schedule => \"* * * * *\"\n      #是否记录上次执行结果, 如果为真,将会把上次执行到的 tracking_column 字段的值记录下来,保存到 last_run_metadata_path 指定的文件中\n      record_last_run => true\n \n      #是否需要记录某个column 的值,如果 record_last_run 为真,可以自定义我们需要 track 的 column 名称，此时该参数就要为 true. 否则默认 track 的是 timestamp 的值.\n      use_column_value => true\n \n      #如果 use_column_value 为真,需配置此参数. track 的数据库 column 名,该 column 必须是递增的.比如：ID.\n      tracking_column => id\n \n      #指定文件,来记录上次执行到的 tracking_column 字段的值\n      #比如上次数据库有 10000 条记录,查询完后该文件中就会有数字 10000 这样的记录,下次执行 SQL 查询可以从 10001 条处开始.\n      #我们只需要在 SQL 语句中 WHERE MY_ID > :last_sql_value 即可. 其中 :last_sql_value 取得就是该文件中的值(10000).\n      #last_run_metadata_path => \"E:\\ELK\\logstash-7.5.2\\viewlogs\"\n \n      #是否清除 last_run_metadata_path 的记录,如果为真那么每次都相当于从头开始查询所有的数据库记录\n      clean_run => false\n \n      #是否将 column 名称转小写\n      #lowercase_column_names => false\n    }\n}\n \noutput {\n \n  elasticsearch {\n    hosts => [\"http://localhost:9200\"]\n    #按分钟\n    #index => \"mysql-%{+YYYY.MM.dd.HH.mm}\"\n    #按小时\n    index => \"logstashmysql\"\n    #index => \"wdnmd\"\n    #index => \"%{[servicename]}\"\n    #index => \"logstash-%{[fields][document_type]}-%{+YYYY.MM.dd}\"\n    #index => \"%{[@metadata][beat]}-%{[@metadata][version]}-%{+YYYY.MM.dd}\"\n    #user => \"elastic\"\n    #password => \"changeme\"\n  }\n   stdout {\n        codec => rubydebug\n    }\n}\n```\n\n在logstash当前目录下启动logstash\n\n```shell\nbin/logstash -f logstash.conf\n```\n\n### 3. 用sql语句查询elasticsearch\n\n安装的elasticsearch是7.5.2版本，可以用sql语句查询elasticsearch。\n\n```\nPOST /_sql?format=txt\n{\n    \"query\": \"SELECT order_id  FROM goodslist WHERE goods_list like '%抽纸%' group by order_id\"\n}\n```\n\n![微信截图_20200209223923.png](http://ww1.sinaimg.cn/large/aacc02d8gy1gbqj3fulqgj211h0er0vp.jpg)\n\nSQL转DSL\n\n```\nPOST /_sql/translate?format=txt\n{\n    \"query\": \"SELECT *  FROM mobile_index WHERE mobile like '%760714206%'\"\n}\n\n```\n\n![DSL.png](http://ww1.sinaimg.cn/large/aacc02d8ly1gckaw3oez9j212b0gp759.jpg)","slug":"ELK初识","published":1,"updated":"2020-08-09T05:24:13.279Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdmsee06001elguw3yigex20","content":"<p>ELK是<strong>E</strong>lasticsearch，<strong>L</strong>ogstash，<strong>K</strong>ibana三个组件组合起来的缩写。</p>\n<p><strong>E</strong>lasticsearch是搜索引擎，<strong>L</strong>ogstash是收集数据输出到elasticsearch中。<strong>K</strong>ibana是<strong>E</strong>lasticsearch数据的可视化，类比于navicat是Mysql数据的可视化。</p>\n<h3 id=\"1-ElasticSearch概念\"><a href=\"#1-ElasticSearch概念\" class=\"headerlink\" title=\"1. ElasticSearch概念\"></a>1. ElasticSearch概念</h3><p>画一个对比图来类比传统关系型数据库：</p>\n<ul>\n<li>关系型数据库 -&gt; Databases(库) -&gt; Tables(表) -&gt; Rows(行) -&gt; Columns(列)。</li>\n<li>Elasticsearch -&gt; Indeces(索引) -&gt; Types(类型) -&gt; Documents(文档) -&gt; Fields(属性)。</li>\n</ul>\n<p><strong>索引</strong></p>\n<p>一个索引(index)就像是传统关系数据库中的数据库，它是相关文档存储的地方。</p>\n<p><strong>文档</strong></p>\n<p>就是一个对象Json串。</p>\n<p><strong>分片（shards）</strong></p>\n<p>索引可能存储大量可能超过单个节点的硬件限制的数据，需要将索引细分，细分后的部分是分片。</p>\n<p><strong>副本（Replicasedit）</strong></p>\n<p>副本，是对分片的复制。</p>\n<p><strong>倒排索引</strong></p>\n<p>就是通过文档中的字段反查到文档的id。</p>\n<p>ES的JSON文档中的每个字段，都有自己的倒排索引。</p>\n<p>组成：单词字典（单词到倒排列表的关系）和倒排列表（记录了单词对应文档的结合）。</p>\n<a id=\"more\"></a> \n<h3 id=\"2-搭建ELK环境读取数据库\"><a href=\"#2-搭建ELK环境读取数据库\" class=\"headerlink\" title=\"2. 搭建ELK环境读取数据库\"></a>2. 搭建ELK环境读取数据库</h3><ol>\n<li>下载版本相同的elasticsearch，logstash，kibana。</li>\n<li>logstash安装logstash-jdbc-input插件。</li>\n<li>配置logstash.conf</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input &#123;</span><br><span class=\"line\">  #beats &#123;</span><br><span class=\"line\">  #  port =&gt; 5044</span><br><span class=\"line\">  #&#125;</span><br><span class=\"line\">  jdbc &#123;</span><br><span class=\"line\">      # 数据库  数据库名称为elk，表名为book_table</span><br><span class=\"line\">      jdbc_connection_string =&gt; \"jdbc:mysql://127.0.0.1:3306/tmall_springboot?characterEncoding=UTF-8\"</span><br><span class=\"line\">      # 用户名密码</span><br><span class=\"line\">      jdbc_user =&gt; \"root\"</span><br><span class=\"line\">      jdbc_password =&gt; \"123456\"</span><br><span class=\"line\">      # jar包的位置</span><br><span class=\"line\">      jdbc_driver_library =&gt; \"E:\\ELK\\logstash-7.5.2\\mysql-connector-java-5.1.30.jar\"</span><br><span class=\"line\">      # mysql的Driver</span><br><span class=\"line\">      jdbc_driver_class =&gt; \"com.mysql.jdbc.Driver\"</span><br><span class=\"line\">      jdbc_paging_enabled =&gt; \"true\"</span><br><span class=\"line\">      jdbc_page_size =&gt; \"100\"</span><br><span class=\"line\">      #statement_filepath =&gt; \"E:\\logstash-7.3.0\\config\\viewlogs.sql\"</span><br><span class=\"line\">      statement =&gt; \"select * from category where id &gt; :sql_last_value\"</span><br><span class=\"line\">      schedule =&gt; \"* * * * *\"</span><br><span class=\"line\">      #是否记录上次执行结果, 如果为真,将会把上次执行到的 tracking_column 字段的值记录下来,保存到 last_run_metadata_path 指定的文件中</span><br><span class=\"line\">      record_last_run =&gt; true</span><br><span class=\"line\"> </span><br><span class=\"line\">      #是否需要记录某个column 的值,如果 record_last_run 为真,可以自定义我们需要 track 的 column 名称，此时该参数就要为 true. 否则默认 track 的是 timestamp 的值.</span><br><span class=\"line\">      use_column_value =&gt; true</span><br><span class=\"line\"> </span><br><span class=\"line\">      #如果 use_column_value 为真,需配置此参数. track 的数据库 column 名,该 column 必须是递增的.比如：ID.</span><br><span class=\"line\">      tracking_column =&gt; id</span><br><span class=\"line\"> </span><br><span class=\"line\">      #指定文件,来记录上次执行到的 tracking_column 字段的值</span><br><span class=\"line\">      #比如上次数据库有 10000 条记录,查询完后该文件中就会有数字 10000 这样的记录,下次执行 SQL 查询可以从 10001 条处开始.</span><br><span class=\"line\">      #我们只需要在 SQL 语句中 WHERE MY_ID &gt; :last_sql_value 即可. 其中 :last_sql_value 取得就是该文件中的值(10000).</span><br><span class=\"line\">      #last_run_metadata_path =&gt; \"E:\\ELK\\logstash-7.5.2\\viewlogs\"</span><br><span class=\"line\"> </span><br><span class=\"line\">      #是否清除 last_run_metadata_path 的记录,如果为真那么每次都相当于从头开始查询所有的数据库记录</span><br><span class=\"line\">      clean_run =&gt; false</span><br><span class=\"line\"> </span><br><span class=\"line\">      #是否将 column 名称转小写</span><br><span class=\"line\">      #lowercase_column_names =&gt; false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">output &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">  elasticsearch &#123;</span><br><span class=\"line\">    hosts =&gt; [\"http://localhost:9200\"]</span><br><span class=\"line\">    #按分钟</span><br><span class=\"line\">    #index =&gt; \"mysql-%&#123;+YYYY.MM.dd.HH.mm&#125;\"</span><br><span class=\"line\">    #按小时</span><br><span class=\"line\">    index =&gt; \"logstashmysql\"</span><br><span class=\"line\">    #index =&gt; \"wdnmd\"</span><br><span class=\"line\">    #index =&gt; \"%&#123;[servicename]&#125;\"</span><br><span class=\"line\">    #index =&gt; \"logstash-%&#123;[fields][document_type]&#125;-%&#123;+YYYY.MM.dd&#125;\"</span><br><span class=\"line\">    #index =&gt; \"%&#123;[@metadata][beat]&#125;-%&#123;[@metadata][version]&#125;-%&#123;+YYYY.MM.dd&#125;\"</span><br><span class=\"line\">    #user =&gt; \"elastic\"</span><br><span class=\"line\">    #password =&gt; \"changeme\"</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">   stdout &#123;</span><br><span class=\"line\">        codec =&gt; rubydebug</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在logstash当前目录下启动logstash</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/logstash -f logstash.conf</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-用sql语句查询elasticsearch\"><a href=\"#3-用sql语句查询elasticsearch\" class=\"headerlink\" title=\"3. 用sql语句查询elasticsearch\"></a>3. 用sql语句查询elasticsearch</h3><p>安装的elasticsearch是7.5.2版本，可以用sql语句查询elasticsearch。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /_sql?format=txt</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;query&quot;: &quot;SELECT order_id  FROM goodslist WHERE goods_list like &apos;%抽纸%&apos; group by order_id&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gbqj3fulqgj211h0er0vp.jpg\" alt=\"微信截图_20200209223923.png\"></p>\n<p>SQL转DSL</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /_sql/translate?format=txt</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;query&quot;: &quot;SELECT *  FROM mobile_index WHERE mobile like &apos;%760714206%&apos;&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1gckaw3oez9j212b0gp759.jpg\" alt=\"DSL.png\"></p>\n","site":{"data":{}},"excerpt":"<p>ELK是<strong>E</strong>lasticsearch，<strong>L</strong>ogstash，<strong>K</strong>ibana三个组件组合起来的缩写。</p>\n<p><strong>E</strong>lasticsearch是搜索引擎，<strong>L</strong>ogstash是收集数据输出到elasticsearch中。<strong>K</strong>ibana是<strong>E</strong>lasticsearch数据的可视化，类比于navicat是Mysql数据的可视化。</p>\n<h3 id=\"1-ElasticSearch概念\"><a href=\"#1-ElasticSearch概念\" class=\"headerlink\" title=\"1. ElasticSearch概念\"></a>1. ElasticSearch概念</h3><p>画一个对比图来类比传统关系型数据库：</p>\n<ul>\n<li>关系型数据库 -&gt; Databases(库) -&gt; Tables(表) -&gt; Rows(行) -&gt; Columns(列)。</li>\n<li>Elasticsearch -&gt; Indeces(索引) -&gt; Types(类型) -&gt; Documents(文档) -&gt; Fields(属性)。</li>\n</ul>\n<p><strong>索引</strong></p>\n<p>一个索引(index)就像是传统关系数据库中的数据库，它是相关文档存储的地方。</p>\n<p><strong>文档</strong></p>\n<p>就是一个对象Json串。</p>\n<p><strong>分片（shards）</strong></p>\n<p>索引可能存储大量可能超过单个节点的硬件限制的数据，需要将索引细分，细分后的部分是分片。</p>\n<p><strong>副本（Replicasedit）</strong></p>\n<p>副本，是对分片的复制。</p>\n<p><strong>倒排索引</strong></p>\n<p>就是通过文档中的字段反查到文档的id。</p>\n<p>ES的JSON文档中的每个字段，都有自己的倒排索引。</p>\n<p>组成：单词字典（单词到倒排列表的关系）和倒排列表（记录了单词对应文档的结合）。</p>","more":"<h3 id=\"2-搭建ELK环境读取数据库\"><a href=\"#2-搭建ELK环境读取数据库\" class=\"headerlink\" title=\"2. 搭建ELK环境读取数据库\"></a>2. 搭建ELK环境读取数据库</h3><ol>\n<li>下载版本相同的elasticsearch，logstash，kibana。</li>\n<li>logstash安装logstash-jdbc-input插件。</li>\n<li>配置logstash.conf</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input &#123;</span><br><span class=\"line\">  #beats &#123;</span><br><span class=\"line\">  #  port =&gt; 5044</span><br><span class=\"line\">  #&#125;</span><br><span class=\"line\">  jdbc &#123;</span><br><span class=\"line\">      # 数据库  数据库名称为elk，表名为book_table</span><br><span class=\"line\">      jdbc_connection_string =&gt; \"jdbc:mysql://127.0.0.1:3306/tmall_springboot?characterEncoding=UTF-8\"</span><br><span class=\"line\">      # 用户名密码</span><br><span class=\"line\">      jdbc_user =&gt; \"root\"</span><br><span class=\"line\">      jdbc_password =&gt; \"123456\"</span><br><span class=\"line\">      # jar包的位置</span><br><span class=\"line\">      jdbc_driver_library =&gt; \"E:\\ELK\\logstash-7.5.2\\mysql-connector-java-5.1.30.jar\"</span><br><span class=\"line\">      # mysql的Driver</span><br><span class=\"line\">      jdbc_driver_class =&gt; \"com.mysql.jdbc.Driver\"</span><br><span class=\"line\">      jdbc_paging_enabled =&gt; \"true\"</span><br><span class=\"line\">      jdbc_page_size =&gt; \"100\"</span><br><span class=\"line\">      #statement_filepath =&gt; \"E:\\logstash-7.3.0\\config\\viewlogs.sql\"</span><br><span class=\"line\">      statement =&gt; \"select * from category where id &gt; :sql_last_value\"</span><br><span class=\"line\">      schedule =&gt; \"* * * * *\"</span><br><span class=\"line\">      #是否记录上次执行结果, 如果为真,将会把上次执行到的 tracking_column 字段的值记录下来,保存到 last_run_metadata_path 指定的文件中</span><br><span class=\"line\">      record_last_run =&gt; true</span><br><span class=\"line\"> </span><br><span class=\"line\">      #是否需要记录某个column 的值,如果 record_last_run 为真,可以自定义我们需要 track 的 column 名称，此时该参数就要为 true. 否则默认 track 的是 timestamp 的值.</span><br><span class=\"line\">      use_column_value =&gt; true</span><br><span class=\"line\"> </span><br><span class=\"line\">      #如果 use_column_value 为真,需配置此参数. track 的数据库 column 名,该 column 必须是递增的.比如：ID.</span><br><span class=\"line\">      tracking_column =&gt; id</span><br><span class=\"line\"> </span><br><span class=\"line\">      #指定文件,来记录上次执行到的 tracking_column 字段的值</span><br><span class=\"line\">      #比如上次数据库有 10000 条记录,查询完后该文件中就会有数字 10000 这样的记录,下次执行 SQL 查询可以从 10001 条处开始.</span><br><span class=\"line\">      #我们只需要在 SQL 语句中 WHERE MY_ID &gt; :last_sql_value 即可. 其中 :last_sql_value 取得就是该文件中的值(10000).</span><br><span class=\"line\">      #last_run_metadata_path =&gt; \"E:\\ELK\\logstash-7.5.2\\viewlogs\"</span><br><span class=\"line\"> </span><br><span class=\"line\">      #是否清除 last_run_metadata_path 的记录,如果为真那么每次都相当于从头开始查询所有的数据库记录</span><br><span class=\"line\">      clean_run =&gt; false</span><br><span class=\"line\"> </span><br><span class=\"line\">      #是否将 column 名称转小写</span><br><span class=\"line\">      #lowercase_column_names =&gt; false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">output &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">  elasticsearch &#123;</span><br><span class=\"line\">    hosts =&gt; [\"http://localhost:9200\"]</span><br><span class=\"line\">    #按分钟</span><br><span class=\"line\">    #index =&gt; \"mysql-%&#123;+YYYY.MM.dd.HH.mm&#125;\"</span><br><span class=\"line\">    #按小时</span><br><span class=\"line\">    index =&gt; \"logstashmysql\"</span><br><span class=\"line\">    #index =&gt; \"wdnmd\"</span><br><span class=\"line\">    #index =&gt; \"%&#123;[servicename]&#125;\"</span><br><span class=\"line\">    #index =&gt; \"logstash-%&#123;[fields][document_type]&#125;-%&#123;+YYYY.MM.dd&#125;\"</span><br><span class=\"line\">    #index =&gt; \"%&#123;[@metadata][beat]&#125;-%&#123;[@metadata][version]&#125;-%&#123;+YYYY.MM.dd&#125;\"</span><br><span class=\"line\">    #user =&gt; \"elastic\"</span><br><span class=\"line\">    #password =&gt; \"changeme\"</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">   stdout &#123;</span><br><span class=\"line\">        codec =&gt; rubydebug</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在logstash当前目录下启动logstash</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/logstash -f logstash.conf</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-用sql语句查询elasticsearch\"><a href=\"#3-用sql语句查询elasticsearch\" class=\"headerlink\" title=\"3. 用sql语句查询elasticsearch\"></a>3. 用sql语句查询elasticsearch</h3><p>安装的elasticsearch是7.5.2版本，可以用sql语句查询elasticsearch。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /_sql?format=txt</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;query&quot;: &quot;SELECT order_id  FROM goodslist WHERE goods_list like &apos;%抽纸%&apos; group by order_id&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1gbqj3fulqgj211h0er0vp.jpg\" alt=\"微信截图_20200209223923.png\"></p>\n<p>SQL转DSL</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /_sql/translate?format=txt</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;query&quot;: &quot;SELECT *  FROM mobile_index WHERE mobile like &apos;%760714206%&apos;&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1gckaw3oez9j212b0gp759.jpg\" alt=\"DSL.png\"></p>"},{"layout":"post","title":"双指针逼近法","date":"2017-09-11T11:58:00.000Z","comments":1,"reward":true,"_content":"\n#### 双指针逼近法：双指针相向夹逼，从两头开始向中间移动。\n\n#### leetcode-15.3Sum\n\nGiven an array *S* of *n* integers, are there elements *a*, *b*, *c* in *S* such that *a* + *b* + *c* = 0? Find all unique triplets in the array which gives the sum of zero.\n\n**Note:** The solution set must not contain duplicate triplets.\n\n```\nFor example, given array S = [-1, 0, 1, 2, -1, -4],\n\nA solution set is:\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n```\n\n题意：在给定的一个数组中找到三个之数为0的组合。\n\n<!--more--> \n\nNote：1.用暴力的方法，时间复杂度会达到O(n^3),用双指针逼近法将时间复杂度降到O(n^2)。\n\n​\t    2.三个数的组合中有相同的组合，要考虑到去除重复的。\n\n```C++\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        \n            vector<vector<int>> sum; //save three elements whose sum = 0;\n        \tsort(nums.begin(), nums.end());\n            int temp_a=-1;int temp_b=-1; int temp_c = -1;\n\t        for (int i = 0; i < nums.size(); i++)\n            {\n                if (i!=0 &&nums[i] == nums[i-1])//avoid duplicate nums[i]\n                    continue;\n                int aa = nums[i];\n                int l = i+1; int r = nums.size()-1;//two pointer\n                while(l<r)\n                {\n                    int temp = aa+nums[l]+nums[r];\n                    if(temp == 0)\n                    {\n                        //avoid duplicate triplets\n                        if(temp_a != aa || temp_b != nums[l] || temp_c != nums[r])\n                        {\n                            temp_a=aa;\n                            temp_b=nums[l];\n                            temp_c=nums[r];\n                            vector<int>temp_sum;\n                            temp_sum.push_back(temp_a);\n                            temp_sum.push_back(temp_b);\n                            temp_sum.push_back(temp_c);\n                            sum.push_back(temp_sum);\n                            temp_sum.clear();\n                        }\n\t\t\t\t\t    l++;//move pointer\n\t\t\t\t\t    r--;\n                    }\n                    else if(temp < 0)//move pointer\n                            l++;\n                        else\n                            r--;\n                }\n            }\n        return sum;\n    }\n};\n```\n\n#### leetcode-11.Container With Most Water\n\nGiven *n* non-negative integers *a1*, *a2*, ..., *an*, where each represents a point at coordinate (*i*, *ai*). *n* vertical lines are drawn such that the two endpoints of line *i* is at (*i*, *ai*) and (*i*, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n\nNote: You may not slant the container and *n* is at least 2.\n\nNote:每个点之间的横坐标是等间隔的。要求出最大的容器，是由“短板”高来决定的和宽，所以这里采用双指针逼近法一开始将两个指针分别指向首和尾，然后逐渐向中间逼近求出最大容器。\n\n```c++\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int l = 0;\n        int r = height.size()-1;//two pointer\n        int ans = 0 ;\n        while(l < r)\n        {\n            int temp = (r-l)*min(height[l],height[r]);//calculating formula \n            if(temp > ans)\n                ans = temp;\n            if(height[l] == height[r])\n                if(height[r-1] > height[l+1])\n                    r--;//pointer move\n                else\n                    l++;\n            else if(height[l] < height[r])\n                    l++;\n                else\n                    r--;\n        }\n        return ans;\n    }\n};\n```\n\n---\n\n### 快速排序\n\n做完这两个题，使我快排的认识比以前认识更深了，因为快排中也用到类似的双指针逼近法。\n\n```c++\nvoid quick_sort(int a[], int l, int r)\n{\n\tif (l < r){\n\t\tint x = a[l];//chose a pivot\n\t\tint i = l; int j = r;//two pointer\n\t\twhile (i < j)\n\t\t{\n\t\t\twhile (i < j && x <= a[j])//find a number which is less than pivot\n\t\t\t\tj--;\n\t\t\tif (i<j)//find a number\n\t\t\t\ta[i] = a[j];\n\t\t\twhile (i < j && x > a[i])\n\t\t\t\ti++;\n\t\t\tif (i<j)\n\t\t\ta[j] = a[i];\t\t\n\t\t}\n\t\ta[i] = x;\n\t\tquick_sort(a, l, i - 1);\n\t\tquick_sort(a, i + 1, r); \n\t}\n}\n```\n\n[白话经典算法系列之六 快速排序 快速搞定](http://blog.csdn.net/morewindows/article/details/6684558)\n\n","source":"_posts/C++/两个指针在算法中的应用.md","raw":"---\nlayout: post\ntitle: \"双指针逼近法\"\ndate: 2017-09-11 19:58\ncomments: true\nreward: true\ntags: \n\t- leetcode\n\t- C++\n---\n\n#### 双指针逼近法：双指针相向夹逼，从两头开始向中间移动。\n\n#### leetcode-15.3Sum\n\nGiven an array *S* of *n* integers, are there elements *a*, *b*, *c* in *S* such that *a* + *b* + *c* = 0? Find all unique triplets in the array which gives the sum of zero.\n\n**Note:** The solution set must not contain duplicate triplets.\n\n```\nFor example, given array S = [-1, 0, 1, 2, -1, -4],\n\nA solution set is:\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n```\n\n题意：在给定的一个数组中找到三个之数为0的组合。\n\n<!--more--> \n\nNote：1.用暴力的方法，时间复杂度会达到O(n^3),用双指针逼近法将时间复杂度降到O(n^2)。\n\n​\t    2.三个数的组合中有相同的组合，要考虑到去除重复的。\n\n```C++\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        \n            vector<vector<int>> sum; //save three elements whose sum = 0;\n        \tsort(nums.begin(), nums.end());\n            int temp_a=-1;int temp_b=-1; int temp_c = -1;\n\t        for (int i = 0; i < nums.size(); i++)\n            {\n                if (i!=0 &&nums[i] == nums[i-1])//avoid duplicate nums[i]\n                    continue;\n                int aa = nums[i];\n                int l = i+1; int r = nums.size()-1;//two pointer\n                while(l<r)\n                {\n                    int temp = aa+nums[l]+nums[r];\n                    if(temp == 0)\n                    {\n                        //avoid duplicate triplets\n                        if(temp_a != aa || temp_b != nums[l] || temp_c != nums[r])\n                        {\n                            temp_a=aa;\n                            temp_b=nums[l];\n                            temp_c=nums[r];\n                            vector<int>temp_sum;\n                            temp_sum.push_back(temp_a);\n                            temp_sum.push_back(temp_b);\n                            temp_sum.push_back(temp_c);\n                            sum.push_back(temp_sum);\n                            temp_sum.clear();\n                        }\n\t\t\t\t\t    l++;//move pointer\n\t\t\t\t\t    r--;\n                    }\n                    else if(temp < 0)//move pointer\n                            l++;\n                        else\n                            r--;\n                }\n            }\n        return sum;\n    }\n};\n```\n\n#### leetcode-11.Container With Most Water\n\nGiven *n* non-negative integers *a1*, *a2*, ..., *an*, where each represents a point at coordinate (*i*, *ai*). *n* vertical lines are drawn such that the two endpoints of line *i* is at (*i*, *ai*) and (*i*, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n\nNote: You may not slant the container and *n* is at least 2.\n\nNote:每个点之间的横坐标是等间隔的。要求出最大的容器，是由“短板”高来决定的和宽，所以这里采用双指针逼近法一开始将两个指针分别指向首和尾，然后逐渐向中间逼近求出最大容器。\n\n```c++\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int l = 0;\n        int r = height.size()-1;//two pointer\n        int ans = 0 ;\n        while(l < r)\n        {\n            int temp = (r-l)*min(height[l],height[r]);//calculating formula \n            if(temp > ans)\n                ans = temp;\n            if(height[l] == height[r])\n                if(height[r-1] > height[l+1])\n                    r--;//pointer move\n                else\n                    l++;\n            else if(height[l] < height[r])\n                    l++;\n                else\n                    r--;\n        }\n        return ans;\n    }\n};\n```\n\n---\n\n### 快速排序\n\n做完这两个题，使我快排的认识比以前认识更深了，因为快排中也用到类似的双指针逼近法。\n\n```c++\nvoid quick_sort(int a[], int l, int r)\n{\n\tif (l < r){\n\t\tint x = a[l];//chose a pivot\n\t\tint i = l; int j = r;//two pointer\n\t\twhile (i < j)\n\t\t{\n\t\t\twhile (i < j && x <= a[j])//find a number which is less than pivot\n\t\t\t\tj--;\n\t\t\tif (i<j)//find a number\n\t\t\t\ta[i] = a[j];\n\t\t\twhile (i < j && x > a[i])\n\t\t\t\ti++;\n\t\t\tif (i<j)\n\t\t\ta[j] = a[i];\t\t\n\t\t}\n\t\ta[i] = x;\n\t\tquick_sort(a, l, i - 1);\n\t\tquick_sort(a, i + 1, r); \n\t}\n}\n```\n\n[白话经典算法系列之六 快速排序 快速搞定](http://blog.csdn.net/morewindows/article/details/6684558)\n\n","slug":"C++/两个指针在算法中的应用","published":1,"updated":"2020-08-09T05:24:13.278Z","photos":[],"link":"","_id":"ckdmsee7j001nlguw1hjc1akw","content":"<h4 id=\"双指针逼近法：双指针相向夹逼，从两头开始向中间移动。\"><a href=\"#双指针逼近法：双指针相向夹逼，从两头开始向中间移动。\" class=\"headerlink\" title=\"双指针逼近法：双指针相向夹逼，从两头开始向中间移动。\"></a>双指针逼近法：双指针相向夹逼，从两头开始向中间移动。</h4><h4 id=\"leetcode-15-3Sum\"><a href=\"#leetcode-15-3Sum\" class=\"headerlink\" title=\"leetcode-15.3Sum\"></a>leetcode-15.3Sum</h4><p>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <em>S</em> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>\n<p><strong>Note:</strong> The solution set must not contain duplicate triplets.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">For example, given array S = [-1, 0, 1, 2, -1, -4],</span><br><span class=\"line\"></span><br><span class=\"line\">A solution set is:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [-1, 0, 1],</span><br><span class=\"line\">  [-1, -1, 2]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>题意：在给定的一个数组中找到三个之数为0的组合。</p>\n<a id=\"more\"></a> \n<p>Note：1.用暴力的方法，时间复杂度会达到O(n^3),用双指针逼近法将时间复杂度降到O(n^2)。</p>\n<p>​        2.三个数的组合中有相同的组合，要考虑到去除重复的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; threeSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; sum; <span class=\"comment\">//save three elements whose sum = 0;</span></span><br><span class=\"line\">        \tsort(nums.begin(), nums.end());</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp_a=<span class=\"number\">-1</span>;<span class=\"keyword\">int</span> temp_b=<span class=\"number\">-1</span>; <span class=\"keyword\">int</span> temp_c = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i!=<span class=\"number\">0</span> &amp;&amp;nums[i] == nums[i<span class=\"number\">-1</span>])<span class=\"comment\">//avoid duplicate nums[i]</span></span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> aa = nums[i];</span><br><span class=\"line\">                <span class=\"keyword\">int</span> l = i+<span class=\"number\">1</span>; <span class=\"keyword\">int</span> r = nums.size()<span class=\"number\">-1</span>;<span class=\"comment\">//two pointer</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span>(l&lt;r)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> temp = aa+nums[l]+nums[r];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(temp == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//avoid duplicate triplets</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(temp_a != aa || temp_b != nums[l] || temp_c != nums[r])</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            temp_a=aa;</span><br><span class=\"line\">                            temp_b=nums[l];</span><br><span class=\"line\">                            temp_c=nums[r];</span><br><span class=\"line\">                            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;temp_sum;</span><br><span class=\"line\">                            temp_sum.push_back(temp_a);</span><br><span class=\"line\">                            temp_sum.push_back(temp_b);</span><br><span class=\"line\">                            temp_sum.push_back(temp_c);</span><br><span class=\"line\">                            sum.push_back(temp_sum);</span><br><span class=\"line\">                            temp_sum.clear();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">\t\t\t\t\t    l++;<span class=\"comment\">//move pointer</span></span><br><span class=\"line\">\t\t\t\t\t    r--;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(temp &lt; <span class=\"number\">0</span>)<span class=\"comment\">//move pointer</span></span><br><span class=\"line\">                            l++;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                            r--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"leetcode-11-Container-With-Most-Water\"><a href=\"#leetcode-11-Container-With-Most-Water\" class=\"headerlink\" title=\"leetcode-11.Container With Most Water\"></a>leetcode-11.Container With Most Water</h4><p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em>, where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>\n<p>Note: You may not slant the container and <em>n</em> is at least 2.</p>\n<p>Note:每个点之间的横坐标是等间隔的。要求出最大的容器，是由“短板”高来决定的和宽，所以这里采用双指针逼近法一开始将两个指针分别指向首和尾，然后逐渐向中间逼近求出最大容器。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = height.size()<span class=\"number\">-1</span>;<span class=\"comment\">//two pointer</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span> ;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = (r-l)*min(height[l],height[r]);<span class=\"comment\">//calculating formula </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(temp &gt; ans)</span><br><span class=\"line\">                ans = temp;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(height[l] == height[r])</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(height[r<span class=\"number\">-1</span>] &gt; height[l+<span class=\"number\">1</span>])</span><br><span class=\"line\">                    r--;<span class=\"comment\">//pointer move</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    l++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(height[l] &lt; height[r])</span><br><span class=\"line\">                    l++;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    r--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><p>做完这两个题，使我快排的认识比以前认识更深了，因为快排中也用到类似的双指针逼近法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quick_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l &lt; r)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x = a[l];<span class=\"comment\">//chose a pivot</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i = l; <span class=\"keyword\">int</span> j = r;<span class=\"comment\">//two pointer</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (i &lt; j)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (i &lt; j &amp;&amp; x &lt;= a[j])<span class=\"comment\">//find a number which is less than pivot</span></span><br><span class=\"line\">\t\t\t\tj--;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i&lt;j)<span class=\"comment\">//find a number</span></span><br><span class=\"line\">\t\t\t\ta[i] = a[j];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (i &lt; j &amp;&amp; x &gt; a[i])</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i&lt;j)</span><br><span class=\"line\">\t\t\ta[j] = a[i];\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ta[i] = x;</span><br><span class=\"line\">\t\tquick_sort(a, l, i - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tquick_sort(a, i + <span class=\"number\">1</span>, r); </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://blog.csdn.net/morewindows/article/details/6684558\" target=\"_blank\" rel=\"noopener\">白话经典算法系列之六 快速排序 快速搞定</a></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"双指针逼近法：双指针相向夹逼，从两头开始向中间移动。\"><a href=\"#双指针逼近法：双指针相向夹逼，从两头开始向中间移动。\" class=\"headerlink\" title=\"双指针逼近法：双指针相向夹逼，从两头开始向中间移动。\"></a>双指针逼近法：双指针相向夹逼，从两头开始向中间移动。</h4><h4 id=\"leetcode-15-3Sum\"><a href=\"#leetcode-15-3Sum\" class=\"headerlink\" title=\"leetcode-15.3Sum\"></a>leetcode-15.3Sum</h4><p>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <em>S</em> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>\n<p><strong>Note:</strong> The solution set must not contain duplicate triplets.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">For example, given array S = [-1, 0, 1, 2, -1, -4],</span><br><span class=\"line\"></span><br><span class=\"line\">A solution set is:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [-1, 0, 1],</span><br><span class=\"line\">  [-1, -1, 2]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>题意：在给定的一个数组中找到三个之数为0的组合。</p>","more":"<p>Note：1.用暴力的方法，时间复杂度会达到O(n^3),用双指针逼近法将时间复杂度降到O(n^2)。</p>\n<p>​        2.三个数的组合中有相同的组合，要考虑到去除重复的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; threeSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; sum; <span class=\"comment\">//save three elements whose sum = 0;</span></span><br><span class=\"line\">        \tsort(nums.begin(), nums.end());</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp_a=<span class=\"number\">-1</span>;<span class=\"keyword\">int</span> temp_b=<span class=\"number\">-1</span>; <span class=\"keyword\">int</span> temp_c = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i!=<span class=\"number\">0</span> &amp;&amp;nums[i] == nums[i<span class=\"number\">-1</span>])<span class=\"comment\">//avoid duplicate nums[i]</span></span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> aa = nums[i];</span><br><span class=\"line\">                <span class=\"keyword\">int</span> l = i+<span class=\"number\">1</span>; <span class=\"keyword\">int</span> r = nums.size()<span class=\"number\">-1</span>;<span class=\"comment\">//two pointer</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span>(l&lt;r)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> temp = aa+nums[l]+nums[r];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(temp == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//avoid duplicate triplets</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(temp_a != aa || temp_b != nums[l] || temp_c != nums[r])</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            temp_a=aa;</span><br><span class=\"line\">                            temp_b=nums[l];</span><br><span class=\"line\">                            temp_c=nums[r];</span><br><span class=\"line\">                            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;temp_sum;</span><br><span class=\"line\">                            temp_sum.push_back(temp_a);</span><br><span class=\"line\">                            temp_sum.push_back(temp_b);</span><br><span class=\"line\">                            temp_sum.push_back(temp_c);</span><br><span class=\"line\">                            sum.push_back(temp_sum);</span><br><span class=\"line\">                            temp_sum.clear();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">\t\t\t\t\t    l++;<span class=\"comment\">//move pointer</span></span><br><span class=\"line\">\t\t\t\t\t    r--;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(temp &lt; <span class=\"number\">0</span>)<span class=\"comment\">//move pointer</span></span><br><span class=\"line\">                            l++;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                            r--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"leetcode-11-Container-With-Most-Water\"><a href=\"#leetcode-11-Container-With-Most-Water\" class=\"headerlink\" title=\"leetcode-11.Container With Most Water\"></a>leetcode-11.Container With Most Water</h4><p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em>, where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>\n<p>Note: You may not slant the container and <em>n</em> is at least 2.</p>\n<p>Note:每个点之间的横坐标是等间隔的。要求出最大的容器，是由“短板”高来决定的和宽，所以这里采用双指针逼近法一开始将两个指针分别指向首和尾，然后逐渐向中间逼近求出最大容器。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = height.size()<span class=\"number\">-1</span>;<span class=\"comment\">//two pointer</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span> ;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = (r-l)*min(height[l],height[r]);<span class=\"comment\">//calculating formula </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(temp &gt; ans)</span><br><span class=\"line\">                ans = temp;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(height[l] == height[r])</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(height[r<span class=\"number\">-1</span>] &gt; height[l+<span class=\"number\">1</span>])</span><br><span class=\"line\">                    r--;<span class=\"comment\">//pointer move</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    l++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(height[l] &lt; height[r])</span><br><span class=\"line\">                    l++;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    r--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><p>做完这两个题，使我快排的认识比以前认识更深了，因为快排中也用到类似的双指针逼近法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quick_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l &lt; r)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x = a[l];<span class=\"comment\">//chose a pivot</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i = l; <span class=\"keyword\">int</span> j = r;<span class=\"comment\">//two pointer</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (i &lt; j)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (i &lt; j &amp;&amp; x &lt;= a[j])<span class=\"comment\">//find a number which is less than pivot</span></span><br><span class=\"line\">\t\t\t\tj--;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i&lt;j)<span class=\"comment\">//find a number</span></span><br><span class=\"line\">\t\t\t\ta[i] = a[j];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (i &lt; j &amp;&amp; x &gt; a[i])</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i&lt;j)</span><br><span class=\"line\">\t\t\ta[j] = a[i];\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ta[i] = x;</span><br><span class=\"line\">\t\tquick_sort(a, l, i - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tquick_sort(a, i + <span class=\"number\">1</span>, r); </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://blog.csdn.net/morewindows/article/details/6684558\" target=\"_blank\" rel=\"noopener\">白话经典算法系列之六 快速排序 快速搞定</a></p>"},{"layout":"post","title":"Matrix multiply","date":"2019-04-29T08:14:55.000Z","comments":1,"_content":"如果直接按矩阵乘法定义来计算的话需要MNP次乘法\n\n```c\nstruct matrix\n{\n    int a[2][2];\n};\nmatrix mul(matrix x,matrix y)\n{\n    matrix temp;\n    memset(temp.a,0,sizeof(temp.a));\n    for(int i=0;i<2;i++)\n        for(int j=0;j<2;j++)\n        for(int k=0;k<2;k++)\n        temp.a[i][j]=(temp.a[i][j]+x.a[i][k]*y.a[k][j])%M;\n    return temp;\n}\nmatrix mpow(matrix A,int n)\n{\n    matrix B;\n    memset(B.a,0,sizeof(B.a));\n    for(int i=0;i<2;i++)\n        B.a[i][i]=1;\n    while(n>0)\n    {\n        if(n&1)\n            B=mul(B,A);\n        A=mul(A,A);\n        n>>=1;\n    }\n    return B;\n}\n```\n\n<!--more--> \n\n## 有一个产生1~5的随机数，怎么产生1~7的随机数\n\n### 特殊：\n\n已知有个rand7()的函数，返回1到7随机自然数，怎样利用这个rand7()构造rand10()，随机1~10。产生随机数的主要原则是每个数出现的概率是相等的，如果可以得到一组等概率出现的数字，那么就可以从中找到映射为1~10的方法。rand7()返回1~7的自然数，构造新的函数 (rand7()-1)*7 + rand7()，这个函数会随机产生1~49的自然数。原因是1~49中的每个数只有唯一的第一个rand7()的值和第二个rand7()的值表示，于是它们出现的概率是相等。但是这里的数字太多，可以丢弃41~49的数字，把1~40的数字分成10组，每组映射成1~10中的一个，于是可以得到随机的结果。具体方法是，利用(rand7()-1)*7 + rand7()产生随机数x，如果大于40则继续随机直到小于等于40为止，如果小于等于40，则产生的随机数为(x-1)/4+1。\n\n### 一般：\n\n已知有个randM()的函数，返回1到M随机自然数，怎样利用这个randM()构造randN()，随机1~N。上题的扩展。当N<=M时可以直接得到。当N>M时，类似构造(randM()-1)*M + randM()，可以产生1~M^2（即randM^2），可以在M^2中选出N个构造1~N的映射。如果M^2还是没有N大，则可以对于randM^2继续构造，直到成功为止。","source":"_posts/C++/Matrix multiply.md","raw":"---\nlayout: post\ntitle: \"Matrix multiply\"\ndate: 2019-4-29 16:14:55\ncomments: true\ntags: \n\t- C++\n---\n如果直接按矩阵乘法定义来计算的话需要MNP次乘法\n\n```c\nstruct matrix\n{\n    int a[2][2];\n};\nmatrix mul(matrix x,matrix y)\n{\n    matrix temp;\n    memset(temp.a,0,sizeof(temp.a));\n    for(int i=0;i<2;i++)\n        for(int j=0;j<2;j++)\n        for(int k=0;k<2;k++)\n        temp.a[i][j]=(temp.a[i][j]+x.a[i][k]*y.a[k][j])%M;\n    return temp;\n}\nmatrix mpow(matrix A,int n)\n{\n    matrix B;\n    memset(B.a,0,sizeof(B.a));\n    for(int i=0;i<2;i++)\n        B.a[i][i]=1;\n    while(n>0)\n    {\n        if(n&1)\n            B=mul(B,A);\n        A=mul(A,A);\n        n>>=1;\n    }\n    return B;\n}\n```\n\n<!--more--> \n\n## 有一个产生1~5的随机数，怎么产生1~7的随机数\n\n### 特殊：\n\n已知有个rand7()的函数，返回1到7随机自然数，怎样利用这个rand7()构造rand10()，随机1~10。产生随机数的主要原则是每个数出现的概率是相等的，如果可以得到一组等概率出现的数字，那么就可以从中找到映射为1~10的方法。rand7()返回1~7的自然数，构造新的函数 (rand7()-1)*7 + rand7()，这个函数会随机产生1~49的自然数。原因是1~49中的每个数只有唯一的第一个rand7()的值和第二个rand7()的值表示，于是它们出现的概率是相等。但是这里的数字太多，可以丢弃41~49的数字，把1~40的数字分成10组，每组映射成1~10中的一个，于是可以得到随机的结果。具体方法是，利用(rand7()-1)*7 + rand7()产生随机数x，如果大于40则继续随机直到小于等于40为止，如果小于等于40，则产生的随机数为(x-1)/4+1。\n\n### 一般：\n\n已知有个randM()的函数，返回1到M随机自然数，怎样利用这个randM()构造randN()，随机1~N。上题的扩展。当N<=M时可以直接得到。当N>M时，类似构造(randM()-1)*M + randM()，可以产生1~M^2（即randM^2），可以在M^2中选出N个构造1~N的映射。如果M^2还是没有N大，则可以对于randM^2继续构造，直到成功为止。","slug":"C++/Matrix multiply","published":1,"updated":"2020-08-09T05:24:13.277Z","photos":[],"link":"","_id":"ckdmsee7l001olguwlu272rhf","content":"<p>如果直接按矩阵乘法定义来计算的话需要MNP次乘法</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">matrix</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a[<span class=\"number\">2</span>][<span class=\"number\">2</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\">matrix <span class=\"title\">mul</span><span class=\"params\">(matrix x,matrix y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    matrix temp;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(temp.a,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(temp.a));</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">2</span>;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">2</span>;j++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=<span class=\"number\">0</span>;k&lt;<span class=\"number\">2</span>;k++)</span><br><span class=\"line\">        temp.a[i][j]=(temp.a[i][j]+x.a[i][k]*y.a[k][j])%M;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">matrix <span class=\"title\">mpow</span><span class=\"params\">(matrix A,<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    matrix B;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(B.a,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(B.a));</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">2</span>;i++)</span><br><span class=\"line\">        B.a[i][i]=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n&amp;<span class=\"number\">1</span>)</span><br><span class=\"line\">            B=mul(B,A);</span><br><span class=\"line\">        A=mul(A,A);</span><br><span class=\"line\">        n&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> B;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a> \n<h2 id=\"有一个产生1-5的随机数，怎么产生1-7的随机数\"><a href=\"#有一个产生1-5的随机数，怎么产生1-7的随机数\" class=\"headerlink\" title=\"有一个产生1~5的随机数，怎么产生1~7的随机数\"></a>有一个产生1~5的随机数，怎么产生1~7的随机数</h2><h3 id=\"特殊：\"><a href=\"#特殊：\" class=\"headerlink\" title=\"特殊：\"></a>特殊：</h3><p>已知有个rand7()的函数，返回1到7随机自然数，怎样利用这个rand7()构造rand10()，随机1~10。产生随机数的主要原则是每个数出现的概率是相等的，如果可以得到一组等概率出现的数字，那么就可以从中找到映射为1~10的方法。rand7()返回1~7的自然数，构造新的函数 (rand7()-1)<em>7 + rand7()，这个函数会随机产生1~49的自然数。原因是1~49中的每个数只有唯一的第一个rand7()的值和第二个rand7()的值表示，于是它们出现的概率是相等。但是这里的数字太多，可以丢弃41~49的数字，把1~40的数字分成10组，每组映射成1~10中的一个，于是可以得到随机的结果。具体方法是，利用(rand7()-1)</em>7 + rand7()产生随机数x，如果大于40则继续随机直到小于等于40为止，如果小于等于40，则产生的随机数为(x-1)/4+1。</p>\n<h3 id=\"一般：\"><a href=\"#一般：\" class=\"headerlink\" title=\"一般：\"></a>一般：</h3><p>已知有个randM()的函数，返回1到M随机自然数，怎样利用这个randM()构造randN()，随机1~N。上题的扩展。当N&lt;=M时可以直接得到。当N&gt;M时，类似构造(randM()-1)*M + randM()，可以产生1~M^2（即randM^2），可以在M^2中选出N个构造1~N的映射。如果M^2还是没有N大，则可以对于randM^2继续构造，直到成功为止。</p>\n","site":{"data":{}},"excerpt":"<p>如果直接按矩阵乘法定义来计算的话需要MNP次乘法</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">matrix</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a[<span class=\"number\">2</span>][<span class=\"number\">2</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\">matrix <span class=\"title\">mul</span><span class=\"params\">(matrix x,matrix y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    matrix temp;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(temp.a,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(temp.a));</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">2</span>;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">2</span>;j++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=<span class=\"number\">0</span>;k&lt;<span class=\"number\">2</span>;k++)</span><br><span class=\"line\">        temp.a[i][j]=(temp.a[i][j]+x.a[i][k]*y.a[k][j])%M;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">matrix <span class=\"title\">mpow</span><span class=\"params\">(matrix A,<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    matrix B;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(B.a,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(B.a));</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">2</span>;i++)</span><br><span class=\"line\">        B.a[i][i]=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n&amp;<span class=\"number\">1</span>)</span><br><span class=\"line\">            B=mul(B,A);</span><br><span class=\"line\">        A=mul(A,A);</span><br><span class=\"line\">        n&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> B;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"有一个产生1-5的随机数，怎么产生1-7的随机数\"><a href=\"#有一个产生1-5的随机数，怎么产生1-7的随机数\" class=\"headerlink\" title=\"有一个产生1~5的随机数，怎么产生1~7的随机数\"></a>有一个产生1~5的随机数，怎么产生1~7的随机数</h2><h3 id=\"特殊：\"><a href=\"#特殊：\" class=\"headerlink\" title=\"特殊：\"></a>特殊：</h3><p>已知有个rand7()的函数，返回1到7随机自然数，怎样利用这个rand7()构造rand10()，随机1~10。产生随机数的主要原则是每个数出现的概率是相等的，如果可以得到一组等概率出现的数字，那么就可以从中找到映射为1~10的方法。rand7()返回1~7的自然数，构造新的函数 (rand7()-1)<em>7 + rand7()，这个函数会随机产生1~49的自然数。原因是1~49中的每个数只有唯一的第一个rand7()的值和第二个rand7()的值表示，于是它们出现的概率是相等。但是这里的数字太多，可以丢弃41~49的数字，把1~40的数字分成10组，每组映射成1~10中的一个，于是可以得到随机的结果。具体方法是，利用(rand7()-1)</em>7 + rand7()产生随机数x，如果大于40则继续随机直到小于等于40为止，如果小于等于40，则产生的随机数为(x-1)/4+1。</p>\n<h3 id=\"一般：\"><a href=\"#一般：\" class=\"headerlink\" title=\"一般：\"></a>一般：</h3><p>已知有个randM()的函数，返回1到M随机自然数，怎样利用这个randM()构造randN()，随机1~N。上题的扩展。当N&lt;=M时可以直接得到。当N&gt;M时，类似构造(randM()-1)*M + randM()，可以产生1~M^2（即randM^2），可以在M^2中选出N个构造1~N的映射。如果M^2还是没有N大，则可以对于randM^2继续构造，直到成功为止。</p>"},{"layout":"post","title":"C++笔面试题目","date":"2017-09-18T08:42:00.000Z","comments":1,"reward":true,"_content":"\n### 1.函数指针\n\na.获取函数地址\n\n```c++\nprocess(think);//passes address of think() to process()\nthought(think);//passes return value of think to thought()\n```\n\n<!--more--> \n\nb.声明函数指针\n\n```C++\ndouble pam(int);//prototype\ndouble (*pf)(int);//pf points to a function that takes\n\t\t\t\t//one int argument and that \n\t\t\t\t//return type double\npf = pam;//pf now points to the pam() function\n```\n\n为提供正确的运算符优先级，必须在声明中使用括号将* pf括起。括号的优先级比*运算符高。\n\n```c++\ndouble (*pf)(int);//pf points to a function that returns double\ndouble *pf(int); //pf() a function that return a pointer-to-double\n```\n\n注意，pam()的参数列表和返回类型必须与pf相同。如果不相同，编译器将拒绝这种赋值：\n\n```c++\ndouble ned(double);\nint ted(int);\ndouble (*pf)(int);\npf = ned;//invalid -- mismatched signature\npf = ted;//invalid -- mismatched return type\n```\n\nc.使用指针来调用函数\n\n```c++\ndouble pam(int);//prototype\ndouble (*pf)(int);//pf points to a function that takes\n\t\t\t\t//one int argument and that \n\t\t\t\t//return type double\npf = pam;//pf now points to the pam() function\ndouble x = pam(4);//call pam() using the function name\ndouble y = (*pf)(5);//call pam() using the pointer pf\ndouble y = pf(5);//also call pam() using the pointer pf\n```\n\n### 2.虚函数工作原理：\n\n编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表(virtual function table，vtbl)。**虚函数表中存储了为类对象进行声明的虚函数地址。**\n\n![image](https://wx2.sinaimg.cn/large/aacc02d8ly1fxvoewmi1hj20rp0ludnv.jpg)\n\n### 3.**结构体内存对齐**\n\n#### **1.什么是内存对齐**\n\n#### 假设我们同时声明两个变量：char a;short b;用&（取地址符号）观察变量a，b的地址的话，我们会发现（以16位CPU为例）：如果a的地址是0x0000，那么b的地址将会是0x0002或者是0x0004。那么就出现这样一个问题：0x0001这个地址没有被使用，那它干什么去了？ 答案就是它确实没被使用。 因为CPU每次都是从以2字节（16位CPU）或是4字节（32位CPU）的整数倍的内存地址中读进数据的。如果变量b的地址是0x0001的话，那么CPU就需要先从0x0000中读取一个short，取它的高8位放入b的低8位，然后再从0x0002中读取下一个short，取它的低8位放入b的高8位中，这样的话，为了获得b的值，CPU需要进行了两次读操作。\n\n但是如果b的地址为0x0002，那么CPU只需一次读操作就可以获得b的值了。**所以编译器为了优化代码，往往会根据变量的大小，将其指定到合适的位置，即称为内存对齐（对变量b做内存对齐，a、b之间的内存被浪费，a并未多占内存）。**\n\n#### **2.结构体内存对齐规则（请记住三条内存规则(在没有#pragam pack宏的情况下）**\n\n结构体所占用的内存与其成员在结构体中的声明顺序有关，其成员的内存对齐规则如下：\n\n（1）每个成员分别按自己的对齐字节数和PPB（指定的对齐字节数，32位机默认为4）两个字节数最小的那个对齐，这样可以最小化长度。如在32bit的机器上，int的大小为4，因此int存储的位置都是4的整数倍的位置开始存储。\n\n（2）复杂类型(如结构)的默认对齐方式是它最长的成员的对齐方式，这样在成员是复杂类型时，结构体数组的时候，可以最小化长度。\n\n（3）结构体对齐后的长度必须是成员中最大的对齐参数（PPB）的整数倍，这样在处理数组时可以保证每一项都边界对齐。 \n\n（4）结构体作为数据成员的对齐规则：在一个struct中包含另一个struct，内部struct应该以它的最大数据成员大小的整数倍开始存储。如 struct A 中包含 struct B, struct B 中包含数据成员 char, int, double，则 struct B 应该以sizeof(double)=8的整数倍为起始地址。\n\n#### **3.实例演示：**\n\n```c++\nstruct A\n{\nchar a;　　　//内存位置:  [0]\ndouble b;　  // 内存位置: [8]...[15]\nint c;　　　　// 内存位置: [16]...[19]　　----　　规则1\n};　　　　　　　 // 内存大小：sizeof(A) = (1+7) + 8 + (4+4) = 24, 补齐[20]...[23]　　----　　规则3\n\nstruct B\n{\nint a,　　　　// 内存位置: [0]...[3]\nA b,　    　　// 内存位置: [8]...[31]　　----　　规则2\nchar c,　　　// 内存位置: [32]\n};　　　　　　　  // 内存大小：sizeof(B) = (4+4) + 24 + (1+7) = 40, 补齐[33]...[39]\n```\n\n*注释：(1+7)表示该数据成员大小为1，补齐7位；(4+4)同理。","source":"_posts/C++/C++笔面试题目.md","raw":"---\nlayout: post\ntitle: \"C++笔面试题目\"\ndate: 2017-09-18 16:42\ncomments: true\nreward: true\ntags: \n\t- C++\n---\n\n### 1.函数指针\n\na.获取函数地址\n\n```c++\nprocess(think);//passes address of think() to process()\nthought(think);//passes return value of think to thought()\n```\n\n<!--more--> \n\nb.声明函数指针\n\n```C++\ndouble pam(int);//prototype\ndouble (*pf)(int);//pf points to a function that takes\n\t\t\t\t//one int argument and that \n\t\t\t\t//return type double\npf = pam;//pf now points to the pam() function\n```\n\n为提供正确的运算符优先级，必须在声明中使用括号将* pf括起。括号的优先级比*运算符高。\n\n```c++\ndouble (*pf)(int);//pf points to a function that returns double\ndouble *pf(int); //pf() a function that return a pointer-to-double\n```\n\n注意，pam()的参数列表和返回类型必须与pf相同。如果不相同，编译器将拒绝这种赋值：\n\n```c++\ndouble ned(double);\nint ted(int);\ndouble (*pf)(int);\npf = ned;//invalid -- mismatched signature\npf = ted;//invalid -- mismatched return type\n```\n\nc.使用指针来调用函数\n\n```c++\ndouble pam(int);//prototype\ndouble (*pf)(int);//pf points to a function that takes\n\t\t\t\t//one int argument and that \n\t\t\t\t//return type double\npf = pam;//pf now points to the pam() function\ndouble x = pam(4);//call pam() using the function name\ndouble y = (*pf)(5);//call pam() using the pointer pf\ndouble y = pf(5);//also call pam() using the pointer pf\n```\n\n### 2.虚函数工作原理：\n\n编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表(virtual function table，vtbl)。**虚函数表中存储了为类对象进行声明的虚函数地址。**\n\n![image](https://wx2.sinaimg.cn/large/aacc02d8ly1fxvoewmi1hj20rp0ludnv.jpg)\n\n### 3.**结构体内存对齐**\n\n#### **1.什么是内存对齐**\n\n#### 假设我们同时声明两个变量：char a;short b;用&（取地址符号）观察变量a，b的地址的话，我们会发现（以16位CPU为例）：如果a的地址是0x0000，那么b的地址将会是0x0002或者是0x0004。那么就出现这样一个问题：0x0001这个地址没有被使用，那它干什么去了？ 答案就是它确实没被使用。 因为CPU每次都是从以2字节（16位CPU）或是4字节（32位CPU）的整数倍的内存地址中读进数据的。如果变量b的地址是0x0001的话，那么CPU就需要先从0x0000中读取一个short，取它的高8位放入b的低8位，然后再从0x0002中读取下一个short，取它的低8位放入b的高8位中，这样的话，为了获得b的值，CPU需要进行了两次读操作。\n\n但是如果b的地址为0x0002，那么CPU只需一次读操作就可以获得b的值了。**所以编译器为了优化代码，往往会根据变量的大小，将其指定到合适的位置，即称为内存对齐（对变量b做内存对齐，a、b之间的内存被浪费，a并未多占内存）。**\n\n#### **2.结构体内存对齐规则（请记住三条内存规则(在没有#pragam pack宏的情况下）**\n\n结构体所占用的内存与其成员在结构体中的声明顺序有关，其成员的内存对齐规则如下：\n\n（1）每个成员分别按自己的对齐字节数和PPB（指定的对齐字节数，32位机默认为4）两个字节数最小的那个对齐，这样可以最小化长度。如在32bit的机器上，int的大小为4，因此int存储的位置都是4的整数倍的位置开始存储。\n\n（2）复杂类型(如结构)的默认对齐方式是它最长的成员的对齐方式，这样在成员是复杂类型时，结构体数组的时候，可以最小化长度。\n\n（3）结构体对齐后的长度必须是成员中最大的对齐参数（PPB）的整数倍，这样在处理数组时可以保证每一项都边界对齐。 \n\n（4）结构体作为数据成员的对齐规则：在一个struct中包含另一个struct，内部struct应该以它的最大数据成员大小的整数倍开始存储。如 struct A 中包含 struct B, struct B 中包含数据成员 char, int, double，则 struct B 应该以sizeof(double)=8的整数倍为起始地址。\n\n#### **3.实例演示：**\n\n```c++\nstruct A\n{\nchar a;　　　//内存位置:  [0]\ndouble b;　  // 内存位置: [8]...[15]\nint c;　　　　// 内存位置: [16]...[19]　　----　　规则1\n};　　　　　　　 // 内存大小：sizeof(A) = (1+7) + 8 + (4+4) = 24, 补齐[20]...[23]　　----　　规则3\n\nstruct B\n{\nint a,　　　　// 内存位置: [0]...[3]\nA b,　    　　// 内存位置: [8]...[31]　　----　　规则2\nchar c,　　　// 内存位置: [32]\n};　　　　　　　  // 内存大小：sizeof(B) = (4+4) + 24 + (1+7) = 40, 补齐[33]...[39]\n```\n\n*注释：(1+7)表示该数据成员大小为1，补齐7位；(4+4)同理。","slug":"C++/C++笔面试题目","published":1,"updated":"2020-08-09T05:24:13.277Z","photos":[],"link":"","_id":"ckdmsee7p001qlguwlqzfbsc7","content":"<h3 id=\"1-函数指针\"><a href=\"#1-函数指针\" class=\"headerlink\" title=\"1.函数指针\"></a>1.函数指针</h3><p>a.获取函数地址</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process(think);<span class=\"comment\">//passes address of think() to process()</span></span><br><span class=\"line\">thought(think);<span class=\"comment\">//passes return value of think to thought()</span></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a> \n<p>b.声明函数指针</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">pam</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;<span class=\"comment\">//prototype</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> (*pf)(<span class=\"keyword\">int</span>);<span class=\"comment\">//pf points to a function that takes</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//one int argument and that </span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//return type double</span></span><br><span class=\"line\">pf = pam;<span class=\"comment\">//pf now points to the pam() function</span></span><br></pre></td></tr></table></figure>\n<p>为提供正确的运算符优先级，必须在声明中使用括号将<em> pf括起。括号的优先级比</em>运算符高。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> (*pf)(<span class=\"keyword\">int</span>);<span class=\"comment\">//pf points to a function that returns double</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> *<span class=\"title\">pf</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>; <span class=\"comment\">//pf() a function that return a pointer-to-double</span></span><br></pre></td></tr></table></figure>\n<p>注意，pam()的参数列表和返回类型必须与pf相同。如果不相同，编译器将拒绝这种赋值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">ned</span><span class=\"params\">(<span class=\"keyword\">double</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ted</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">double</span> (*pf)(<span class=\"keyword\">int</span>);</span><br><span class=\"line\">pf = ned;<span class=\"comment\">//invalid -- mismatched signature</span></span><br><span class=\"line\">pf = ted;<span class=\"comment\">//invalid -- mismatched return type</span></span><br></pre></td></tr></table></figure>\n<p>c.使用指针来调用函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">pam</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;<span class=\"comment\">//prototype</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> (*pf)(<span class=\"keyword\">int</span>);<span class=\"comment\">//pf points to a function that takes</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//one int argument and that </span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//return type double</span></span><br><span class=\"line\">pf = pam;<span class=\"comment\">//pf now points to the pam() function</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> x = pam(<span class=\"number\">4</span>);<span class=\"comment\">//call pam() using the function name</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> y = (*pf)(<span class=\"number\">5</span>);<span class=\"comment\">//call pam() using the pointer pf</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> y = pf(<span class=\"number\">5</span>);<span class=\"comment\">//also call pam() using the pointer pf</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-虚函数工作原理：\"><a href=\"#2-虚函数工作原理：\" class=\"headerlink\" title=\"2.虚函数工作原理：\"></a>2.虚函数工作原理：</h3><p>编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表(virtual function table，vtbl)。<strong>虚函数表中存储了为类对象进行声明的虚函数地址。</strong></p>\n<p><img src=\"https://wx2.sinaimg.cn/large/aacc02d8ly1fxvoewmi1hj20rp0ludnv.jpg\" alt=\"image\"></p>\n<h3 id=\"3-结构体内存对齐\"><a href=\"#3-结构体内存对齐\" class=\"headerlink\" title=\"3.结构体内存对齐\"></a>3.<strong>结构体内存对齐</strong></h3><h4 id=\"1-什么是内存对齐\"><a href=\"#1-什么是内存对齐\" class=\"headerlink\" title=\"1.什么是内存对齐\"></a><strong>1.什么是内存对齐</strong></h4><h4 id=\"假设我们同时声明两个变量：char-a-short-b-用-amp-（取地址符号）观察变量a，b的地址的话，我们会发现（以16位CPU为例）：如果a的地址是0x0000，那么b的地址将会是0x0002或者是0x0004。那么就出现这样一个问题：0x0001这个地址没有被使用，那它干什么去了？-答案就是它确实没被使用。-因为CPU每次都是从以2字节（16位CPU）或是4字节（32位CPU）的整数倍的内存地址中读进数据的。如果变量b的地址是0x0001的话，那么CPU就需要先从0x0000中读取一个short，取它的高8位放入b的低8位，然后再从0x0002中读取下一个short，取它的低8位放入b的高8位中，这样的话，为了获得b的值，CPU需要进行了两次读操作。\"><a href=\"#假设我们同时声明两个变量：char-a-short-b-用-amp-（取地址符号）观察变量a，b的地址的话，我们会发现（以16位CPU为例）：如果a的地址是0x0000，那么b的地址将会是0x0002或者是0x0004。那么就出现这样一个问题：0x0001这个地址没有被使用，那它干什么去了？-答案就是它确实没被使用。-因为CPU每次都是从以2字节（16位CPU）或是4字节（32位CPU）的整数倍的内存地址中读进数据的。如果变量b的地址是0x0001的话，那么CPU就需要先从0x0000中读取一个short，取它的高8位放入b的低8位，然后再从0x0002中读取下一个short，取它的低8位放入b的高8位中，这样的话，为了获得b的值，CPU需要进行了两次读操作。\" class=\"headerlink\" title=\"假设我们同时声明两个变量：char a;short b;用&amp;（取地址符号）观察变量a，b的地址的话，我们会发现（以16位CPU为例）：如果a的地址是0x0000，那么b的地址将会是0x0002或者是0x0004。那么就出现这样一个问题：0x0001这个地址没有被使用，那它干什么去了？ 答案就是它确实没被使用。 因为CPU每次都是从以2字节（16位CPU）或是4字节（32位CPU）的整数倍的内存地址中读进数据的。如果变量b的地址是0x0001的话，那么CPU就需要先从0x0000中读取一个short，取它的高8位放入b的低8位，然后再从0x0002中读取下一个short，取它的低8位放入b的高8位中，这样的话，为了获得b的值，CPU需要进行了两次读操作。\"></a>假设我们同时声明两个变量：char a;short b;用&amp;（取地址符号）观察变量a，b的地址的话，我们会发现（以16位CPU为例）：如果a的地址是0x0000，那么b的地址将会是0x0002或者是0x0004。那么就出现这样一个问题：0x0001这个地址没有被使用，那它干什么去了？ 答案就是它确实没被使用。 因为CPU每次都是从以2字节（16位CPU）或是4字节（32位CPU）的整数倍的内存地址中读进数据的。如果变量b的地址是0x0001的话，那么CPU就需要先从0x0000中读取一个short，取它的高8位放入b的低8位，然后再从0x0002中读取下一个short，取它的低8位放入b的高8位中，这样的话，为了获得b的值，CPU需要进行了两次读操作。</h4><p>但是如果b的地址为0x0002，那么CPU只需一次读操作就可以获得b的值了。<strong>所以编译器为了优化代码，往往会根据变量的大小，将其指定到合适的位置，即称为内存对齐（对变量b做内存对齐，a、b之间的内存被浪费，a并未多占内存）。</strong></p>\n<h4 id=\"2-结构体内存对齐规则（请记住三条内存规则-在没有-pragam-pack宏的情况下）\"><a href=\"#2-结构体内存对齐规则（请记住三条内存规则-在没有-pragam-pack宏的情况下）\" class=\"headerlink\" title=\"2.结构体内存对齐规则（请记住三条内存规则(在没有#pragam pack宏的情况下）\"></a><strong>2.结构体内存对齐规则（请记住三条内存规则(在没有#pragam pack宏的情况下）</strong></h4><p>结构体所占用的内存与其成员在结构体中的声明顺序有关，其成员的内存对齐规则如下：</p>\n<p>（1）每个成员分别按自己的对齐字节数和PPB（指定的对齐字节数，32位机默认为4）两个字节数最小的那个对齐，这样可以最小化长度。如在32bit的机器上，int的大小为4，因此int存储的位置都是4的整数倍的位置开始存储。</p>\n<p>（2）复杂类型(如结构)的默认对齐方式是它最长的成员的对齐方式，这样在成员是复杂类型时，结构体数组的时候，可以最小化长度。</p>\n<p>（3）结构体对齐后的长度必须是成员中最大的对齐参数（PPB）的整数倍，这样在处理数组时可以保证每一项都边界对齐。 </p>\n<p>（4）结构体作为数据成员的对齐规则：在一个struct中包含另一个struct，内部struct应该以它的最大数据成员大小的整数倍开始存储。如 struct A 中包含 struct B, struct B 中包含数据成员 char, int, double，则 struct B 应该以sizeof(double)=8的整数倍为起始地址。</p>\n<h4 id=\"3-实例演示：\"><a href=\"#3-实例演示：\" class=\"headerlink\" title=\"3.实例演示：\"></a><strong>3.实例演示：</strong></h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> a;　　　<span class=\"comment\">//内存位置:  [0]</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> b;　  <span class=\"comment\">// 内存位置: [8]...[15]</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> c;　　　　<span class=\"comment\">// 内存位置: [16]...[19]　　----　　规则1</span></span><br><span class=\"line\">&#125;;　　　　　　　 <span class=\"comment\">// 内存大小：sizeof(A) = (1+7) + 8 + (4+4) = 24, 补齐[20]...[23]　　----　　规则3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a,　　　　<span class=\"comment\">// 内存位置: [0]...[3]</span></span><br><span class=\"line\">A b,　    　　<span class=\"comment\">// 内存位置: [8]...[31]　　----　　规则2</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> c,　　　<span class=\"comment\">// 内存位置: [32]</span></span><br><span class=\"line\">&#125;;　　　　　　　  <span class=\"comment\">// 内存大小：sizeof(B) = (4+4) + 24 + (1+7) = 40, 补齐[33]...[39]</span></span><br></pre></td></tr></table></figure>\n<p>*注释：(1+7)表示该数据成员大小为1，补齐7位；(4+4)同理。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-函数指针\"><a href=\"#1-函数指针\" class=\"headerlink\" title=\"1.函数指针\"></a>1.函数指针</h3><p>a.获取函数地址</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process(think);<span class=\"comment\">//passes address of think() to process()</span></span><br><span class=\"line\">thought(think);<span class=\"comment\">//passes return value of think to thought()</span></span><br></pre></td></tr></table></figure>","more":"<p>b.声明函数指针</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">pam</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;<span class=\"comment\">//prototype</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> (*pf)(<span class=\"keyword\">int</span>);<span class=\"comment\">//pf points to a function that takes</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//one int argument and that </span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//return type double</span></span><br><span class=\"line\">pf = pam;<span class=\"comment\">//pf now points to the pam() function</span></span><br></pre></td></tr></table></figure>\n<p>为提供正确的运算符优先级，必须在声明中使用括号将<em> pf括起。括号的优先级比</em>运算符高。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> (*pf)(<span class=\"keyword\">int</span>);<span class=\"comment\">//pf points to a function that returns double</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> *<span class=\"title\">pf</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>; <span class=\"comment\">//pf() a function that return a pointer-to-double</span></span><br></pre></td></tr></table></figure>\n<p>注意，pam()的参数列表和返回类型必须与pf相同。如果不相同，编译器将拒绝这种赋值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">ned</span><span class=\"params\">(<span class=\"keyword\">double</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ted</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">double</span> (*pf)(<span class=\"keyword\">int</span>);</span><br><span class=\"line\">pf = ned;<span class=\"comment\">//invalid -- mismatched signature</span></span><br><span class=\"line\">pf = ted;<span class=\"comment\">//invalid -- mismatched return type</span></span><br></pre></td></tr></table></figure>\n<p>c.使用指针来调用函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">pam</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;<span class=\"comment\">//prototype</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> (*pf)(<span class=\"keyword\">int</span>);<span class=\"comment\">//pf points to a function that takes</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//one int argument and that </span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//return type double</span></span><br><span class=\"line\">pf = pam;<span class=\"comment\">//pf now points to the pam() function</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> x = pam(<span class=\"number\">4</span>);<span class=\"comment\">//call pam() using the function name</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> y = (*pf)(<span class=\"number\">5</span>);<span class=\"comment\">//call pam() using the pointer pf</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> y = pf(<span class=\"number\">5</span>);<span class=\"comment\">//also call pam() using the pointer pf</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-虚函数工作原理：\"><a href=\"#2-虚函数工作原理：\" class=\"headerlink\" title=\"2.虚函数工作原理：\"></a>2.虚函数工作原理：</h3><p>编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表(virtual function table，vtbl)。<strong>虚函数表中存储了为类对象进行声明的虚函数地址。</strong></p>\n<p><img src=\"https://wx2.sinaimg.cn/large/aacc02d8ly1fxvoewmi1hj20rp0ludnv.jpg\" alt=\"image\"></p>\n<h3 id=\"3-结构体内存对齐\"><a href=\"#3-结构体内存对齐\" class=\"headerlink\" title=\"3.结构体内存对齐\"></a>3.<strong>结构体内存对齐</strong></h3><h4 id=\"1-什么是内存对齐\"><a href=\"#1-什么是内存对齐\" class=\"headerlink\" title=\"1.什么是内存对齐\"></a><strong>1.什么是内存对齐</strong></h4><h4 id=\"假设我们同时声明两个变量：char-a-short-b-用-amp-（取地址符号）观察变量a，b的地址的话，我们会发现（以16位CPU为例）：如果a的地址是0x0000，那么b的地址将会是0x0002或者是0x0004。那么就出现这样一个问题：0x0001这个地址没有被使用，那它干什么去了？-答案就是它确实没被使用。-因为CPU每次都是从以2字节（16位CPU）或是4字节（32位CPU）的整数倍的内存地址中读进数据的。如果变量b的地址是0x0001的话，那么CPU就需要先从0x0000中读取一个short，取它的高8位放入b的低8位，然后再从0x0002中读取下一个short，取它的低8位放入b的高8位中，这样的话，为了获得b的值，CPU需要进行了两次读操作。\"><a href=\"#假设我们同时声明两个变量：char-a-short-b-用-amp-（取地址符号）观察变量a，b的地址的话，我们会发现（以16位CPU为例）：如果a的地址是0x0000，那么b的地址将会是0x0002或者是0x0004。那么就出现这样一个问题：0x0001这个地址没有被使用，那它干什么去了？-答案就是它确实没被使用。-因为CPU每次都是从以2字节（16位CPU）或是4字节（32位CPU）的整数倍的内存地址中读进数据的。如果变量b的地址是0x0001的话，那么CPU就需要先从0x0000中读取一个short，取它的高8位放入b的低8位，然后再从0x0002中读取下一个short，取它的低8位放入b的高8位中，这样的话，为了获得b的值，CPU需要进行了两次读操作。\" class=\"headerlink\" title=\"假设我们同时声明两个变量：char a;short b;用&amp;（取地址符号）观察变量a，b的地址的话，我们会发现（以16位CPU为例）：如果a的地址是0x0000，那么b的地址将会是0x0002或者是0x0004。那么就出现这样一个问题：0x0001这个地址没有被使用，那它干什么去了？ 答案就是它确实没被使用。 因为CPU每次都是从以2字节（16位CPU）或是4字节（32位CPU）的整数倍的内存地址中读进数据的。如果变量b的地址是0x0001的话，那么CPU就需要先从0x0000中读取一个short，取它的高8位放入b的低8位，然后再从0x0002中读取下一个short，取它的低8位放入b的高8位中，这样的话，为了获得b的值，CPU需要进行了两次读操作。\"></a>假设我们同时声明两个变量：char a;short b;用&amp;（取地址符号）观察变量a，b的地址的话，我们会发现（以16位CPU为例）：如果a的地址是0x0000，那么b的地址将会是0x0002或者是0x0004。那么就出现这样一个问题：0x0001这个地址没有被使用，那它干什么去了？ 答案就是它确实没被使用。 因为CPU每次都是从以2字节（16位CPU）或是4字节（32位CPU）的整数倍的内存地址中读进数据的。如果变量b的地址是0x0001的话，那么CPU就需要先从0x0000中读取一个short，取它的高8位放入b的低8位，然后再从0x0002中读取下一个short，取它的低8位放入b的高8位中，这样的话，为了获得b的值，CPU需要进行了两次读操作。</h4><p>但是如果b的地址为0x0002，那么CPU只需一次读操作就可以获得b的值了。<strong>所以编译器为了优化代码，往往会根据变量的大小，将其指定到合适的位置，即称为内存对齐（对变量b做内存对齐，a、b之间的内存被浪费，a并未多占内存）。</strong></p>\n<h4 id=\"2-结构体内存对齐规则（请记住三条内存规则-在没有-pragam-pack宏的情况下）\"><a href=\"#2-结构体内存对齐规则（请记住三条内存规则-在没有-pragam-pack宏的情况下）\" class=\"headerlink\" title=\"2.结构体内存对齐规则（请记住三条内存规则(在没有#pragam pack宏的情况下）\"></a><strong>2.结构体内存对齐规则（请记住三条内存规则(在没有#pragam pack宏的情况下）</strong></h4><p>结构体所占用的内存与其成员在结构体中的声明顺序有关，其成员的内存对齐规则如下：</p>\n<p>（1）每个成员分别按自己的对齐字节数和PPB（指定的对齐字节数，32位机默认为4）两个字节数最小的那个对齐，这样可以最小化长度。如在32bit的机器上，int的大小为4，因此int存储的位置都是4的整数倍的位置开始存储。</p>\n<p>（2）复杂类型(如结构)的默认对齐方式是它最长的成员的对齐方式，这样在成员是复杂类型时，结构体数组的时候，可以最小化长度。</p>\n<p>（3）结构体对齐后的长度必须是成员中最大的对齐参数（PPB）的整数倍，这样在处理数组时可以保证每一项都边界对齐。 </p>\n<p>（4）结构体作为数据成员的对齐规则：在一个struct中包含另一个struct，内部struct应该以它的最大数据成员大小的整数倍开始存储。如 struct A 中包含 struct B, struct B 中包含数据成员 char, int, double，则 struct B 应该以sizeof(double)=8的整数倍为起始地址。</p>\n<h4 id=\"3-实例演示：\"><a href=\"#3-实例演示：\" class=\"headerlink\" title=\"3.实例演示：\"></a><strong>3.实例演示：</strong></h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> a;　　　<span class=\"comment\">//内存位置:  [0]</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> b;　  <span class=\"comment\">// 内存位置: [8]...[15]</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> c;　　　　<span class=\"comment\">// 内存位置: [16]...[19]　　----　　规则1</span></span><br><span class=\"line\">&#125;;　　　　　　　 <span class=\"comment\">// 内存大小：sizeof(A) = (1+7) + 8 + (4+4) = 24, 补齐[20]...[23]　　----　　规则3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a,　　　　<span class=\"comment\">// 内存位置: [0]...[3]</span></span><br><span class=\"line\">A b,　    　　<span class=\"comment\">// 内存位置: [8]...[31]　　----　　规则2</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> c,　　　<span class=\"comment\">// 内存位置: [32]</span></span><br><span class=\"line\">&#125;;　　　　　　　  <span class=\"comment\">// 内存大小：sizeof(B) = (4+4) + 24 + (1+7) = 40, 补齐[33]...[39]</span></span><br></pre></td></tr></table></figure>\n<p>*注释：(1+7)表示该数据成员大小为1，补齐7位；(4+4)同理。</p>"},{"layout":"post","title":"20190507深入学习","date":"2019-05-07T10:03:11.000Z","comments":1,"_content":"1. HashMap,ArrayList,LinkList,ConcurrentMap集合的底层原理。\n\n  转自：<https://juejin.im/post/5aa5d8d26fb9a028d2079264#heading-23>\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1g2svpceo2gj20lx0jzgmd.jpg)\n\n<!-- more -->\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1g2svq2ia0yj20tq1cmju9.jpg)\n\n2. 创建线程的几种方式？线程池有什么好处？线程池是怎么创建的？\n  使用ThreadPoolExecutor创建，线程池的原理\n\n  ```java\n  package com.differ.jackyun.oms.common.task;\n  \n  import java.util.concurrent.LinkedBlockingQueue;\n  import java.util.concurrent.RejectedExecutionHandler;\n  import java.util.concurrent.ThreadFactory;\n  import java.util.concurrent.ThreadPoolExecutor;\n  import java.util.concurrent.TimeUnit;\n  import java.util.concurrent.atomic.AtomicInteger;\n  \n  import org.springframework.core.task.TaskRejectedException;\n  \n  /**\n   * 通用线程池任务处理执行器\n   * \n   * @since 2018年5月16日 下午1:32:01\n   * @author yly\n   *\n   */\n  public class HandleTaskExecutor {\n      \n      /**\n       * 核心线程大小\n       */\n      private static int CORE_POOL_SIZE = 8;\n      /**\n       * 线程池最大线程数\n       */\n      private static int MAX_POOL_SIZE = 64;\n      /**\n       * 额外线程空状态生存时间\n       */\n      private static int KEEP_ALIVE_TIME = 30 * 1000;\n      /**\n       * 队列大小\n       */\n      private static int MAX_QUEUE_SIZE = 30000;\n      \n      private HandleTaskExecutor(){}\n      private static class TmcHandleTaskExecutorHolder{\n          static HandleTaskExecutor me = new HandleTaskExecutor();\n      }\n      \n      /**\n       * 拿到执行器实例\n       * @return\n       */\n      public static HandleTaskExecutor me() {\n          return TmcHandleTaskExecutorHolder.me;\n      }\n      \n      /**\n       * 线程池\n       */\n      private static ThreadPoolExecutor THREAD_POOL = new ThreadPoolExecutor(CORE_POOL_SIZE, MAX_POOL_SIZE, KEEP_ALIVE_TIME, \n                  TimeUnit.MICROSECONDS, new LinkedBlockingQueue<Runnable>(MAX_QUEUE_SIZE),\n              new ThreadFactory() {\n  \n                  private final AtomicInteger index = new AtomicInteger();\n                  @Override\n                  public Thread newThread(Runnable r) {\n                      String threadName = \"任务处理线程[HandleTaskExecutor]-\" + (null != r ? r.getClass().getSimpleName() : \"\") + \"#\" + index.getAndIncrement();\n                      return new Thread(r, threadName);\n                  }\n  \n              }, new RejectedExecutionHandler() {\n  \n                  @Override\n                  public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {\n                      // 线程池过载 抛出异常\n                      String info = \"\";\n                      if (r instanceof AbstractHandleTask) {\n                          AbstractHandleTask task = (AbstractHandleTask) r;\n                          info = task.rejected();\n                      }\n                      throw new TaskRejectedException(String.format(\"线程池过载，任务被拒绝。%s\", info));\n                  }\n  \n              });\n      \n      /**\n       * 添加任务\n       */\n      public void execute(AbstractHandleTask handleTask) throws Exception {\n          THREAD_POOL.execute(handleTask);\n      }\n      \n      /**\n       * 线程池基本状态信息\n       * @return\n       */\n      public String status() {\n          StringBuffer info = new StringBuffer(\"HandleTaskExecutor\");\n          info.append(\", getQueue().size() : \").append(THREAD_POOL.getQueue().size());\n          info.append(\", remainingCapacity : \").append(THREAD_POOL.getQueue().remainingCapacity());\n          info.append(\", MAX_QUEUE_SIZE : \").append(HandleTaskExecutor.MAX_QUEUE_SIZE);\n          info.append(\", getPoolSize : \").append(THREAD_POOL.getPoolSize());\n          info.append(\", getActiveCount : \").append(THREAD_POOL.getActiveCount());\n          info.append(\", getCorePoolSize : \").append(THREAD_POOL.getCorePoolSize());\n          info.append(\", getMaximumPoolSize : \").append(THREAD_POOL.getMaximumPoolSize());\n          info.append(\", getLargestPoolSize : \").append(THREAD_POOL.getLargestPoolSize());\n          \n          return info.toString();\n      }\n      \n  }\n  ```\n\n  线程池默认行为：\n\n  - 不会初始化 corePoolSize 个线程，有任务来了才创建工作线程；\n  - 当核心线程满了之后不会立即扩容线程池，而是把任务堆积到工作队列中；\n  - 当工作队列满了后扩容线程池，一直到线程个数达到 maximumPoolSize 为止；\n  - 如果队列已满且达到了最大线程后还有任务进来，按照拒绝策略处理；\n  - 当线程数大于核心线程数时，线程等待 keepAliveTime 后还是没有任务需要处理的话，\n    收缩线程到核心线程数。\n\n  复用线程池\n\n  线程池必须复用而不是按需创建，但是不推荐一味混用一个线程池。对于选择是否混用线程池，至少对于**频+快的任务和少+慢的任务应该分开**，还是要根据实际任务的性质来选择。\n\n  \n\n","source":"_posts/JAVA/20190507深入学习.md","raw":"---\nlayout: post\ntitle: \"20190507深入学习\"\ndate: 2019-5-7 18:03:11\ncomments: true\ntags: \n\t- JAVA\n---\n1. HashMap,ArrayList,LinkList,ConcurrentMap集合的底层原理。\n\n  转自：<https://juejin.im/post/5aa5d8d26fb9a028d2079264#heading-23>\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1g2svpceo2gj20lx0jzgmd.jpg)\n\n<!-- more -->\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1g2svq2ia0yj20tq1cmju9.jpg)\n\n2. 创建线程的几种方式？线程池有什么好处？线程池是怎么创建的？\n  使用ThreadPoolExecutor创建，线程池的原理\n\n  ```java\n  package com.differ.jackyun.oms.common.task;\n  \n  import java.util.concurrent.LinkedBlockingQueue;\n  import java.util.concurrent.RejectedExecutionHandler;\n  import java.util.concurrent.ThreadFactory;\n  import java.util.concurrent.ThreadPoolExecutor;\n  import java.util.concurrent.TimeUnit;\n  import java.util.concurrent.atomic.AtomicInteger;\n  \n  import org.springframework.core.task.TaskRejectedException;\n  \n  /**\n   * 通用线程池任务处理执行器\n   * \n   * @since 2018年5月16日 下午1:32:01\n   * @author yly\n   *\n   */\n  public class HandleTaskExecutor {\n      \n      /**\n       * 核心线程大小\n       */\n      private static int CORE_POOL_SIZE = 8;\n      /**\n       * 线程池最大线程数\n       */\n      private static int MAX_POOL_SIZE = 64;\n      /**\n       * 额外线程空状态生存时间\n       */\n      private static int KEEP_ALIVE_TIME = 30 * 1000;\n      /**\n       * 队列大小\n       */\n      private static int MAX_QUEUE_SIZE = 30000;\n      \n      private HandleTaskExecutor(){}\n      private static class TmcHandleTaskExecutorHolder{\n          static HandleTaskExecutor me = new HandleTaskExecutor();\n      }\n      \n      /**\n       * 拿到执行器实例\n       * @return\n       */\n      public static HandleTaskExecutor me() {\n          return TmcHandleTaskExecutorHolder.me;\n      }\n      \n      /**\n       * 线程池\n       */\n      private static ThreadPoolExecutor THREAD_POOL = new ThreadPoolExecutor(CORE_POOL_SIZE, MAX_POOL_SIZE, KEEP_ALIVE_TIME, \n                  TimeUnit.MICROSECONDS, new LinkedBlockingQueue<Runnable>(MAX_QUEUE_SIZE),\n              new ThreadFactory() {\n  \n                  private final AtomicInteger index = new AtomicInteger();\n                  @Override\n                  public Thread newThread(Runnable r) {\n                      String threadName = \"任务处理线程[HandleTaskExecutor]-\" + (null != r ? r.getClass().getSimpleName() : \"\") + \"#\" + index.getAndIncrement();\n                      return new Thread(r, threadName);\n                  }\n  \n              }, new RejectedExecutionHandler() {\n  \n                  @Override\n                  public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {\n                      // 线程池过载 抛出异常\n                      String info = \"\";\n                      if (r instanceof AbstractHandleTask) {\n                          AbstractHandleTask task = (AbstractHandleTask) r;\n                          info = task.rejected();\n                      }\n                      throw new TaskRejectedException(String.format(\"线程池过载，任务被拒绝。%s\", info));\n                  }\n  \n              });\n      \n      /**\n       * 添加任务\n       */\n      public void execute(AbstractHandleTask handleTask) throws Exception {\n          THREAD_POOL.execute(handleTask);\n      }\n      \n      /**\n       * 线程池基本状态信息\n       * @return\n       */\n      public String status() {\n          StringBuffer info = new StringBuffer(\"HandleTaskExecutor\");\n          info.append(\", getQueue().size() : \").append(THREAD_POOL.getQueue().size());\n          info.append(\", remainingCapacity : \").append(THREAD_POOL.getQueue().remainingCapacity());\n          info.append(\", MAX_QUEUE_SIZE : \").append(HandleTaskExecutor.MAX_QUEUE_SIZE);\n          info.append(\", getPoolSize : \").append(THREAD_POOL.getPoolSize());\n          info.append(\", getActiveCount : \").append(THREAD_POOL.getActiveCount());\n          info.append(\", getCorePoolSize : \").append(THREAD_POOL.getCorePoolSize());\n          info.append(\", getMaximumPoolSize : \").append(THREAD_POOL.getMaximumPoolSize());\n          info.append(\", getLargestPoolSize : \").append(THREAD_POOL.getLargestPoolSize());\n          \n          return info.toString();\n      }\n      \n  }\n  ```\n\n  线程池默认行为：\n\n  - 不会初始化 corePoolSize 个线程，有任务来了才创建工作线程；\n  - 当核心线程满了之后不会立即扩容线程池，而是把任务堆积到工作队列中；\n  - 当工作队列满了后扩容线程池，一直到线程个数达到 maximumPoolSize 为止；\n  - 如果队列已满且达到了最大线程后还有任务进来，按照拒绝策略处理；\n  - 当线程数大于核心线程数时，线程等待 keepAliveTime 后还是没有任务需要处理的话，\n    收缩线程到核心线程数。\n\n  复用线程池\n\n  线程池必须复用而不是按需创建，但是不推荐一味混用一个线程池。对于选择是否混用线程池，至少对于**频+快的任务和少+慢的任务应该分开**，还是要根据实际任务的性质来选择。\n\n  \n\n","slug":"JAVA/20190507深入学习","published":1,"updated":"2020-08-09T05:24:13.280Z","photos":[],"link":"","_id":"ckdmsee7r001rlguwrgpcjeb0","content":"<ol>\n<li><p>HashMap,ArrayList,LinkList,ConcurrentMap集合的底层原理。</p>\n<p>转自：<a href=\"https://juejin.im/post/5aa5d8d26fb9a028d2079264#heading-23\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5aa5d8d26fb9a028d2079264#heading-23</a></p>\n</li>\n</ol>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1g2svpceo2gj20lx0jzgmd.jpg\" alt></p>\n<a id=\"more\"></a>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1g2svq2ia0yj20tq1cmju9.jpg\" alt></p>\n<ol start=\"2\">\n<li><p>创建线程的几种方式？线程池有什么好处？线程池是怎么创建的？<br>使用ThreadPoolExecutor创建，线程池的原理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.differ.jackyun.oms.common.task;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.RejectedExecutionHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ThreadFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.task.TaskRejectedException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 通用线程池任务处理执行器</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 2018年5月16日 下午1:32:01</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> yly</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HandleTaskExecutor</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 核心线程大小</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> CORE_POOL_SIZE = <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 线程池最大线程数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> MAX_POOL_SIZE = <span class=\"number\">64</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 额外线程空状态生存时间</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> KEEP_ALIVE_TIME = <span class=\"number\">30</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 队列大小</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> MAX_QUEUE_SIZE = <span class=\"number\">30000</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">HandleTaskExecutor</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TmcHandleTaskExecutorHolder</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> HandleTaskExecutor me = <span class=\"keyword\">new</span> HandleTaskExecutor();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 拿到执行器实例</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HandleTaskExecutor <span class=\"title\">me</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> TmcHandleTaskExecutorHolder.me;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 线程池</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ThreadPoolExecutor THREAD_POOL = <span class=\"keyword\">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAX_POOL_SIZE, KEEP_ALIVE_TIME, </span><br><span class=\"line\">                TimeUnit.MICROSECONDS, <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;(MAX_QUEUE_SIZE),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> ThreadFactory() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger index = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Thread <span class=\"title\">newThread</span><span class=\"params\">(Runnable r)</span> </span>&#123;</span><br><span class=\"line\">                    String threadName = <span class=\"string\">\"任务处理线程[HandleTaskExecutor]-\"</span> + (<span class=\"keyword\">null</span> != r ? r.getClass().getSimpleName() : <span class=\"string\">\"\"</span>) + <span class=\"string\">\"#\"</span> + index.getAndIncrement();</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Thread(r, threadName);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;, <span class=\"keyword\">new</span> RejectedExecutionHandler() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 线程池过载 抛出异常</span></span><br><span class=\"line\">                    String info = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (r <span class=\"keyword\">instanceof</span> AbstractHandleTask) &#123;</span><br><span class=\"line\">                        AbstractHandleTask task = (AbstractHandleTask) r;</span><br><span class=\"line\">                        info = task.rejected();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> TaskRejectedException(String.format(<span class=\"string\">\"线程池过载，任务被拒绝。%s\"</span>, info));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加任务</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(AbstractHandleTask handleTask)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        THREAD_POOL.execute(handleTask);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 线程池基本状态信息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">status</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        StringBuffer info = <span class=\"keyword\">new</span> StringBuffer(<span class=\"string\">\"HandleTaskExecutor\"</span>);</span><br><span class=\"line\">        info.append(<span class=\"string\">\", getQueue().size() : \"</span>).append(THREAD_POOL.getQueue().size());</span><br><span class=\"line\">        info.append(<span class=\"string\">\", remainingCapacity : \"</span>).append(THREAD_POOL.getQueue().remainingCapacity());</span><br><span class=\"line\">        info.append(<span class=\"string\">\", MAX_QUEUE_SIZE : \"</span>).append(HandleTaskExecutor.MAX_QUEUE_SIZE);</span><br><span class=\"line\">        info.append(<span class=\"string\">\", getPoolSize : \"</span>).append(THREAD_POOL.getPoolSize());</span><br><span class=\"line\">        info.append(<span class=\"string\">\", getActiveCount : \"</span>).append(THREAD_POOL.getActiveCount());</span><br><span class=\"line\">        info.append(<span class=\"string\">\", getCorePoolSize : \"</span>).append(THREAD_POOL.getCorePoolSize());</span><br><span class=\"line\">        info.append(<span class=\"string\">\", getMaximumPoolSize : \"</span>).append(THREAD_POOL.getMaximumPoolSize());</span><br><span class=\"line\">        info.append(<span class=\"string\">\", getLargestPoolSize : \"</span>).append(THREAD_POOL.getLargestPoolSize());</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> info.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>线程池默认行为：</p>\n<ul>\n<li>不会初始化 corePoolSize 个线程，有任务来了才创建工作线程；</li>\n<li>当核心线程满了之后不会立即扩容线程池，而是把任务堆积到工作队列中；</li>\n<li>当工作队列满了后扩容线程池，一直到线程个数达到 maximumPoolSize 为止；</li>\n<li>如果队列已满且达到了最大线程后还有任务进来，按照拒绝策略处理；</li>\n<li>当线程数大于核心线程数时，线程等待 keepAliveTime 后还是没有任务需要处理的话，<br>收缩线程到核心线程数。</li>\n</ul>\n<p>复用线程池</p>\n<p>线程池必须复用而不是按需创建，但是不推荐一味混用一个线程池。对于选择是否混用线程池，至少对于<strong>频+快的任务和少+慢的任务应该分开</strong>，还是要根据实际任务的性质来选择。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<ol>\n<li><p>HashMap,ArrayList,LinkList,ConcurrentMap集合的底层原理。</p>\n<p>转自：<a href=\"https://juejin.im/post/5aa5d8d26fb9a028d2079264#heading-23\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5aa5d8d26fb9a028d2079264#heading-23</a></p>\n</li>\n</ol>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1g2svpceo2gj20lx0jzgmd.jpg\" alt></p>","more":"<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1g2svq2ia0yj20tq1cmju9.jpg\" alt></p>\n<ol start=\"2\">\n<li><p>创建线程的几种方式？线程池有什么好处？线程池是怎么创建的？<br>使用ThreadPoolExecutor创建，线程池的原理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.differ.jackyun.oms.common.task;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.RejectedExecutionHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ThreadFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.task.TaskRejectedException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 通用线程池任务处理执行器</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 2018年5月16日 下午1:32:01</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> yly</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HandleTaskExecutor</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 核心线程大小</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> CORE_POOL_SIZE = <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 线程池最大线程数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> MAX_POOL_SIZE = <span class=\"number\">64</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 额外线程空状态生存时间</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> KEEP_ALIVE_TIME = <span class=\"number\">30</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 队列大小</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> MAX_QUEUE_SIZE = <span class=\"number\">30000</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">HandleTaskExecutor</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TmcHandleTaskExecutorHolder</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> HandleTaskExecutor me = <span class=\"keyword\">new</span> HandleTaskExecutor();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 拿到执行器实例</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HandleTaskExecutor <span class=\"title\">me</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> TmcHandleTaskExecutorHolder.me;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 线程池</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ThreadPoolExecutor THREAD_POOL = <span class=\"keyword\">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAX_POOL_SIZE, KEEP_ALIVE_TIME, </span><br><span class=\"line\">                TimeUnit.MICROSECONDS, <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;(MAX_QUEUE_SIZE),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> ThreadFactory() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger index = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Thread <span class=\"title\">newThread</span><span class=\"params\">(Runnable r)</span> </span>&#123;</span><br><span class=\"line\">                    String threadName = <span class=\"string\">\"任务处理线程[HandleTaskExecutor]-\"</span> + (<span class=\"keyword\">null</span> != r ? r.getClass().getSimpleName() : <span class=\"string\">\"\"</span>) + <span class=\"string\">\"#\"</span> + index.getAndIncrement();</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Thread(r, threadName);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;, <span class=\"keyword\">new</span> RejectedExecutionHandler() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 线程池过载 抛出异常</span></span><br><span class=\"line\">                    String info = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (r <span class=\"keyword\">instanceof</span> AbstractHandleTask) &#123;</span><br><span class=\"line\">                        AbstractHandleTask task = (AbstractHandleTask) r;</span><br><span class=\"line\">                        info = task.rejected();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> TaskRejectedException(String.format(<span class=\"string\">\"线程池过载，任务被拒绝。%s\"</span>, info));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加任务</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(AbstractHandleTask handleTask)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        THREAD_POOL.execute(handleTask);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 线程池基本状态信息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">status</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        StringBuffer info = <span class=\"keyword\">new</span> StringBuffer(<span class=\"string\">\"HandleTaskExecutor\"</span>);</span><br><span class=\"line\">        info.append(<span class=\"string\">\", getQueue().size() : \"</span>).append(THREAD_POOL.getQueue().size());</span><br><span class=\"line\">        info.append(<span class=\"string\">\", remainingCapacity : \"</span>).append(THREAD_POOL.getQueue().remainingCapacity());</span><br><span class=\"line\">        info.append(<span class=\"string\">\", MAX_QUEUE_SIZE : \"</span>).append(HandleTaskExecutor.MAX_QUEUE_SIZE);</span><br><span class=\"line\">        info.append(<span class=\"string\">\", getPoolSize : \"</span>).append(THREAD_POOL.getPoolSize());</span><br><span class=\"line\">        info.append(<span class=\"string\">\", getActiveCount : \"</span>).append(THREAD_POOL.getActiveCount());</span><br><span class=\"line\">        info.append(<span class=\"string\">\", getCorePoolSize : \"</span>).append(THREAD_POOL.getCorePoolSize());</span><br><span class=\"line\">        info.append(<span class=\"string\">\", getMaximumPoolSize : \"</span>).append(THREAD_POOL.getMaximumPoolSize());</span><br><span class=\"line\">        info.append(<span class=\"string\">\", getLargestPoolSize : \"</span>).append(THREAD_POOL.getLargestPoolSize());</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> info.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>线程池默认行为：</p>\n<ul>\n<li>不会初始化 corePoolSize 个线程，有任务来了才创建工作线程；</li>\n<li>当核心线程满了之后不会立即扩容线程池，而是把任务堆积到工作队列中；</li>\n<li>当工作队列满了后扩容线程池，一直到线程个数达到 maximumPoolSize 为止；</li>\n<li>如果队列已满且达到了最大线程后还有任务进来，按照拒绝策略处理；</li>\n<li>当线程数大于核心线程数时，线程等待 keepAliveTime 后还是没有任务需要处理的话，<br>收缩线程到核心线程数。</li>\n</ul>\n<p>复用线程池</p>\n<p>线程池必须复用而不是按需创建，但是不推荐一味混用一个线程池。对于选择是否混用线程池，至少对于<strong>频+快的任务和少+慢的任务应该分开</strong>，还是要根据实际任务的性质来选择。</p>\n</li>\n</ol>"},{"layout":"post","title":"20190521深入学习","date":"2019-05-21T03:15:07.000Z","comments":1,"_content":"\n### 1. redis分布式锁的实现\n\nsetnx命令为例子，由于Redis的单线程命令处理机制，如果有多个客户端同时执行setnx key value，\n根据setnx的特性只有一个客户端能设置成功，setnx可以作为分布式锁的一种实现方案。\n\n```java\npublic class RedisTool {\n \n    private static final String LOCK_SUCCESS = \"OK\";\n    private static final String SET_IF_NOT_EXIST = \"NX\";\n    private static final String SET_WITH_EXPIRE_TIME = \"PX\";\n \n    /**\n     * 尝试获取分布式锁\n     * @param jedis Redis客户端\n     * @param lockKey 锁\n     * @param requestId 请求标识\n     * @param expireTime 超期时间\n     * @return 是否获取成功\n     */\n    public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) {\n \n        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);\n \n        if (LOCK_SUCCESS.equals(result)) {\n            return true;\n        }\n        return false;\n \n    }\n \n}\n```\n\n### 2. 多线程保证数据安全性\n\n保证数据线程安全的思路基本有以下三种，这三种中又分别有不同的做法：\n\n> 1. 线程封闭技术，让数据只能被单个线程所见。如Threadlocal\n>\n> 2. 使用原子类如AtomicInteger其底层就是volatile和CAS 共同作用的结果。\n>\n>    首先使用了volatile 保证了内存可见性。\n>\n>    然后使用了CAS（compare-and-swap）算法 保证了原子性。 其中CAS算法的原理就是里面包含三个值：内存值A  预估值V  更新值 B  当且仅当 V == A 时，V = B; 否则，不会执行任何操作。\n>\n> 3. 同步技术，正确的发布并维护共享数据。如synchronized锁，即线程A获取到锁后，线程B阻塞直到线程A释放锁，线程B才能获取到同一个锁 。\n\n### 3. equals和hashcode\n\nequals方法注重 **两个对象在逻辑上是否相等**。\n\n> 1） 只要重写 equals ，就必须重写 hashCode 。\n> 2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的\n> 对象必须重写这两个方法。\n> 3） 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals 。\n> 说明： String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象\n> 作为 key 来使用。\n\n### 4. MQ消息事务一致性\n\n主要是让消息持久化。\n\n>1)  上游应用，执行业务并发送指令给可靠消息服务并保留消息副本。\n>\n>2)  可靠消息服务和 MQ消息组件，协调上下游消息的传递，并确保上下游数据的一致性。\n>\n>3)  下游应用，监听 MQ 的消息并执行自身业务并保留消息副本。\n\n","source":"_posts/JAVA/20190521深入学习.md","raw":"---\nlayout: post\ntitle: \"20190521深入学习\"\ndate: 2019-5-21 11:15:07\ncomments: true\ntags: \n\t- JAVA\n---\n\n### 1. redis分布式锁的实现\n\nsetnx命令为例子，由于Redis的单线程命令处理机制，如果有多个客户端同时执行setnx key value，\n根据setnx的特性只有一个客户端能设置成功，setnx可以作为分布式锁的一种实现方案。\n\n```java\npublic class RedisTool {\n \n    private static final String LOCK_SUCCESS = \"OK\";\n    private static final String SET_IF_NOT_EXIST = \"NX\";\n    private static final String SET_WITH_EXPIRE_TIME = \"PX\";\n \n    /**\n     * 尝试获取分布式锁\n     * @param jedis Redis客户端\n     * @param lockKey 锁\n     * @param requestId 请求标识\n     * @param expireTime 超期时间\n     * @return 是否获取成功\n     */\n    public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) {\n \n        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);\n \n        if (LOCK_SUCCESS.equals(result)) {\n            return true;\n        }\n        return false;\n \n    }\n \n}\n```\n\n### 2. 多线程保证数据安全性\n\n保证数据线程安全的思路基本有以下三种，这三种中又分别有不同的做法：\n\n> 1. 线程封闭技术，让数据只能被单个线程所见。如Threadlocal\n>\n> 2. 使用原子类如AtomicInteger其底层就是volatile和CAS 共同作用的结果。\n>\n>    首先使用了volatile 保证了内存可见性。\n>\n>    然后使用了CAS（compare-and-swap）算法 保证了原子性。 其中CAS算法的原理就是里面包含三个值：内存值A  预估值V  更新值 B  当且仅当 V == A 时，V = B; 否则，不会执行任何操作。\n>\n> 3. 同步技术，正确的发布并维护共享数据。如synchronized锁，即线程A获取到锁后，线程B阻塞直到线程A释放锁，线程B才能获取到同一个锁 。\n\n### 3. equals和hashcode\n\nequals方法注重 **两个对象在逻辑上是否相等**。\n\n> 1） 只要重写 equals ，就必须重写 hashCode 。\n> 2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的\n> 对象必须重写这两个方法。\n> 3） 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals 。\n> 说明： String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象\n> 作为 key 来使用。\n\n### 4. MQ消息事务一致性\n\n主要是让消息持久化。\n\n>1)  上游应用，执行业务并发送指令给可靠消息服务并保留消息副本。\n>\n>2)  可靠消息服务和 MQ消息组件，协调上下游消息的传递，并确保上下游数据的一致性。\n>\n>3)  下游应用，监听 MQ 的消息并执行自身业务并保留消息副本。\n\n","slug":"JAVA/20190521深入学习","published":1,"updated":"2020-08-09T05:24:13.281Z","photos":[],"link":"","_id":"ckdmsee7s001slguwf04jfl3l","content":"<h3 id=\"1-redis分布式锁的实现\"><a href=\"#1-redis分布式锁的实现\" class=\"headerlink\" title=\"1. redis分布式锁的实现\"></a>1. redis分布式锁的实现</h3><p>setnx命令为例子，由于Redis的单线程命令处理机制，如果有多个客户端同时执行setnx key value，<br>根据setnx的特性只有一个客户端能设置成功，setnx可以作为分布式锁的一种实现方案。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisTool</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String LOCK_SUCCESS = <span class=\"string\">\"OK\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String SET_IF_NOT_EXIST = <span class=\"string\">\"NX\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String SET_WITH_EXPIRE_TIME = <span class=\"string\">\"PX\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 尝试获取分布式锁</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> jedis Redis客户端</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lockKey 锁</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> requestId 请求标识</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> expireTime 超期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 是否获取成功</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryGetDistributedLock</span><span class=\"params\">(Jedis jedis, String lockKey, String requestId, <span class=\"keyword\">int</span> expireTime)</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-多线程保证数据安全性\"><a href=\"#2-多线程保证数据安全性\" class=\"headerlink\" title=\"2. 多线程保证数据安全性\"></a>2. 多线程保证数据安全性</h3><p>保证数据线程安全的思路基本有以下三种，这三种中又分别有不同的做法：</p>\n<blockquote>\n<ol>\n<li><p>线程封闭技术，让数据只能被单个线程所见。如Threadlocal</p>\n</li>\n<li><p>使用原子类如AtomicInteger其底层就是volatile和CAS 共同作用的结果。</p>\n<p>首先使用了volatile 保证了内存可见性。</p>\n<p>然后使用了CAS（compare-and-swap）算法 保证了原子性。 其中CAS算法的原理就是里面包含三个值：内存值A  预估值V  更新值 B  当且仅当 V == A 时，V = B; 否则，不会执行任何操作。</p>\n</li>\n<li><p>同步技术，正确的发布并维护共享数据。如synchronized锁，即线程A获取到锁后，线程B阻塞直到线程A释放锁，线程B才能获取到同一个锁 。</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"3-equals和hashcode\"><a href=\"#3-equals和hashcode\" class=\"headerlink\" title=\"3. equals和hashcode\"></a>3. equals和hashcode</h3><p>equals方法注重 <strong>两个对象在逻辑上是否相等</strong>。</p>\n<blockquote>\n<p>1） 只要重写 equals ，就必须重写 hashCode 。<br>2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的<br>对象必须重写这两个方法。<br>3） 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals 。<br>说明： String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象<br>作为 key 来使用。</p>\n</blockquote>\n<h3 id=\"4-MQ消息事务一致性\"><a href=\"#4-MQ消息事务一致性\" class=\"headerlink\" title=\"4. MQ消息事务一致性\"></a>4. MQ消息事务一致性</h3><p>主要是让消息持久化。</p>\n<blockquote>\n<p>1)  上游应用，执行业务并发送指令给可靠消息服务并保留消息副本。</p>\n<p>2)  可靠消息服务和 MQ消息组件，协调上下游消息的传递，并确保上下游数据的一致性。</p>\n<p>3)  下游应用，监听 MQ 的消息并执行自身业务并保留消息副本。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-redis分布式锁的实现\"><a href=\"#1-redis分布式锁的实现\" class=\"headerlink\" title=\"1. redis分布式锁的实现\"></a>1. redis分布式锁的实现</h3><p>setnx命令为例子，由于Redis的单线程命令处理机制，如果有多个客户端同时执行setnx key value，<br>根据setnx的特性只有一个客户端能设置成功，setnx可以作为分布式锁的一种实现方案。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisTool</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String LOCK_SUCCESS = <span class=\"string\">\"OK\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String SET_IF_NOT_EXIST = <span class=\"string\">\"NX\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String SET_WITH_EXPIRE_TIME = <span class=\"string\">\"PX\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 尝试获取分布式锁</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> jedis Redis客户端</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> lockKey 锁</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> requestId 请求标识</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> expireTime 超期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 是否获取成功</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryGetDistributedLock</span><span class=\"params\">(Jedis jedis, String lockKey, String requestId, <span class=\"keyword\">int</span> expireTime)</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-多线程保证数据安全性\"><a href=\"#2-多线程保证数据安全性\" class=\"headerlink\" title=\"2. 多线程保证数据安全性\"></a>2. 多线程保证数据安全性</h3><p>保证数据线程安全的思路基本有以下三种，这三种中又分别有不同的做法：</p>\n<blockquote>\n<ol>\n<li><p>线程封闭技术，让数据只能被单个线程所见。如Threadlocal</p>\n</li>\n<li><p>使用原子类如AtomicInteger其底层就是volatile和CAS 共同作用的结果。</p>\n<p>首先使用了volatile 保证了内存可见性。</p>\n<p>然后使用了CAS（compare-and-swap）算法 保证了原子性。 其中CAS算法的原理就是里面包含三个值：内存值A  预估值V  更新值 B  当且仅当 V == A 时，V = B; 否则，不会执行任何操作。</p>\n</li>\n<li><p>同步技术，正确的发布并维护共享数据。如synchronized锁，即线程A获取到锁后，线程B阻塞直到线程A释放锁，线程B才能获取到同一个锁 。</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"3-equals和hashcode\"><a href=\"#3-equals和hashcode\" class=\"headerlink\" title=\"3. equals和hashcode\"></a>3. equals和hashcode</h3><p>equals方法注重 <strong>两个对象在逻辑上是否相等</strong>。</p>\n<blockquote>\n<p>1） 只要重写 equals ，就必须重写 hashCode 。<br>2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的<br>对象必须重写这两个方法。<br>3） 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals 。<br>说明： String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象<br>作为 key 来使用。</p>\n</blockquote>\n<h3 id=\"4-MQ消息事务一致性\"><a href=\"#4-MQ消息事务一致性\" class=\"headerlink\" title=\"4. MQ消息事务一致性\"></a>4. MQ消息事务一致性</h3><p>主要是让消息持久化。</p>\n<blockquote>\n<p>1)  上游应用，执行业务并发送指令给可靠消息服务并保留消息副本。</p>\n<p>2)  可靠消息服务和 MQ消息组件，协调上下游消息的传递，并确保上下游数据的一致性。</p>\n<p>3)  下游应用，监听 MQ 的消息并执行自身业务并保留消息副本。</p>\n</blockquote>\n"},{"layout":"post","title":"C++基础概念","date":"2018-03-26T13:19:00.000Z","_content":"字符，字符串/字符数组\n\nchar ch = ‘A’;\n\nchar str1[20] = \"Helloworld!\";  \n\nchar str2[ ] = \"Have a niceday!\";\n\n<!--more--> \n\n•数组、函数与指针\n\nint *a[10]; \n\nint (*a)[10]; \n\nint (*a)(int); \n\nint (*a[10])(int); \n\n\n\n–非静态成员数据每个对象都有自己的，互相独立，静态成员数据所有对象只有一份\n\n–非静态成员函数，传递了this指针，指向调用对象，所以在函数内可以操作非静态成员数据。静态成员函数没有this指针，因而不能操作非静态成员数据\n\n抽象类不能实例化。\n\n### 附：计算机面试常考算法题目类型\n\n- 深度优先搜索算法/广度优先搜索算法\n- 贪心算法\n- 滑动窗口算法\n- 分治算法\n- 递归算法\n- 动态规划算法（01背包）","source":"_posts/C++/C++Review.md","raw":"layout: post\ntitle: C++基础概念\ntags:\n  - C++\ncategories: []\ndate: 2018-03-26 21:19:00\n---\n字符，字符串/字符数组\n\nchar ch = ‘A’;\n\nchar str1[20] = \"Helloworld!\";  \n\nchar str2[ ] = \"Have a niceday!\";\n\n<!--more--> \n\n•数组、函数与指针\n\nint *a[10]; \n\nint (*a)[10]; \n\nint (*a)(int); \n\nint (*a[10])(int); \n\n\n\n–非静态成员数据每个对象都有自己的，互相独立，静态成员数据所有对象只有一份\n\n–非静态成员函数，传递了this指针，指向调用对象，所以在函数内可以操作非静态成员数据。静态成员函数没有this指针，因而不能操作非静态成员数据\n\n抽象类不能实例化。\n\n### 附：计算机面试常考算法题目类型\n\n- 深度优先搜索算法/广度优先搜索算法\n- 贪心算法\n- 滑动窗口算法\n- 分治算法\n- 递归算法\n- 动态规划算法（01背包）","slug":"C++/C++Review","published":1,"updated":"2020-08-09T05:24:13.276Z","comments":1,"photos":[],"link":"","_id":"ckdmsee7v001vlguw351z5uxp","content":"<p>字符，字符串/字符数组</p>\n<p>char ch = ‘A’;</p>\n<p>char str1[20] = “Helloworld!”;  </p>\n<p>char str2[ ] = “Have a niceday!”;</p>\n<a id=\"more\"></a> \n<p>•数组、函数与指针</p>\n<p>int *a[10]; </p>\n<p>int (*a)[10]; </p>\n<p>int (*a)(int); </p>\n<p>int (*a[10])(int); </p>\n<p>–非静态成员数据每个对象都有自己的，互相独立，静态成员数据所有对象只有一份</p>\n<p>–非静态成员函数，传递了this指针，指向调用对象，所以在函数内可以操作非静态成员数据。静态成员函数没有this指针，因而不能操作非静态成员数据</p>\n<p>抽象类不能实例化。</p>\n<h3 id=\"附：计算机面试常考算法题目类型\"><a href=\"#附：计算机面试常考算法题目类型\" class=\"headerlink\" title=\"附：计算机面试常考算法题目类型\"></a>附：计算机面试常考算法题目类型</h3><ul>\n<li>深度优先搜索算法/广度优先搜索算法</li>\n<li>贪心算法</li>\n<li>滑动窗口算法</li>\n<li>分治算法</li>\n<li>递归算法</li>\n<li>动态规划算法（01背包）</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>字符，字符串/字符数组</p>\n<p>char ch = ‘A’;</p>\n<p>char str1[20] = “Helloworld!”;  </p>\n<p>char str2[ ] = “Have a niceday!”;</p>","more":"<p>•数组、函数与指针</p>\n<p>int *a[10]; </p>\n<p>int (*a)[10]; </p>\n<p>int (*a)(int); </p>\n<p>int (*a[10])(int); </p>\n<p>–非静态成员数据每个对象都有自己的，互相独立，静态成员数据所有对象只有一份</p>\n<p>–非静态成员函数，传递了this指针，指向调用对象，所以在函数内可以操作非静态成员数据。静态成员函数没有this指针，因而不能操作非静态成员数据</p>\n<p>抽象类不能实例化。</p>\n<h3 id=\"附：计算机面试常考算法题目类型\"><a href=\"#附：计算机面试常考算法题目类型\" class=\"headerlink\" title=\"附：计算机面试常考算法题目类型\"></a>附：计算机面试常考算法题目类型</h3><ul>\n<li>深度优先搜索算法/广度优先搜索算法</li>\n<li>贪心算法</li>\n<li>滑动窗口算法</li>\n<li>分治算法</li>\n<li>递归算法</li>\n<li>动态规划算法（01背包）</li>\n</ul>"},{"title":"20191107深入学习","date":"2019-11-14T08:01:17.000Z","_content":"\n### 1.  JVM分区是哪些，哪些是线程独有的\n\n![TIM截图20191114162719.png](http://ww1.sinaimg.cn/large/aacc02d8ly1g8xnp68hsgj209q084750.jpg)\n\n### 2. HashMap为什么线程不安全\n\n- Put的时候会导致数据会覆盖\n\n-  删除键值对 \n\n-  addEntry中当加入新的键值对后键值对总数量超过门限值的时候会调用一个resize操作 \n\n  比如有两个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录所要落到的桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的桶索引和线程B要插入的记录计算出来的桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了。\n\n### 3. synchronized锁什么时候升级\n\n![TIM截图20191121094106.png](http://ww1.sinaimg.cn/large/aacc02d8ly1g95f1ec5vej20nc0c2t99.jpg)\n\n![TIM截图20191121094422.png](http://ww1.sinaimg.cn/large/aacc02d8ly1g95f29kxcaj20n608uglt.jpg)\n\n### 4. lock可以用来做什么锁\n\n- ReentrantLock\n- ReentrantReadWriteLock.ReadLock\n- ReentrantReadWriteLock.WriteLock\n- StampedLock.ReadLockView\n- StampedLock.WriteLockView\n\n### 5. 哪些可以当做 GC Roots对象 \n\n可以作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）\n\n- 虚拟机栈（栈帧中的本地变量表）中引用的对象；\n- 方法区中类静态属性引用的对象；\n- 方法区中常量引用的对象；\n- 本地方法栈中JNI（即一般说的Native方法）引用的对象；\n\n总结就是，方法运行时，方法中引用的对象；类的静态变量引用的对象；类中常量引用的对象；Native方法中引用的对象。","source":"_posts/JAVA/20191107深入学习.md","raw":"---\ntitle: 20191107深入学习\ndate: 2019-11-14 16:01:17\ntags: JAVA\n---\n\n### 1.  JVM分区是哪些，哪些是线程独有的\n\n![TIM截图20191114162719.png](http://ww1.sinaimg.cn/large/aacc02d8ly1g8xnp68hsgj209q084750.jpg)\n\n### 2. HashMap为什么线程不安全\n\n- Put的时候会导致数据会覆盖\n\n-  删除键值对 \n\n-  addEntry中当加入新的键值对后键值对总数量超过门限值的时候会调用一个resize操作 \n\n  比如有两个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录所要落到的桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的桶索引和线程B要插入的记录计算出来的桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了。\n\n### 3. synchronized锁什么时候升级\n\n![TIM截图20191121094106.png](http://ww1.sinaimg.cn/large/aacc02d8ly1g95f1ec5vej20nc0c2t99.jpg)\n\n![TIM截图20191121094422.png](http://ww1.sinaimg.cn/large/aacc02d8ly1g95f29kxcaj20n608uglt.jpg)\n\n### 4. lock可以用来做什么锁\n\n- ReentrantLock\n- ReentrantReadWriteLock.ReadLock\n- ReentrantReadWriteLock.WriteLock\n- StampedLock.ReadLockView\n- StampedLock.WriteLockView\n\n### 5. 哪些可以当做 GC Roots对象 \n\n可以作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）\n\n- 虚拟机栈（栈帧中的本地变量表）中引用的对象；\n- 方法区中类静态属性引用的对象；\n- 方法区中常量引用的对象；\n- 本地方法栈中JNI（即一般说的Native方法）引用的对象；\n\n总结就是，方法运行时，方法中引用的对象；类的静态变量引用的对象；类中常量引用的对象；Native方法中引用的对象。","slug":"JAVA/20191107深入学习","published":1,"updated":"2020-08-09T05:24:13.281Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdmsee7x001xlguwwcbzzam2","content":"<h3 id=\"1-JVM分区是哪些，哪些是线程独有的\"><a href=\"#1-JVM分区是哪些，哪些是线程独有的\" class=\"headerlink\" title=\"1.  JVM分区是哪些，哪些是线程独有的\"></a>1.  JVM分区是哪些，哪些是线程独有的</h3><p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1g8xnp68hsgj209q084750.jpg\" alt=\"TIM截图20191114162719.png\"></p>\n<h3 id=\"2-HashMap为什么线程不安全\"><a href=\"#2-HashMap为什么线程不安全\" class=\"headerlink\" title=\"2. HashMap为什么线程不安全\"></a>2. HashMap为什么线程不安全</h3><ul>\n<li><p>Put的时候会导致数据会覆盖</p>\n</li>\n<li><p>删除键值对 </p>\n</li>\n<li><p>addEntry中当加入新的键值对后键值对总数量超过门限值的时候会调用一个resize操作 </p>\n<p>比如有两个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录所要落到的桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的桶索引和线程B要插入的记录计算出来的桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了。</p>\n</li>\n</ul>\n<h3 id=\"3-synchronized锁什么时候升级\"><a href=\"#3-synchronized锁什么时候升级\" class=\"headerlink\" title=\"3. synchronized锁什么时候升级\"></a>3. synchronized锁什么时候升级</h3><p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1g95f1ec5vej20nc0c2t99.jpg\" alt=\"TIM截图20191121094106.png\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1g95f29kxcaj20n608uglt.jpg\" alt=\"TIM截图20191121094422.png\"></p>\n<h3 id=\"4-lock可以用来做什么锁\"><a href=\"#4-lock可以用来做什么锁\" class=\"headerlink\" title=\"4. lock可以用来做什么锁\"></a>4. lock可以用来做什么锁</h3><ul>\n<li>ReentrantLock</li>\n<li>ReentrantReadWriteLock.ReadLock</li>\n<li>ReentrantReadWriteLock.WriteLock</li>\n<li>StampedLock.ReadLockView</li>\n<li>StampedLock.WriteLockView</li>\n</ul>\n<h3 id=\"5-哪些可以当做-GC-Roots对象\"><a href=\"#5-哪些可以当做-GC-Roots对象\" class=\"headerlink\" title=\"5. 哪些可以当做 GC Roots对象\"></a>5. 哪些可以当做 GC Roots对象</h3><p>可以作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）</p>\n<ul>\n<li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li>\n<li>方法区中类静态属性引用的对象；</li>\n<li>方法区中常量引用的对象；</li>\n<li>本地方法栈中JNI（即一般说的Native方法）引用的对象；</li>\n</ul>\n<p>总结就是，方法运行时，方法中引用的对象；类的静态变量引用的对象；类中常量引用的对象；Native方法中引用的对象。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-JVM分区是哪些，哪些是线程独有的\"><a href=\"#1-JVM分区是哪些，哪些是线程独有的\" class=\"headerlink\" title=\"1.  JVM分区是哪些，哪些是线程独有的\"></a>1.  JVM分区是哪些，哪些是线程独有的</h3><p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1g8xnp68hsgj209q084750.jpg\" alt=\"TIM截图20191114162719.png\"></p>\n<h3 id=\"2-HashMap为什么线程不安全\"><a href=\"#2-HashMap为什么线程不安全\" class=\"headerlink\" title=\"2. HashMap为什么线程不安全\"></a>2. HashMap为什么线程不安全</h3><ul>\n<li><p>Put的时候会导致数据会覆盖</p>\n</li>\n<li><p>删除键值对 </p>\n</li>\n<li><p>addEntry中当加入新的键值对后键值对总数量超过门限值的时候会调用一个resize操作 </p>\n<p>比如有两个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录所要落到的桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的桶索引和线程B要插入的记录计算出来的桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了。</p>\n</li>\n</ul>\n<h3 id=\"3-synchronized锁什么时候升级\"><a href=\"#3-synchronized锁什么时候升级\" class=\"headerlink\" title=\"3. synchronized锁什么时候升级\"></a>3. synchronized锁什么时候升级</h3><p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1g95f1ec5vej20nc0c2t99.jpg\" alt=\"TIM截图20191121094106.png\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1g95f29kxcaj20n608uglt.jpg\" alt=\"TIM截图20191121094422.png\"></p>\n<h3 id=\"4-lock可以用来做什么锁\"><a href=\"#4-lock可以用来做什么锁\" class=\"headerlink\" title=\"4. lock可以用来做什么锁\"></a>4. lock可以用来做什么锁</h3><ul>\n<li>ReentrantLock</li>\n<li>ReentrantReadWriteLock.ReadLock</li>\n<li>ReentrantReadWriteLock.WriteLock</li>\n<li>StampedLock.ReadLockView</li>\n<li>StampedLock.WriteLockView</li>\n</ul>\n<h3 id=\"5-哪些可以当做-GC-Roots对象\"><a href=\"#5-哪些可以当做-GC-Roots对象\" class=\"headerlink\" title=\"5. 哪些可以当做 GC Roots对象\"></a>5. 哪些可以当做 GC Roots对象</h3><p>可以作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）</p>\n<ul>\n<li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li>\n<li>方法区中类静态属性引用的对象；</li>\n<li>方法区中常量引用的对象；</li>\n<li>本地方法栈中JNI（即一般说的Native方法）引用的对象；</li>\n</ul>\n<p>总结就是，方法运行时，方法中引用的对象；类的静态变量引用的对象；类中常量引用的对象；Native方法中引用的对象。</p>\n"},{"layout":"post","title":"JVM内存分区","date":"2019-05-21T03:14:07.000Z","_content":"\n#### 1. JVM的内存模型\n\n**线程私有：**\n\n栈（方法栈）：线程在执行方法的时候会创建一个栈帧，栈帧包含：局部变量表，操作数栈，动态链接（与其他方法相链接），方法出口等信息。\n\n本地方法栈：与栈类型，不同点是执行native方法。\n\n程序计数器：保存当前字节码的位置\n\n**线程共享：**\n\n堆：由垃圾回收器管理。\n\n-Xms: 堆的最小值\n\n-Xmx: 堆的最大值\n\n-XX:NewSize: 新生代最小值\n\n-XX:MaxNewSize: 新生代最大值\n\n新生代：Eden:From:To = 8:1:1\n\n方法区：用以存储加载类的信息，常量，静态变量。JDK8以前，方法区是在堆永久代中，JDK8及以后取消了永久代，方法区挪到直接内存MetaSpace中。\n\n永久代：\n\njdk1.7及以前： -XX:PermSize -XX:MaxPermSize\n\njdk1.8以后：-XX:MetaspaceSize -XX:MaxMetaspaceSize\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1g2v0u0kga5j20jv0dnmzd.jpg)\n\n<!--more-->\n\n局部变量存在虚拟机栈中，常量存在方法区中，成员变量则随着对象一起存在堆中。\n\nJava 堆从 GC 的角度还可以细分为: 新生代( Eden 区 、 From Survivor 区 和 To Survivor 区 )和老年\n代。\n\n\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1g2v1049rtij20ir05n3zt.jpg)\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxuyutofxmj20vw0lidrd.jpg)\n\n\n\n#### 2. 垃圾回收算法\n\n**2.1 两种判断对象是否死亡的方法**\n\n1.引用计数法\n\n它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。\n\n2.GC Roots可达性分析法\n\n目前 Java 虚拟机的主流垃圾回收器采取的是可达性分析算法。这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。\n\n**2.2 垃圾回收的三种方式**\n\n**标记清除清除算法（Mark-Sweep）**\n\n即把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。\n\n缺点很明显，会造成内存碎片。JVM内部是要求内存连续的，所以就会出现总的空闲内存还比较充足但是无法分配对象的情况。\n\n**压缩（Mark-Compact）**\n\n即把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。\n\n**复制（copying）**\n\n即把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。\n\n分代收集法是目前大部分 JVM 所采用的方法，**其核心思想是根据对象存活的不同生命周期将内存**\n**划分为不同的域，**一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(Young\nGeneration)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃\n圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。\n\n**新生代：复制算法** \n\n当Eden区域内存不够的时候触发MinorGC,MinorGC采用复制算法。因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少。\n\n- Eden, From -> To \n- 清空 Eden, From\n- To和From互换\n\n当老年代空间不够用时，触发FullGC。\n\n**老年代：压缩算法**\n\n老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。\n\n因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标\n记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存.","source":"_posts/JAVA/JVM内存分区.md","raw":"---\nlayout: post\ntitle: \"JVM内存分区\"\ndate: 2019-5-21 11:14:07\ntags: Java\n---\n\n#### 1. JVM的内存模型\n\n**线程私有：**\n\n栈（方法栈）：线程在执行方法的时候会创建一个栈帧，栈帧包含：局部变量表，操作数栈，动态链接（与其他方法相链接），方法出口等信息。\n\n本地方法栈：与栈类型，不同点是执行native方法。\n\n程序计数器：保存当前字节码的位置\n\n**线程共享：**\n\n堆：由垃圾回收器管理。\n\n-Xms: 堆的最小值\n\n-Xmx: 堆的最大值\n\n-XX:NewSize: 新生代最小值\n\n-XX:MaxNewSize: 新生代最大值\n\n新生代：Eden:From:To = 8:1:1\n\n方法区：用以存储加载类的信息，常量，静态变量。JDK8以前，方法区是在堆永久代中，JDK8及以后取消了永久代，方法区挪到直接内存MetaSpace中。\n\n永久代：\n\njdk1.7及以前： -XX:PermSize -XX:MaxPermSize\n\njdk1.8以后：-XX:MetaspaceSize -XX:MaxMetaspaceSize\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1g2v0u0kga5j20jv0dnmzd.jpg)\n\n<!--more-->\n\n局部变量存在虚拟机栈中，常量存在方法区中，成员变量则随着对象一起存在堆中。\n\nJava 堆从 GC 的角度还可以细分为: 新生代( Eden 区 、 From Survivor 区 和 To Survivor 区 )和老年\n代。\n\n\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1g2v1049rtij20ir05n3zt.jpg)\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxuyutofxmj20vw0lidrd.jpg)\n\n\n\n#### 2. 垃圾回收算法\n\n**2.1 两种判断对象是否死亡的方法**\n\n1.引用计数法\n\n它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。\n\n2.GC Roots可达性分析法\n\n目前 Java 虚拟机的主流垃圾回收器采取的是可达性分析算法。这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。\n\n**2.2 垃圾回收的三种方式**\n\n**标记清除清除算法（Mark-Sweep）**\n\n即把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。\n\n缺点很明显，会造成内存碎片。JVM内部是要求内存连续的，所以就会出现总的空闲内存还比较充足但是无法分配对象的情况。\n\n**压缩（Mark-Compact）**\n\n即把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。\n\n**复制（copying）**\n\n即把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。\n\n分代收集法是目前大部分 JVM 所采用的方法，**其核心思想是根据对象存活的不同生命周期将内存**\n**划分为不同的域，**一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(Young\nGeneration)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃\n圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。\n\n**新生代：复制算法** \n\n当Eden区域内存不够的时候触发MinorGC,MinorGC采用复制算法。因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少。\n\n- Eden, From -> To \n- 清空 Eden, From\n- To和From互换\n\n当老年代空间不够用时，触发FullGC。\n\n**老年代：压缩算法**\n\n老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。\n\n因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标\n记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存.","slug":"JAVA/JVM内存分区","published":1,"updated":"2020-08-09T05:24:13.282Z","comments":1,"photos":[],"link":"","_id":"ckdmsee800020lguwc97i3qih","content":"<h4 id=\"1-JVM的内存模型\"><a href=\"#1-JVM的内存模型\" class=\"headerlink\" title=\"1. JVM的内存模型\"></a>1. JVM的内存模型</h4><p><strong>线程私有：</strong></p>\n<p>栈（方法栈）：线程在执行方法的时候会创建一个栈帧，栈帧包含：局部变量表，操作数栈，动态链接（与其他方法相链接），方法出口等信息。</p>\n<p>本地方法栈：与栈类型，不同点是执行native方法。</p>\n<p>程序计数器：保存当前字节码的位置</p>\n<p><strong>线程共享：</strong></p>\n<p>堆：由垃圾回收器管理。</p>\n<p>-Xms: 堆的最小值</p>\n<p>-Xmx: 堆的最大值</p>\n<p>-XX:NewSize: 新生代最小值</p>\n<p>-XX:MaxNewSize: 新生代最大值</p>\n<p>新生代：Eden:From:To = 8:1:1</p>\n<p>方法区：用以存储加载类的信息，常量，静态变量。JDK8以前，方法区是在堆永久代中，JDK8及以后取消了永久代，方法区挪到直接内存MetaSpace中。</p>\n<p>永久代：</p>\n<p>jdk1.7及以前： -XX:PermSize -XX:MaxPermSize</p>\n<p>jdk1.8以后：-XX:MetaspaceSize -XX:MaxMetaspaceSize</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1g2v0u0kga5j20jv0dnmzd.jpg\" alt></p>\n<a id=\"more\"></a>\n<p>局部变量存在虚拟机栈中，常量存在方法区中，成员变量则随着对象一起存在堆中。</p>\n<p>Java 堆从 GC 的角度还可以细分为: 新生代( Eden 区 、 From Survivor 区 和 To Survivor 区 )和老年<br>代。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1g2v1049rtij20ir05n3zt.jpg\" alt></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1fxuyutofxmj20vw0lidrd.jpg\" alt></p>\n<h4 id=\"2-垃圾回收算法\"><a href=\"#2-垃圾回收算法\" class=\"headerlink\" title=\"2. 垃圾回收算法\"></a>2. 垃圾回收算法</h4><p><strong>2.1 两种判断对象是否死亡的方法</strong></p>\n<p>1.引用计数法</p>\n<p>它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。</p>\n<p>2.GC Roots可达性分析法</p>\n<p>目前 Java 虚拟机的主流垃圾回收器采取的是可达性分析算法。这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。</p>\n<p><strong>2.2 垃圾回收的三种方式</strong></p>\n<p><strong>标记清除清除算法（Mark-Sweep）</strong></p>\n<p>即把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。</p>\n<p>缺点很明显，会造成内存碎片。JVM内部是要求内存连续的，所以就会出现总的空闲内存还比较充足但是无法分配对象的情况。</p>\n<p><strong>压缩（Mark-Compact）</strong></p>\n<p>即把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。</p>\n<p><strong>复制（copying）</strong></p>\n<p>即把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。</p>\n<p>分代收集法是目前大部分 JVM 所采用的方法，<strong>其核心思想是根据对象存活的不同生命周期将内存</strong><br><strong>划分为不同的域，</strong>一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(Young<br>Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃<br>圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。</p>\n<p><strong>新生代：复制算法</strong> </p>\n<p>当Eden区域内存不够的时候触发MinorGC,MinorGC采用复制算法。因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少。</p>\n<ul>\n<li>Eden, From -&gt; To </li>\n<li>清空 Eden, From</li>\n<li>To和From互换</li>\n</ul>\n<p>当老年代空间不够用时，触发FullGC。</p>\n<p><strong>老年代：压缩算法</strong></p>\n<p>老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。</p>\n<p>因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标<br>记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存.</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"1-JVM的内存模型\"><a href=\"#1-JVM的内存模型\" class=\"headerlink\" title=\"1. JVM的内存模型\"></a>1. JVM的内存模型</h4><p><strong>线程私有：</strong></p>\n<p>栈（方法栈）：线程在执行方法的时候会创建一个栈帧，栈帧包含：局部变量表，操作数栈，动态链接（与其他方法相链接），方法出口等信息。</p>\n<p>本地方法栈：与栈类型，不同点是执行native方法。</p>\n<p>程序计数器：保存当前字节码的位置</p>\n<p><strong>线程共享：</strong></p>\n<p>堆：由垃圾回收器管理。</p>\n<p>-Xms: 堆的最小值</p>\n<p>-Xmx: 堆的最大值</p>\n<p>-XX:NewSize: 新生代最小值</p>\n<p>-XX:MaxNewSize: 新生代最大值</p>\n<p>新生代：Eden:From:To = 8:1:1</p>\n<p>方法区：用以存储加载类的信息，常量，静态变量。JDK8以前，方法区是在堆永久代中，JDK8及以后取消了永久代，方法区挪到直接内存MetaSpace中。</p>\n<p>永久代：</p>\n<p>jdk1.7及以前： -XX:PermSize -XX:MaxPermSize</p>\n<p>jdk1.8以后：-XX:MetaspaceSize -XX:MaxMetaspaceSize</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1g2v0u0kga5j20jv0dnmzd.jpg\" alt></p>","more":"<p>局部变量存在虚拟机栈中，常量存在方法区中，成员变量则随着对象一起存在堆中。</p>\n<p>Java 堆从 GC 的角度还可以细分为: 新生代( Eden 区 、 From Survivor 区 和 To Survivor 区 )和老年<br>代。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1g2v1049rtij20ir05n3zt.jpg\" alt></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1fxuyutofxmj20vw0lidrd.jpg\" alt></p>\n<h4 id=\"2-垃圾回收算法\"><a href=\"#2-垃圾回收算法\" class=\"headerlink\" title=\"2. 垃圾回收算法\"></a>2. 垃圾回收算法</h4><p><strong>2.1 两种判断对象是否死亡的方法</strong></p>\n<p>1.引用计数法</p>\n<p>它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。</p>\n<p>2.GC Roots可达性分析法</p>\n<p>目前 Java 虚拟机的主流垃圾回收器采取的是可达性分析算法。这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。</p>\n<p><strong>2.2 垃圾回收的三种方式</strong></p>\n<p><strong>标记清除清除算法（Mark-Sweep）</strong></p>\n<p>即把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。</p>\n<p>缺点很明显，会造成内存碎片。JVM内部是要求内存连续的，所以就会出现总的空闲内存还比较充足但是无法分配对象的情况。</p>\n<p><strong>压缩（Mark-Compact）</strong></p>\n<p>即把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。</p>\n<p><strong>复制（copying）</strong></p>\n<p>即把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。</p>\n<p>分代收集法是目前大部分 JVM 所采用的方法，<strong>其核心思想是根据对象存活的不同生命周期将内存</strong><br><strong>划分为不同的域，</strong>一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(Young<br>Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃<br>圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。</p>\n<p><strong>新生代：复制算法</strong> </p>\n<p>当Eden区域内存不够的时候触发MinorGC,MinorGC采用复制算法。因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少。</p>\n<ul>\n<li>Eden, From -&gt; To </li>\n<li>清空 Eden, From</li>\n<li>To和From互换</li>\n</ul>\n<p>当老年代空间不够用时，触发FullGC。</p>\n<p><strong>老年代：压缩算法</strong></p>\n<p>老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。</p>\n<p>因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标<br>记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存.</p>"},{"layout":"post","title":"链表","date":"2019-10-08T12:41:31.000Z","comments":1,"_content":"链表的题目，思考起来不难，考察的是实现代码的能力，思路是否清晰明了，代码是否简洁。\n\n1. https://leetcode.com/problems/reverse-linked-list/\n\n   ```java\n   public static ListNode reverseList(ListNode head) {\n           // 在遍历列表时，将当前节点的 next 指针改为指向前一个元素。\n           // 由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。\n           // 在更改引用之前，还需要另一个指针来存储下一个节点。\n           ListNode cur = head;\n           ListNode prev = null;\n           while (cur != null){\n               ListNode nextTemp = cur.next;\n               cur.next = prev;\n               prev = cur;\n               cur = nextTemp;\n           }\n           return prev;\n       }\n   ```\n\n2. https://leetcode.com/problems/swap-nodes-in-pairs/\n\n   理解递归\n\n   ```java\n   public static ListNode swapPairs(ListNode head) {\n   \n           if (head == null || head.next == null) {\n               return head;\n           }\n           ListNode next = head.next;\n           head.next = swapPairs(next.next);\n           next.next = head;\n           return next;\n       }\n   ```\n\n   <!--more--> \n\n3. 将两个有序顺序表合并成一个新的有序顺序表，并由函数返回结果顺序表。 \n\n```c++\nbool Merge(SeqList A, SeqList B, SeqList &C){\n    if(A.length + B.length > C.maxSize)\n        return false;\n    int i = 0, j = 0, k = 0;\n    while(i < A.length && j < B.length){\n        if(A.data[i] <= B.data[j])\n            C.data[k++] = A.data[i++];\n        else\n            C.data[k++] = B.data[j++];\n    }\n    while(i < A.length)\n        C.data[k++] = A.data[i++];\n    while(j < B.length)\n        C.data[k++] = A.data[j++];\n    C.length = k+1;\n    return true;\n}\n```\n4. 设L为带头结点的单链表，编写算法实现从尾到头反向输出每个节点的值。\n\n​        key: 想到调用栈这点很重要。\n\n```c++\nvoid R_Print(LinkList L){\n    if(L->next != NULL){\n        R_Print(L->next);\n    }\n    printf(L->data);\n}\n```","source":"_posts/C++/链表.md","raw":"---\nlayout: post\ntitle: \"链表\"\ndate: 2019-10-8 20:41:31\ncomments: true\ntags: \n\t- leetcode\n---\n链表的题目，思考起来不难，考察的是实现代码的能力，思路是否清晰明了，代码是否简洁。\n\n1. https://leetcode.com/problems/reverse-linked-list/\n\n   ```java\n   public static ListNode reverseList(ListNode head) {\n           // 在遍历列表时，将当前节点的 next 指针改为指向前一个元素。\n           // 由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。\n           // 在更改引用之前，还需要另一个指针来存储下一个节点。\n           ListNode cur = head;\n           ListNode prev = null;\n           while (cur != null){\n               ListNode nextTemp = cur.next;\n               cur.next = prev;\n               prev = cur;\n               cur = nextTemp;\n           }\n           return prev;\n       }\n   ```\n\n2. https://leetcode.com/problems/swap-nodes-in-pairs/\n\n   理解递归\n\n   ```java\n   public static ListNode swapPairs(ListNode head) {\n   \n           if (head == null || head.next == null) {\n               return head;\n           }\n           ListNode next = head.next;\n           head.next = swapPairs(next.next);\n           next.next = head;\n           return next;\n       }\n   ```\n\n   <!--more--> \n\n3. 将两个有序顺序表合并成一个新的有序顺序表，并由函数返回结果顺序表。 \n\n```c++\nbool Merge(SeqList A, SeqList B, SeqList &C){\n    if(A.length + B.length > C.maxSize)\n        return false;\n    int i = 0, j = 0, k = 0;\n    while(i < A.length && j < B.length){\n        if(A.data[i] <= B.data[j])\n            C.data[k++] = A.data[i++];\n        else\n            C.data[k++] = B.data[j++];\n    }\n    while(i < A.length)\n        C.data[k++] = A.data[i++];\n    while(j < B.length)\n        C.data[k++] = A.data[j++];\n    C.length = k+1;\n    return true;\n}\n```\n4. 设L为带头结点的单链表，编写算法实现从尾到头反向输出每个节点的值。\n\n​        key: 想到调用栈这点很重要。\n\n```c++\nvoid R_Print(LinkList L){\n    if(L->next != NULL){\n        R_Print(L->next);\n    }\n    printf(L->data);\n}\n```","slug":"C++/链表","published":1,"updated":"2020-08-09T05:24:13.279Z","photos":[],"link":"","_id":"ckdmsee810022lguwqc45s1oo","content":"<p>链表的题目，思考起来不难，考察的是实现代码的能力，思路是否清晰明了，代码是否简洁。</p>\n<ol>\n<li><p><a href=\"https://leetcode.com/problems/reverse-linked-list/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/reverse-linked-list/</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ListNode <span class=\"title\">reverseList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在遍历列表时，将当前节点的 next 指针改为指向前一个元素。</span></span><br><span class=\"line\">        <span class=\"comment\">// 由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。</span></span><br><span class=\"line\">        <span class=\"comment\">// 在更改引用之前，还需要另一个指针来存储下一个节点。</span></span><br><span class=\"line\">        ListNode cur = head;</span><br><span class=\"line\">        ListNode prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            ListNode nextTemp = cur.next;</span><br><span class=\"line\">            cur.next = prev;</span><br><span class=\"line\">            prev = cur;</span><br><span class=\"line\">            cur = nextTemp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> prev;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://leetcode.com/problems/swap-nodes-in-pairs/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/swap-nodes-in-pairs/</a></p>\n<p>理解递归</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ListNode <span class=\"title\">swapPairs</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode next = head.next;</span><br><span class=\"line\">        head.next = swapPairs(next.next);</span><br><span class=\"line\">        next.next = head;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a> \n</li>\n<li><p>将两个有序顺序表合并成一个新的有序顺序表，并由函数返回结果顺序表。 </p>\n</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Merge</span><span class=\"params\">(SeqList A, SeqList B, SeqList &amp;C)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(A.length + B.length &gt; C.maxSize)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>, k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; A.length &amp;&amp; j &lt; B.length)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(A.data[i] &lt;= B.data[j])</span><br><span class=\"line\">            C.data[k++] = A.data[i++];</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            C.data[k++] = B.data[j++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; A.length)</span><br><span class=\"line\">        C.data[k++] = A.data[i++];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(j &lt; B.length)</span><br><span class=\"line\">        C.data[k++] = A.data[j++];</span><br><span class=\"line\">    C.length = k+<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>设L为带头结点的单链表，编写算法实现从尾到头反向输出每个节点的值。</li>\n</ol>\n<p>​        key: 想到调用栈这点很重要。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">R_Print</span><span class=\"params\">(LinkList L)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L-&gt;next != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        R_Print(L-&gt;next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(L-&gt;data);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>链表的题目，思考起来不难，考察的是实现代码的能力，思路是否清晰明了，代码是否简洁。</p>\n<ol>\n<li><p><a href=\"https://leetcode.com/problems/reverse-linked-list/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/reverse-linked-list/</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ListNode <span class=\"title\">reverseList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在遍历列表时，将当前节点的 next 指针改为指向前一个元素。</span></span><br><span class=\"line\">        <span class=\"comment\">// 由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。</span></span><br><span class=\"line\">        <span class=\"comment\">// 在更改引用之前，还需要另一个指针来存储下一个节点。</span></span><br><span class=\"line\">        ListNode cur = head;</span><br><span class=\"line\">        ListNode prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            ListNode nextTemp = cur.next;</span><br><span class=\"line\">            cur.next = prev;</span><br><span class=\"line\">            prev = cur;</span><br><span class=\"line\">            cur = nextTemp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> prev;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://leetcode.com/problems/swap-nodes-in-pairs/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/swap-nodes-in-pairs/</a></p>\n<p>理解递归</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ListNode <span class=\"title\">swapPairs</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode next = head.next;</span><br><span class=\"line\">        head.next = swapPairs(next.next);</span><br><span class=\"line\">        next.next = head;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li></ol>","more":"\n<li><p>将两个有序顺序表合并成一个新的有序顺序表，并由函数返回结果顺序表。 </p>\n</li>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Merge</span><span class=\"params\">(SeqList A, SeqList B, SeqList &amp;C)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(A.length + B.length &gt; C.maxSize)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>, k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; A.length &amp;&amp; j &lt; B.length)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(A.data[i] &lt;= B.data[j])</span><br><span class=\"line\">            C.data[k++] = A.data[i++];</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            C.data[k++] = B.data[j++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; A.length)</span><br><span class=\"line\">        C.data[k++] = A.data[i++];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(j &lt; B.length)</span><br><span class=\"line\">        C.data[k++] = A.data[j++];</span><br><span class=\"line\">    C.length = k+<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>设L为带头结点的单链表，编写算法实现从尾到头反向输出每个节点的值。</li>\n</ol>\n<p>​        key: 想到调用栈这点很重要。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">R_Print</span><span class=\"params\">(LinkList L)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L-&gt;next != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        R_Print(L-&gt;next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(L-&gt;data);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"SpringBoot中直接new对象为NULL值","date":"2019-04-29T08:14:55.000Z","comments":1,"_content":"#### SpringBoot中直接new对象为NULL值\n\n在springBoot中如果直接new一个对象出来，那么在此对象使用了@Autowired注解都会为NULL值。\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1g2ic3hf2v3j215g0le40u.jpg)\n\n为了解决这个问题，我们就要了解Spring容器机制了。\n\n@Autowired是适用于Spring容器的，直接new出来的对象不在Spring容器中，所以@Autowired失效了。\n\n在程序启动的过程中，Spring就创建了容器。我们可以根据ApplicationContext获取到容器中的所有对象。\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1g2icmib810j20ov02ywep.jpg)\n\n","source":"_posts/JAVA/SpringBoot中直接new对象为NULL值.md","raw":"---\nlayout: post\ntitle: \"SpringBoot中直接new对象为NULL值\"\ndate: 2019-4-29 16:14:55\ncomments: true\ntags: \n\t- JAVA\n---\n#### SpringBoot中直接new对象为NULL值\n\n在springBoot中如果直接new一个对象出来，那么在此对象使用了@Autowired注解都会为NULL值。\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1g2ic3hf2v3j215g0le40u.jpg)\n\n为了解决这个问题，我们就要了解Spring容器机制了。\n\n@Autowired是适用于Spring容器的，直接new出来的对象不在Spring容器中，所以@Autowired失效了。\n\n在程序启动的过程中，Spring就创建了容器。我们可以根据ApplicationContext获取到容器中的所有对象。\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1g2icmib810j20ov02ywep.jpg)\n\n","slug":"JAVA/SpringBoot中直接new对象为NULL值","published":1,"updated":"2020-08-09T05:24:13.283Z","photos":[],"link":"","_id":"ckdmsee820024lguwere5t16y","content":"<h4 id=\"SpringBoot中直接new对象为NULL值\"><a href=\"#SpringBoot中直接new对象为NULL值\" class=\"headerlink\" title=\"SpringBoot中直接new对象为NULL值\"></a>SpringBoot中直接new对象为NULL值</h4><p>在springBoot中如果直接new一个对象出来，那么在此对象使用了@Autowired注解都会为NULL值。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1g2ic3hf2v3j215g0le40u.jpg\" alt></p>\n<p>为了解决这个问题，我们就要了解Spring容器机制了。</p>\n<p>@Autowired是适用于Spring容器的，直接new出来的对象不在Spring容器中，所以@Autowired失效了。</p>\n<p>在程序启动的过程中，Spring就创建了容器。我们可以根据ApplicationContext获取到容器中的所有对象。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1g2icmib810j20ov02ywep.jpg\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"SpringBoot中直接new对象为NULL值\"><a href=\"#SpringBoot中直接new对象为NULL值\" class=\"headerlink\" title=\"SpringBoot中直接new对象为NULL值\"></a>SpringBoot中直接new对象为NULL值</h4><p>在springBoot中如果直接new一个对象出来，那么在此对象使用了@Autowired注解都会为NULL值。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1g2ic3hf2v3j215g0le40u.jpg\" alt></p>\n<p>为了解决这个问题，我们就要了解Spring容器机制了。</p>\n<p>@Autowired是适用于Spring容器的，直接new出来的对象不在Spring容器中，所以@Autowired失效了。</p>\n<p>在程序启动的过程中，Spring就创建了容器。我们可以根据ApplicationContext获取到容器中的所有对象。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1g2icmib810j20ov02ywep.jpg\" alt></p>\n"},{"layout":"post","title":"Spring学习笔记","comments":1,"date":"2019-05-20T03:14:07.000Z","_content":"在面试中，经常会问，说说你对spring IOC和AOP的理解，问题很宽泛，似乎不知道从何说起。\n\n回答思路：1.先用通俗易懂的话解释下何为IOC和AOP---------》2.各自的实现原理-----------》3.自己的项目中如何使用\n\n<!--more--> \n\n## IOC\n\n#### 一.定义\n\nIOC是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，交给了Spring。 \n\nSpring IOC的作用\n\n1. 不必自己创建对象了（不必new出来了）\n2. 面向接口编程\n\n许多应用都是通过彼此间的相互合作来实现业务逻辑的，如类A要调用类B的方法，以前我们都是在类A中，通过自身new一个类B，然后在调用类B的方法，这样对象间的耦合度高了，现在我们把new类B的事情交给spring来做，在我们调用的时候，容器会为我们实例化。\n\n#### 二.依赖注入（DI）\n\n资源定位，即定义bean的xml（也可以使用@Bean）-------》载入--------》IOC容器注册，注册beanDefinition。\n\nIOC容器的初始化过程，一般不包含bean的依赖注入的实现，在spring IOC设计中，bean的注册和依赖注入是两个过程，，依赖注入一般发生在应用第一次索取bean的时候，但是也可以在xm中配置，在容器初始化的时候，这个bean就完成了初始化。\n\nSpring使用：单独使用Bean容器（Bean管理）。\n\nBean容器初始化基础：依赖两个包\n\n- org.springframework.beans 中的BeanFactory提供配置结构和基本功能，加载并初始化Bean\n- org.springframework.context 中的 ApplicationContext保存了Bean对象并在Spring中被广泛使用\n\nSpring注入是指在启动Spring容器加载bean配置的时候，完成对变量的赋值行为。\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1dg2ewfj20wp0c70ue.jpg)\n\n## AOP\n\n面向切面，所有业务都要处理的业务，如打印日志，登录拦截。要记录所有update*方法的执行时间时间，操作人等等信息，记录到日志，\n\n通过spring的AOP技术，就可以在不修改update*的代码的情况下完成该需求。\n\nspring用代理类包裹切面，把他们织入到Spring管理的bean中。也就是说代理类伪装成目标类，它会截取对目标类中方法的调用，让调用者对目标类的调用都先变成调用伪装类，伪装类中就先执行了切面，再把调用转发给真正的目标bean。\n\n前一种兄弟模式，spring会使用JDK的java.lang.reflect.Proxy类，它允许Spring动态生成一个新类来实现必要的接口，织入通知，并且把对这些接口的任何调用都转发到目标类。\n\n后一种父子模式，spring使用CGLIB库生成目标类的一个子类，在创建这个子类的时候，spring织入通知，并且把对这个子类的调用委托到目标类。\n\nSpring AOP 会动态选择使用 JDK 动态代理、CGLIB 来生成 AOP 代理，如果目标类实现了接口，Spring AOP 则无需 CGLIB 的支持，直接使用 JDK 提供的 Proxy 和 InvocationHandler 来生成 AOP 代理即可。\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1dpe89mj20ns0eajug.jpg)\n\n### JDBC数据库全过程\n\n1. 加载驱动\n2. 创建数据库链接\n3. 创建Statement对象\n4. **执行SQL获取数据（MyBatis关注这里）**\n5. 数据转化\n6. 资源释放","source":"_posts/JAVA/Spring学习笔记.md","raw":"---\nlayout: post\ntitle: \"Spring学习笔记\"\ncomments: true\ndate: 2019-5-20 11:14:07\ntags: \n\t- JAVA\n---\n在面试中，经常会问，说说你对spring IOC和AOP的理解，问题很宽泛，似乎不知道从何说起。\n\n回答思路：1.先用通俗易懂的话解释下何为IOC和AOP---------》2.各自的实现原理-----------》3.自己的项目中如何使用\n\n<!--more--> \n\n## IOC\n\n#### 一.定义\n\nIOC是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，交给了Spring。 \n\nSpring IOC的作用\n\n1. 不必自己创建对象了（不必new出来了）\n2. 面向接口编程\n\n许多应用都是通过彼此间的相互合作来实现业务逻辑的，如类A要调用类B的方法，以前我们都是在类A中，通过自身new一个类B，然后在调用类B的方法，这样对象间的耦合度高了，现在我们把new类B的事情交给spring来做，在我们调用的时候，容器会为我们实例化。\n\n#### 二.依赖注入（DI）\n\n资源定位，即定义bean的xml（也可以使用@Bean）-------》载入--------》IOC容器注册，注册beanDefinition。\n\nIOC容器的初始化过程，一般不包含bean的依赖注入的实现，在spring IOC设计中，bean的注册和依赖注入是两个过程，，依赖注入一般发生在应用第一次索取bean的时候，但是也可以在xm中配置，在容器初始化的时候，这个bean就完成了初始化。\n\nSpring使用：单独使用Bean容器（Bean管理）。\n\nBean容器初始化基础：依赖两个包\n\n- org.springframework.beans 中的BeanFactory提供配置结构和基本功能，加载并初始化Bean\n- org.springframework.context 中的 ApplicationContext保存了Bean对象并在Spring中被广泛使用\n\nSpring注入是指在启动Spring容器加载bean配置的时候，完成对变量的赋值行为。\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1dg2ewfj20wp0c70ue.jpg)\n\n## AOP\n\n面向切面，所有业务都要处理的业务，如打印日志，登录拦截。要记录所有update*方法的执行时间时间，操作人等等信息，记录到日志，\n\n通过spring的AOP技术，就可以在不修改update*的代码的情况下完成该需求。\n\nspring用代理类包裹切面，把他们织入到Spring管理的bean中。也就是说代理类伪装成目标类，它会截取对目标类中方法的调用，让调用者对目标类的调用都先变成调用伪装类，伪装类中就先执行了切面，再把调用转发给真正的目标bean。\n\n前一种兄弟模式，spring会使用JDK的java.lang.reflect.Proxy类，它允许Spring动态生成一个新类来实现必要的接口，织入通知，并且把对这些接口的任何调用都转发到目标类。\n\n后一种父子模式，spring使用CGLIB库生成目标类的一个子类，在创建这个子类的时候，spring织入通知，并且把对这个子类的调用委托到目标类。\n\nSpring AOP 会动态选择使用 JDK 动态代理、CGLIB 来生成 AOP 代理，如果目标类实现了接口，Spring AOP 则无需 CGLIB 的支持，直接使用 JDK 提供的 Proxy 和 InvocationHandler 来生成 AOP 代理即可。\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1dpe89mj20ns0eajug.jpg)\n\n### JDBC数据库全过程\n\n1. 加载驱动\n2. 创建数据库链接\n3. 创建Statement对象\n4. **执行SQL获取数据（MyBatis关注这里）**\n5. 数据转化\n6. 资源释放","slug":"JAVA/Spring学习笔记","published":1,"updated":"2020-08-09T05:24:13.284Z","photos":[],"link":"","_id":"ckdmsee860026lguw2jh38398","content":"<p>在面试中，经常会问，说说你对spring IOC和AOP的理解，问题很宽泛，似乎不知道从何说起。</p>\n<p>回答思路：1.先用通俗易懂的话解释下何为IOC和AOP———》2.各自的实现原理———–》3.自己的项目中如何使用</p>\n<a id=\"more\"></a> \n<h2 id=\"IOC\"><a href=\"#IOC\" class=\"headerlink\" title=\"IOC\"></a>IOC</h2><h4 id=\"一-定义\"><a href=\"#一-定义\" class=\"headerlink\" title=\"一.定义\"></a>一.定义</h4><p>IOC是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，交给了Spring。 </p>\n<p>Spring IOC的作用</p>\n<ol>\n<li>不必自己创建对象了（不必new出来了）</li>\n<li>面向接口编程</li>\n</ol>\n<p>许多应用都是通过彼此间的相互合作来实现业务逻辑的，如类A要调用类B的方法，以前我们都是在类A中，通过自身new一个类B，然后在调用类B的方法，这样对象间的耦合度高了，现在我们把new类B的事情交给spring来做，在我们调用的时候，容器会为我们实例化。</p>\n<h4 id=\"二-依赖注入（DI）\"><a href=\"#二-依赖注入（DI）\" class=\"headerlink\" title=\"二.依赖注入（DI）\"></a>二.依赖注入（DI）</h4><p>资源定位，即定义bean的xml（也可以使用@Bean）——-》载入——–》IOC容器注册，注册beanDefinition。</p>\n<p>IOC容器的初始化过程，一般不包含bean的依赖注入的实现，在spring IOC设计中，bean的注册和依赖注入是两个过程，，依赖注入一般发生在应用第一次索取bean的时候，但是也可以在xm中配置，在容器初始化的时候，这个bean就完成了初始化。</p>\n<p>Spring使用：单独使用Bean容器（Bean管理）。</p>\n<p>Bean容器初始化基础：依赖两个包</p>\n<ul>\n<li>org.springframework.beans 中的BeanFactory提供配置结构和基本功能，加载并初始化Bean</li>\n<li>org.springframework.context 中的 ApplicationContext保存了Bean对象并在Spring中被广泛使用</li>\n</ul>\n<p>Spring注入是指在启动Spring容器加载bean配置的时候，完成对变量的赋值行为。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1dg2ewfj20wp0c70ue.jpg\" alt></p>\n<h2 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h2><p>面向切面，所有业务都要处理的业务，如打印日志，登录拦截。要记录所有update*方法的执行时间时间，操作人等等信息，记录到日志，</p>\n<p>通过spring的AOP技术，就可以在不修改update*的代码的情况下完成该需求。</p>\n<p>spring用代理类包裹切面，把他们织入到Spring管理的bean中。也就是说代理类伪装成目标类，它会截取对目标类中方法的调用，让调用者对目标类的调用都先变成调用伪装类，伪装类中就先执行了切面，再把调用转发给真正的目标bean。</p>\n<p>前一种兄弟模式，spring会使用JDK的java.lang.reflect.Proxy类，它允许Spring动态生成一个新类来实现必要的接口，织入通知，并且把对这些接口的任何调用都转发到目标类。</p>\n<p>后一种父子模式，spring使用CGLIB库生成目标类的一个子类，在创建这个子类的时候，spring织入通知，并且把对这个子类的调用委托到目标类。</p>\n<p>Spring AOP 会动态选择使用 JDK 动态代理、CGLIB 来生成 AOP 代理，如果目标类实现了接口，Spring AOP 则无需 CGLIB 的支持，直接使用 JDK 提供的 Proxy 和 InvocationHandler 来生成 AOP 代理即可。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1dpe89mj20ns0eajug.jpg\" alt></p>\n<h3 id=\"JDBC数据库全过程\"><a href=\"#JDBC数据库全过程\" class=\"headerlink\" title=\"JDBC数据库全过程\"></a>JDBC数据库全过程</h3><ol>\n<li>加载驱动</li>\n<li>创建数据库链接</li>\n<li>创建Statement对象</li>\n<li><strong>执行SQL获取数据（MyBatis关注这里）</strong></li>\n<li>数据转化</li>\n<li>资源释放</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>在面试中，经常会问，说说你对spring IOC和AOP的理解，问题很宽泛，似乎不知道从何说起。</p>\n<p>回答思路：1.先用通俗易懂的话解释下何为IOC和AOP———》2.各自的实现原理———–》3.自己的项目中如何使用</p>","more":"<h2 id=\"IOC\"><a href=\"#IOC\" class=\"headerlink\" title=\"IOC\"></a>IOC</h2><h4 id=\"一-定义\"><a href=\"#一-定义\" class=\"headerlink\" title=\"一.定义\"></a>一.定义</h4><p>IOC是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，交给了Spring。 </p>\n<p>Spring IOC的作用</p>\n<ol>\n<li>不必自己创建对象了（不必new出来了）</li>\n<li>面向接口编程</li>\n</ol>\n<p>许多应用都是通过彼此间的相互合作来实现业务逻辑的，如类A要调用类B的方法，以前我们都是在类A中，通过自身new一个类B，然后在调用类B的方法，这样对象间的耦合度高了，现在我们把new类B的事情交给spring来做，在我们调用的时候，容器会为我们实例化。</p>\n<h4 id=\"二-依赖注入（DI）\"><a href=\"#二-依赖注入（DI）\" class=\"headerlink\" title=\"二.依赖注入（DI）\"></a>二.依赖注入（DI）</h4><p>资源定位，即定义bean的xml（也可以使用@Bean）——-》载入——–》IOC容器注册，注册beanDefinition。</p>\n<p>IOC容器的初始化过程，一般不包含bean的依赖注入的实现，在spring IOC设计中，bean的注册和依赖注入是两个过程，，依赖注入一般发生在应用第一次索取bean的时候，但是也可以在xm中配置，在容器初始化的时候，这个bean就完成了初始化。</p>\n<p>Spring使用：单独使用Bean容器（Bean管理）。</p>\n<p>Bean容器初始化基础：依赖两个包</p>\n<ul>\n<li>org.springframework.beans 中的BeanFactory提供配置结构和基本功能，加载并初始化Bean</li>\n<li>org.springframework.context 中的 ApplicationContext保存了Bean对象并在Spring中被广泛使用</li>\n</ul>\n<p>Spring注入是指在启动Spring容器加载bean配置的时候，完成对变量的赋值行为。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1dg2ewfj20wp0c70ue.jpg\" alt></p>\n<h2 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h2><p>面向切面，所有业务都要处理的业务，如打印日志，登录拦截。要记录所有update*方法的执行时间时间，操作人等等信息，记录到日志，</p>\n<p>通过spring的AOP技术，就可以在不修改update*的代码的情况下完成该需求。</p>\n<p>spring用代理类包裹切面，把他们织入到Spring管理的bean中。也就是说代理类伪装成目标类，它会截取对目标类中方法的调用，让调用者对目标类的调用都先变成调用伪装类，伪装类中就先执行了切面，再把调用转发给真正的目标bean。</p>\n<p>前一种兄弟模式，spring会使用JDK的java.lang.reflect.Proxy类，它允许Spring动态生成一个新类来实现必要的接口，织入通知，并且把对这些接口的任何调用都转发到目标类。</p>\n<p>后一种父子模式，spring使用CGLIB库生成目标类的一个子类，在创建这个子类的时候，spring织入通知，并且把对这个子类的调用委托到目标类。</p>\n<p>Spring AOP 会动态选择使用 JDK 动态代理、CGLIB 来生成 AOP 代理，如果目标类实现了接口，Spring AOP 则无需 CGLIB 的支持，直接使用 JDK 提供的 Proxy 和 InvocationHandler 来生成 AOP 代理即可。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1dpe89mj20ns0eajug.jpg\" alt></p>\n<h3 id=\"JDBC数据库全过程\"><a href=\"#JDBC数据库全过程\" class=\"headerlink\" title=\"JDBC数据库全过程\"></a>JDBC数据库全过程</h3><ol>\n<li>加载驱动</li>\n<li>创建数据库链接</li>\n<li>创建Statement对象</li>\n<li><strong>执行SQL获取数据（MyBatis关注这里）</strong></li>\n<li>数据转化</li>\n<li>资源释放</li>\n</ol>"},{"title":"动态代理","date":"2019-10-02T02:33:27.000Z","_content":"\nJAVA中的动态代理：通过动态的创建一个新类，实现在运行时对类进行修改（如想知道某个类运行的时长）。\n\n使用JDK和Cglib实现动态代理。\n\n**Spring如何选择两种代理模式的？**\n\n1、如果目标对象实现了接口，则默认采用JDK动态代理。\n\n2、如果目标对象没有实现接口，则使用Cglib代理。\n\n我们可以通过DeBug看到生成的代理类后缀不同来区别。\n\n![image.png](http://ww1.sinaimg.cn/large/aacc02d8gy1g7jo9m3ucyj20no06a74i.jpg)\n\n<!--more-->\n\n```java\npackage com.example.rabbitmqtest.demo.dynamicproxy;\n\nimport java.lang.reflect.Proxy;\n\npublic class DynamicMain {\n\n    public static void main(String[] args) {\n\n        System.out.println(\"=======JDK=======\");\n\n        Sell sell = new Vendor();\n        //创建中介类实例\n        DynamicProxy inter = new DynamicProxy(sell);\n        //加上这句将会产生一个$Proxy0.class文件，这个文件即为动态生成的代理类文件\n        //System.getProperties().put(\"sun.misc.ProxyGenerator.saveGeneratedFiles\",\"true\");\n\n        //获取代理类实例sell\n        Sell jdkProxy = (Sell)(Proxy.newProxyInstance(Sell.class.getClassLoader(), sell.getClass().getInterfaces(), inter));\n        System.out.println(jdkProxy.getClass());\n        //通过代理类对象调用代理类方法，实际上会转到invoke方法调用\n        jdkProxy.sell();\n\n        System.out.println(\"=======Cglib=======\");\n\n        //代理对象\n        Sell proxy = (Sell) new CglibProxy(new Vendor()).getProxyInstance();\n        System.out.println(proxy.getClass());\n        //执行代理对象方法\n        proxy.sell();\n\n    }\n\n}\n```\n\n```java\npackage com.example.rabbitmqtest.demo.dynamicproxy;\n\n/**\n * 委托类和代理类都实现了Sell接口\n */\npublic interface Sell {\n    void sell();\n}\n```\n\n```java\npackage com.example.rabbitmqtest.demo.dynamicproxy;\n\n/**\n * 生产厂家\n */\npublic class Vendor implements Sell {\n    public void sell() {\n        System.out.println(\"In sell method\");\n    }\n}\n```\n\n```java\npackage com.example.rabbitmqtest.demo.dynamicproxy;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n\npublic class DynamicProxy implements InvocationHandler{\n\n    //obj为委托类对象;\n    private Object obj;\n\n    public DynamicProxy(Object obj) {\n        this.obj = obj;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"jdk before\");\n        Object result = method.invoke(obj, args);\n        System.out.println(\"jdk after\");\n        return result;\n    }\n}\n```\n\n```java\npackage com.example.rabbitmqtest.demo.dynamicproxy;\n\nimport org.springframework.cglib.proxy.Enhancer;\nimport org.springframework.cglib.proxy.MethodInterceptor;\nimport org.springframework.cglib.proxy.MethodProxy;\n\nimport java.lang.reflect.Method;\n\npublic class CglibProxy implements MethodInterceptor {\n\n\n    private Object target;\n\n    public CglibProxy(Object target) {\n        this.target = target;\n    }\n\n\n    //为目标对象生成代理对象\n    public Object getProxyInstance() {\n        //工具类\n        Enhancer en = new Enhancer();\n        //设置父类\n        en.setSuperclass(target.getClass());\n        //设置回调函数\n        en.setCallback(this);\n        //创建子类对象代理\n        return en.create();\n    }\n\n    @Override\n    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n        System.out.println(\"cglib before\");\n        Object result = method.invoke(target, args);\n        System.out.println(\"cglib after\");\n        return result;\n    }\n}\n```\n\n","source":"_posts/JAVA/动态代理.md","raw":"---\ntitle: 动态代理\ndate: 2019-10-02 10:33:27\ntags: JAVA\n---\n\nJAVA中的动态代理：通过动态的创建一个新类，实现在运行时对类进行修改（如想知道某个类运行的时长）。\n\n使用JDK和Cglib实现动态代理。\n\n**Spring如何选择两种代理模式的？**\n\n1、如果目标对象实现了接口，则默认采用JDK动态代理。\n\n2、如果目标对象没有实现接口，则使用Cglib代理。\n\n我们可以通过DeBug看到生成的代理类后缀不同来区别。\n\n![image.png](http://ww1.sinaimg.cn/large/aacc02d8gy1g7jo9m3ucyj20no06a74i.jpg)\n\n<!--more-->\n\n```java\npackage com.example.rabbitmqtest.demo.dynamicproxy;\n\nimport java.lang.reflect.Proxy;\n\npublic class DynamicMain {\n\n    public static void main(String[] args) {\n\n        System.out.println(\"=======JDK=======\");\n\n        Sell sell = new Vendor();\n        //创建中介类实例\n        DynamicProxy inter = new DynamicProxy(sell);\n        //加上这句将会产生一个$Proxy0.class文件，这个文件即为动态生成的代理类文件\n        //System.getProperties().put(\"sun.misc.ProxyGenerator.saveGeneratedFiles\",\"true\");\n\n        //获取代理类实例sell\n        Sell jdkProxy = (Sell)(Proxy.newProxyInstance(Sell.class.getClassLoader(), sell.getClass().getInterfaces(), inter));\n        System.out.println(jdkProxy.getClass());\n        //通过代理类对象调用代理类方法，实际上会转到invoke方法调用\n        jdkProxy.sell();\n\n        System.out.println(\"=======Cglib=======\");\n\n        //代理对象\n        Sell proxy = (Sell) new CglibProxy(new Vendor()).getProxyInstance();\n        System.out.println(proxy.getClass());\n        //执行代理对象方法\n        proxy.sell();\n\n    }\n\n}\n```\n\n```java\npackage com.example.rabbitmqtest.demo.dynamicproxy;\n\n/**\n * 委托类和代理类都实现了Sell接口\n */\npublic interface Sell {\n    void sell();\n}\n```\n\n```java\npackage com.example.rabbitmqtest.demo.dynamicproxy;\n\n/**\n * 生产厂家\n */\npublic class Vendor implements Sell {\n    public void sell() {\n        System.out.println(\"In sell method\");\n    }\n}\n```\n\n```java\npackage com.example.rabbitmqtest.demo.dynamicproxy;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n\npublic class DynamicProxy implements InvocationHandler{\n\n    //obj为委托类对象;\n    private Object obj;\n\n    public DynamicProxy(Object obj) {\n        this.obj = obj;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"jdk before\");\n        Object result = method.invoke(obj, args);\n        System.out.println(\"jdk after\");\n        return result;\n    }\n}\n```\n\n```java\npackage com.example.rabbitmqtest.demo.dynamicproxy;\n\nimport org.springframework.cglib.proxy.Enhancer;\nimport org.springframework.cglib.proxy.MethodInterceptor;\nimport org.springframework.cglib.proxy.MethodProxy;\n\nimport java.lang.reflect.Method;\n\npublic class CglibProxy implements MethodInterceptor {\n\n\n    private Object target;\n\n    public CglibProxy(Object target) {\n        this.target = target;\n    }\n\n\n    //为目标对象生成代理对象\n    public Object getProxyInstance() {\n        //工具类\n        Enhancer en = new Enhancer();\n        //设置父类\n        en.setSuperclass(target.getClass());\n        //设置回调函数\n        en.setCallback(this);\n        //创建子类对象代理\n        return en.create();\n    }\n\n    @Override\n    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n        System.out.println(\"cglib before\");\n        Object result = method.invoke(target, args);\n        System.out.println(\"cglib after\");\n        return result;\n    }\n}\n```\n\n","slug":"JAVA/动态代理","published":1,"updated":"2020-08-09T05:24:13.285Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdmsee870028lguwwjfribng","content":"<p>JAVA中的动态代理：通过动态的创建一个新类，实现在运行时对类进行修改（如想知道某个类运行的时长）。</p>\n<p>使用JDK和Cglib实现动态代理。</p>\n<p><strong>Spring如何选择两种代理模式的？</strong></p>\n<p>1、如果目标对象实现了接口，则默认采用JDK动态代理。</p>\n<p>2、如果目标对象没有实现接口，则使用Cglib代理。</p>\n<p>我们可以通过DeBug看到生成的代理类后缀不同来区别。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1g7jo9m3ucyj20no06a74i.jpg\" alt=\"image.png\"></p>\n<a id=\"more\"></a>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.rabbitmqtest.demo.dynamicproxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Proxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicMain</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"=======JDK=======\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Sell sell = <span class=\"keyword\">new</span> Vendor();</span><br><span class=\"line\">        <span class=\"comment\">//创建中介类实例</span></span><br><span class=\"line\">        DynamicProxy inter = <span class=\"keyword\">new</span> DynamicProxy(sell);</span><br><span class=\"line\">        <span class=\"comment\">//加上这句将会产生一个$Proxy0.class文件，这个文件即为动态生成的代理类文件</span></span><br><span class=\"line\">        <span class=\"comment\">//System.getProperties().put(\"sun.misc.ProxyGenerator.saveGeneratedFiles\",\"true\");</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//获取代理类实例sell</span></span><br><span class=\"line\">        Sell jdkProxy = (Sell)(Proxy.newProxyInstance(Sell.class.getClassLoader(), sell.getClass().getInterfaces(), inter));</span><br><span class=\"line\">        System.out.println(jdkProxy.getClass());</span><br><span class=\"line\">        <span class=\"comment\">//通过代理类对象调用代理类方法，实际上会转到invoke方法调用</span></span><br><span class=\"line\">        jdkProxy.sell();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"=======Cglib=======\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//代理对象</span></span><br><span class=\"line\">        Sell proxy = (Sell) <span class=\"keyword\">new</span> CglibProxy(<span class=\"keyword\">new</span> Vendor()).getProxyInstance();</span><br><span class=\"line\">        System.out.println(proxy.getClass());</span><br><span class=\"line\">        <span class=\"comment\">//执行代理对象方法</span></span><br><span class=\"line\">        proxy.sell();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.rabbitmqtest.demo.dynamicproxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 委托类和代理类都实现了Sell接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Sell</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sell</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.rabbitmqtest.demo.dynamicproxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 生产厂家</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vendor</span> <span class=\"keyword\">implements</span> <span class=\"title\">Sell</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sell</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"In sell method\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.rabbitmqtest.demo.dynamicproxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//obj为委托类对象;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object obj;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DynamicProxy</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.obj = obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"jdk before\"</span>);</span><br><span class=\"line\">        Object result = method.invoke(obj, args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"jdk after\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.rabbitmqtest.demo.dynamicproxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CglibProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">MethodInterceptor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CglibProxy</span><span class=\"params\">(Object target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//为目标对象生成代理对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getProxyInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//工具类</span></span><br><span class=\"line\">        Enhancer en = <span class=\"keyword\">new</span> Enhancer();</span><br><span class=\"line\">        <span class=\"comment\">//设置父类</span></span><br><span class=\"line\">        en.setSuperclass(target.getClass());</span><br><span class=\"line\">        <span class=\"comment\">//设置回调函数</span></span><br><span class=\"line\">        en.setCallback(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">//创建子类对象代理</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> en.create();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">intercept</span><span class=\"params\">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"cglib before\"</span>);</span><br><span class=\"line\">        Object result = method.invoke(target, args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"cglib after\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>JAVA中的动态代理：通过动态的创建一个新类，实现在运行时对类进行修改（如想知道某个类运行的时长）。</p>\n<p>使用JDK和Cglib实现动态代理。</p>\n<p><strong>Spring如何选择两种代理模式的？</strong></p>\n<p>1、如果目标对象实现了接口，则默认采用JDK动态代理。</p>\n<p>2、如果目标对象没有实现接口，则使用Cglib代理。</p>\n<p>我们可以通过DeBug看到生成的代理类后缀不同来区别。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8gy1g7jo9m3ucyj20no06a74i.jpg\" alt=\"image.png\"></p>","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.rabbitmqtest.demo.dynamicproxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Proxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicMain</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"=======JDK=======\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Sell sell = <span class=\"keyword\">new</span> Vendor();</span><br><span class=\"line\">        <span class=\"comment\">//创建中介类实例</span></span><br><span class=\"line\">        DynamicProxy inter = <span class=\"keyword\">new</span> DynamicProxy(sell);</span><br><span class=\"line\">        <span class=\"comment\">//加上这句将会产生一个$Proxy0.class文件，这个文件即为动态生成的代理类文件</span></span><br><span class=\"line\">        <span class=\"comment\">//System.getProperties().put(\"sun.misc.ProxyGenerator.saveGeneratedFiles\",\"true\");</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//获取代理类实例sell</span></span><br><span class=\"line\">        Sell jdkProxy = (Sell)(Proxy.newProxyInstance(Sell.class.getClassLoader(), sell.getClass().getInterfaces(), inter));</span><br><span class=\"line\">        System.out.println(jdkProxy.getClass());</span><br><span class=\"line\">        <span class=\"comment\">//通过代理类对象调用代理类方法，实际上会转到invoke方法调用</span></span><br><span class=\"line\">        jdkProxy.sell();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"=======Cglib=======\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//代理对象</span></span><br><span class=\"line\">        Sell proxy = (Sell) <span class=\"keyword\">new</span> CglibProxy(<span class=\"keyword\">new</span> Vendor()).getProxyInstance();</span><br><span class=\"line\">        System.out.println(proxy.getClass());</span><br><span class=\"line\">        <span class=\"comment\">//执行代理对象方法</span></span><br><span class=\"line\">        proxy.sell();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.rabbitmqtest.demo.dynamicproxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 委托类和代理类都实现了Sell接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Sell</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sell</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.rabbitmqtest.demo.dynamicproxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 生产厂家</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vendor</span> <span class=\"keyword\">implements</span> <span class=\"title\">Sell</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sell</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"In sell method\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.rabbitmqtest.demo.dynamicproxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//obj为委托类对象;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object obj;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DynamicProxy</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.obj = obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"jdk before\"</span>);</span><br><span class=\"line\">        Object result = method.invoke(obj, args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"jdk after\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.rabbitmqtest.demo.dynamicproxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CglibProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">MethodInterceptor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CglibProxy</span><span class=\"params\">(Object target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//为目标对象生成代理对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getProxyInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//工具类</span></span><br><span class=\"line\">        Enhancer en = <span class=\"keyword\">new</span> Enhancer();</span><br><span class=\"line\">        <span class=\"comment\">//设置父类</span></span><br><span class=\"line\">        en.setSuperclass(target.getClass());</span><br><span class=\"line\">        <span class=\"comment\">//设置回调函数</span></span><br><span class=\"line\">        en.setCallback(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">//创建子类对象代理</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> en.create();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">intercept</span><span class=\"params\">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"cglib before\"</span>);</span><br><span class=\"line\">        Object result = method.invoke(target, args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"cglib after\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"二分查找容易出错的3个地方","date":"2019-12-22T08:01:19.000Z","_content":"\n```java\npackage com.leetcode;\n\npublic class BinarySearch {\n\n    public static void main(String[] args) {\n        Integer [] a = {1,2,3,4,5,6,7,9,10};\n        System.out.println(binarySearch(a,  10));\n    }\n\n    private static int binarySearch(Integer[] a, int value) {\n\n        int low = 0;\n        int high = a.length-1;\n\n        while (low <= high){\n            int mid = low + ((high-low) >> 1);\n            if (a[mid] == value){\n                return  mid;\n            } else if (a[mid] < value){\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return  -1;\n    }\n}\n```\n\n#### **1.循环退出条件**\n\n注意是 low<=high，而不是 low<high。\n\n#### 2.mid 的取值\n\n实际上，mid=(low+high)/2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会溢出。改进的方法是将 mid 的计算方式写成 low+(high-low)/2。更进一步，如果要将性能优化到极致的话，我们可以将这里的除以 2 操作转化成位运算 low+((high-low)>>1)。因为相比除法运算来说，计算机处理位运算要快得多。\n\n#### 3.low 和 high 的更新\n\nlow=mid+1，high=mid-1。注意这里的 +1 和 -1，如果直接写成 low=mid 或者 high=mid，就可能会发生死循环。比如，当 high=3，low=3 时，如果 a[3] 不等于value，就会导致一直循环不退出。","source":"_posts/JAVA/二分查找容易出错的3个地方.md","raw":"---\ntitle: 二分查找容易出错的3个地方\ndate: 2019-12-22 16:01:19\ntags: JAVA\n---\n\n```java\npackage com.leetcode;\n\npublic class BinarySearch {\n\n    public static void main(String[] args) {\n        Integer [] a = {1,2,3,4,5,6,7,9,10};\n        System.out.println(binarySearch(a,  10));\n    }\n\n    private static int binarySearch(Integer[] a, int value) {\n\n        int low = 0;\n        int high = a.length-1;\n\n        while (low <= high){\n            int mid = low + ((high-low) >> 1);\n            if (a[mid] == value){\n                return  mid;\n            } else if (a[mid] < value){\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return  -1;\n    }\n}\n```\n\n#### **1.循环退出条件**\n\n注意是 low<=high，而不是 low<high。\n\n#### 2.mid 的取值\n\n实际上，mid=(low+high)/2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会溢出。改进的方法是将 mid 的计算方式写成 low+(high-low)/2。更进一步，如果要将性能优化到极致的话，我们可以将这里的除以 2 操作转化成位运算 low+((high-low)>>1)。因为相比除法运算来说，计算机处理位运算要快得多。\n\n#### 3.low 和 high 的更新\n\nlow=mid+1，high=mid-1。注意这里的 +1 和 -1，如果直接写成 low=mid 或者 high=mid，就可能会发生死循环。比如，当 high=3，low=3 时，如果 a[3] 不等于value，就会导致一直循环不退出。","slug":"JAVA/二分查找容易出错的3个地方","published":1,"updated":"2020-08-09T05:24:13.284Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdmsee88002alguwata73xso","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.leetcode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinarySearch</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Integer [] a = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">        System.out.println(binarySearch(a,  <span class=\"number\">10</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(Integer[] a, <span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> high = a.length-<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (low &lt;= high)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = low + ((high-low) &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[mid] == value)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>  mid;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[mid] &lt; value)&#123;</span><br><span class=\"line\">                low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-循环退出条件\"><a href=\"#1-循环退出条件\" class=\"headerlink\" title=\"1.循环退出条件\"></a><strong>1.循环退出条件</strong></h4><p>注意是 low&lt;=high，而不是 low&lt;high。</p>\n<h4 id=\"2-mid-的取值\"><a href=\"#2-mid-的取值\" class=\"headerlink\" title=\"2.mid 的取值\"></a>2.mid 的取值</h4><p>实际上，mid=(low+high)/2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会溢出。改进的方法是将 mid 的计算方式写成 low+(high-low)/2。更进一步，如果要将性能优化到极致的话，我们可以将这里的除以 2 操作转化成位运算 low+((high-low)&gt;&gt;1)。因为相比除法运算来说，计算机处理位运算要快得多。</p>\n<h4 id=\"3-low-和-high-的更新\"><a href=\"#3-low-和-high-的更新\" class=\"headerlink\" title=\"3.low 和 high 的更新\"></a>3.low 和 high 的更新</h4><p>low=mid+1，high=mid-1。注意这里的 +1 和 -1，如果直接写成 low=mid 或者 high=mid，就可能会发生死循环。比如，当 high=3，low=3 时，如果 a[3] 不等于value，就会导致一直循环不退出。</p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.leetcode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinarySearch</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Integer [] a = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">        System.out.println(binarySearch(a,  <span class=\"number\">10</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(Integer[] a, <span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> high = a.length-<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (low &lt;= high)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = low + ((high-low) &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[mid] == value)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>  mid;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[mid] &lt; value)&#123;</span><br><span class=\"line\">                low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-循环退出条件\"><a href=\"#1-循环退出条件\" class=\"headerlink\" title=\"1.循环退出条件\"></a><strong>1.循环退出条件</strong></h4><p>注意是 low&lt;=high，而不是 low&lt;high。</p>\n<h4 id=\"2-mid-的取值\"><a href=\"#2-mid-的取值\" class=\"headerlink\" title=\"2.mid 的取值\"></a>2.mid 的取值</h4><p>实际上，mid=(low+high)/2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会溢出。改进的方法是将 mid 的计算方式写成 low+(high-low)/2。更进一步，如果要将性能优化到极致的话，我们可以将这里的除以 2 操作转化成位运算 low+((high-low)&gt;&gt;1)。因为相比除法运算来说，计算机处理位运算要快得多。</p>\n<h4 id=\"3-low-和-high-的更新\"><a href=\"#3-low-和-high-的更新\" class=\"headerlink\" title=\"3.low 和 high 的更新\"></a>3.low 和 high 的更新</h4><p>low=mid+1，high=mid-1。注意这里的 +1 和 -1，如果直接写成 low=mid 或者 high=mid，就可能会发生死循环。比如，当 high=3，low=3 时，如果 a[3] 不等于value，就会导致一直循环不退出。</p>\n"},{"title":"深入理解JVM","date":"2019-11-11T05:17:40.000Z","_content":"\n### 1. Java程序如何跑起来的？\n\n从虚拟机视角来看，编译完成的class文件会加载到JVM。\n\n- 加载后的Java类会被存放于**方法区**中，创建class对象。\n- 在运行过程中，每当调用进入一个Java方法，JVM会在当前的线程Java方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。\n- 当退出当前执行的方法时，JVM会弹出当前线程的当前栈帧，并将之舍弃。\n\n**栈帧用于存放局部变量表，操作数栈，动态链接，方法出口信息等。**\n\nBootStrap ClassLoader <JAVA_HOME>/lib\n\n双亲委派模型：\n\n1.防止类重复加载。\n\n2.防止对JAVA核心API的篡改。\n\n<!--more-->\n\n### 2. JVM触发初始化的情况\n\n- 当虚拟机启动时，初始化用户指定的主类。\n- 当遇到用以新建目标类实例的new指令时，初始化new指令的目标类。\n- 当遇到调用静态方法的指令时，初始化该静态方法所在的类。\n- 当遇到访问静态字段额指令时，初始化该静态字段所在的类。\n- 子类的初始化会触发父类的初始化。\n- 如果一个接口定义了default方法，那么直接实现或间接实现该接口的类的初始化，会触发该接口的初始化。\n- 使用反射API对某个类进行反射调用时，初始化这个类。\n- 当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。\n\n### 3. 在Hotspot虚拟机中，对象的内存布局。\n\n对象在内存布局分为3块区域：对象头，实例数据和对齐填充。\n\n对象头包含2部分，第一部分存储对象运行的数据如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳，又称为**Mark Word**。另一部分是类型指针。\n\n### 4. JMM与内存可见性\n\nsynchronized: 通过高级字节码monitor_enter和monitor_exit实现的。\n\nvolatile: 强制变量的赋值会强制刷新回主内存，强制变量的读取从主内存中重新加载。","source":"_posts/JAVA/深入理解JVM.md","raw":"---\ntitle: 深入理解JVM\ndate: 2019-11-11 13:17:40\ntags: Java\n\n---\n\n### 1. Java程序如何跑起来的？\n\n从虚拟机视角来看，编译完成的class文件会加载到JVM。\n\n- 加载后的Java类会被存放于**方法区**中，创建class对象。\n- 在运行过程中，每当调用进入一个Java方法，JVM会在当前的线程Java方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。\n- 当退出当前执行的方法时，JVM会弹出当前线程的当前栈帧，并将之舍弃。\n\n**栈帧用于存放局部变量表，操作数栈，动态链接，方法出口信息等。**\n\nBootStrap ClassLoader <JAVA_HOME>/lib\n\n双亲委派模型：\n\n1.防止类重复加载。\n\n2.防止对JAVA核心API的篡改。\n\n<!--more-->\n\n### 2. JVM触发初始化的情况\n\n- 当虚拟机启动时，初始化用户指定的主类。\n- 当遇到用以新建目标类实例的new指令时，初始化new指令的目标类。\n- 当遇到调用静态方法的指令时，初始化该静态方法所在的类。\n- 当遇到访问静态字段额指令时，初始化该静态字段所在的类。\n- 子类的初始化会触发父类的初始化。\n- 如果一个接口定义了default方法，那么直接实现或间接实现该接口的类的初始化，会触发该接口的初始化。\n- 使用反射API对某个类进行反射调用时，初始化这个类。\n- 当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。\n\n### 3. 在Hotspot虚拟机中，对象的内存布局。\n\n对象在内存布局分为3块区域：对象头，实例数据和对齐填充。\n\n对象头包含2部分，第一部分存储对象运行的数据如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳，又称为**Mark Word**。另一部分是类型指针。\n\n### 4. JMM与内存可见性\n\nsynchronized: 通过高级字节码monitor_enter和monitor_exit实现的。\n\nvolatile: 强制变量的赋值会强制刷新回主内存，强制变量的读取从主内存中重新加载。","slug":"JAVA/深入理解JVM","published":1,"updated":"2020-08-09T05:24:13.286Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdmsee89002clguwatpfeisc","content":"<h3 id=\"1-Java程序如何跑起来的？\"><a href=\"#1-Java程序如何跑起来的？\" class=\"headerlink\" title=\"1. Java程序如何跑起来的？\"></a>1. Java程序如何跑起来的？</h3><p>从虚拟机视角来看，编译完成的class文件会加载到JVM。</p>\n<ul>\n<li>加载后的Java类会被存放于<strong>方法区</strong>中，创建class对象。</li>\n<li>在运行过程中，每当调用进入一个Java方法，JVM会在当前的线程Java方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。</li>\n<li>当退出当前执行的方法时，JVM会弹出当前线程的当前栈帧，并将之舍弃。</li>\n</ul>\n<p><strong>栈帧用于存放局部变量表，操作数栈，动态链接，方法出口信息等。</strong></p>\n<p>BootStrap ClassLoader &lt;JAVA_HOME&gt;/lib</p>\n<p>双亲委派模型：</p>\n<p>1.防止类重复加载。</p>\n<p>2.防止对JAVA核心API的篡改。</p>\n<a id=\"more\"></a>\n<h3 id=\"2-JVM触发初始化的情况\"><a href=\"#2-JVM触发初始化的情况\" class=\"headerlink\" title=\"2. JVM触发初始化的情况\"></a>2. JVM触发初始化的情况</h3><ul>\n<li>当虚拟机启动时，初始化用户指定的主类。</li>\n<li>当遇到用以新建目标类实例的new指令时，初始化new指令的目标类。</li>\n<li>当遇到调用静态方法的指令时，初始化该静态方法所在的类。</li>\n<li>当遇到访问静态字段额指令时，初始化该静态字段所在的类。</li>\n<li>子类的初始化会触发父类的初始化。</li>\n<li>如果一个接口定义了default方法，那么直接实现或间接实现该接口的类的初始化，会触发该接口的初始化。</li>\n<li>使用反射API对某个类进行反射调用时，初始化这个类。</li>\n<li>当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。</li>\n</ul>\n<h3 id=\"3-在Hotspot虚拟机中，对象的内存布局。\"><a href=\"#3-在Hotspot虚拟机中，对象的内存布局。\" class=\"headerlink\" title=\"3. 在Hotspot虚拟机中，对象的内存布局。\"></a>3. 在Hotspot虚拟机中，对象的内存布局。</h3><p>对象在内存布局分为3块区域：对象头，实例数据和对齐填充。</p>\n<p>对象头包含2部分，第一部分存储对象运行的数据如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳，又称为<strong>Mark Word</strong>。另一部分是类型指针。</p>\n<h3 id=\"4-JMM与内存可见性\"><a href=\"#4-JMM与内存可见性\" class=\"headerlink\" title=\"4. JMM与内存可见性\"></a>4. JMM与内存可见性</h3><p>synchronized: 通过高级字节码monitor_enter和monitor_exit实现的。</p>\n<p>volatile: 强制变量的赋值会强制刷新回主内存，强制变量的读取从主内存中重新加载。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-Java程序如何跑起来的？\"><a href=\"#1-Java程序如何跑起来的？\" class=\"headerlink\" title=\"1. Java程序如何跑起来的？\"></a>1. Java程序如何跑起来的？</h3><p>从虚拟机视角来看，编译完成的class文件会加载到JVM。</p>\n<ul>\n<li>加载后的Java类会被存放于<strong>方法区</strong>中，创建class对象。</li>\n<li>在运行过程中，每当调用进入一个Java方法，JVM会在当前的线程Java方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。</li>\n<li>当退出当前执行的方法时，JVM会弹出当前线程的当前栈帧，并将之舍弃。</li>\n</ul>\n<p><strong>栈帧用于存放局部变量表，操作数栈，动态链接，方法出口信息等。</strong></p>\n<p>BootStrap ClassLoader &lt;JAVA_HOME&gt;/lib</p>\n<p>双亲委派模型：</p>\n<p>1.防止类重复加载。</p>\n<p>2.防止对JAVA核心API的篡改。</p>","more":"<h3 id=\"2-JVM触发初始化的情况\"><a href=\"#2-JVM触发初始化的情况\" class=\"headerlink\" title=\"2. JVM触发初始化的情况\"></a>2. JVM触发初始化的情况</h3><ul>\n<li>当虚拟机启动时，初始化用户指定的主类。</li>\n<li>当遇到用以新建目标类实例的new指令时，初始化new指令的目标类。</li>\n<li>当遇到调用静态方法的指令时，初始化该静态方法所在的类。</li>\n<li>当遇到访问静态字段额指令时，初始化该静态字段所在的类。</li>\n<li>子类的初始化会触发父类的初始化。</li>\n<li>如果一个接口定义了default方法，那么直接实现或间接实现该接口的类的初始化，会触发该接口的初始化。</li>\n<li>使用反射API对某个类进行反射调用时，初始化这个类。</li>\n<li>当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。</li>\n</ul>\n<h3 id=\"3-在Hotspot虚拟机中，对象的内存布局。\"><a href=\"#3-在Hotspot虚拟机中，对象的内存布局。\" class=\"headerlink\" title=\"3. 在Hotspot虚拟机中，对象的内存布局。\"></a>3. 在Hotspot虚拟机中，对象的内存布局。</h3><p>对象在内存布局分为3块区域：对象头，实例数据和对齐填充。</p>\n<p>对象头包含2部分，第一部分存储对象运行的数据如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳，又称为<strong>Mark Word</strong>。另一部分是类型指针。</p>\n<h3 id=\"4-JMM与内存可见性\"><a href=\"#4-JMM与内存可见性\" class=\"headerlink\" title=\"4. JMM与内存可见性\"></a>4. JMM与内存可见性</h3><p>synchronized: 通过高级字节码monitor_enter和monitor_exit实现的。</p>\n<p>volatile: 强制变量的赋值会强制刷新回主内存，强制变量的读取从主内存中重新加载。</p>"},{"title":"单例模式","date":"2019-10-28T15:09:40.000Z","_content":"\n### 静态内部类\n\n```java\npublic class Singleton {\n \tprivate Singleton(){\n    \n    }\n\n    private static class LazyLoader{\n        final static Singleton INSTANCE = new Singleton();\n    }\n    \n    // 只有当调用Singleton.getInstance时，程序才会访问LazyHolder.INSTANCE,才会触发对LazyLoader的初始化\n    // 然后新建一个实例\n    // 由于类初始化是线程安全的，并且仅被执行一次，可以确保多线程情况只有一个实例。\n    public static Singleton getInstance(){\n        return LazyLoader.INSTANCE;\n    }\n}\n```\n\n只有当调用Singleton.getInstance时，程序才会访问LazyHolder.INSTANCE,才会触发对LazyLoader的初始化(当遇到访问静态字段的指令时，初始化该静态字段所在的类)，由于类初始化是通过加锁的，并且仅被执行一次，可以确保多线程情况只有一个实例。\n\n<!--more-->\n\n### 双重检查\n\n```java\npublic class Singleton {\n\n    // instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。\n    // 1.给 instance 分配内存\n    // 2.调用 Singleton 的构造函数来初始化成员变量\n    // 3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）\n    // 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，\n    // 最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，\n    // 这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后报错。\n    private volatile static Singleton singleton;\n\n    private int a = 0;\n\n    private Singleton(){\n\n    }\n\n    public static Singleton getSingleton(){\n        if (singleton == null){\n            // 通过在synchronized的外面增加一层判断，就可以在对象一经创建以后，不再进入synchronized同步块。\n            // 这种方案不仅减小了锁的粒度，保证了线程安全，性能方面也得到了大幅提升。\n            synchronized (Singleton.class){\n                if (singleton == null){\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n}\n```\n\n","source":"_posts/JAVA/单例模式.md","raw":"---\ntitle: 单例模式\ndate: 2019-10-28 23:09:40\ntags: JAVA\n---\n\n### 静态内部类\n\n```java\npublic class Singleton {\n \tprivate Singleton(){\n    \n    }\n\n    private static class LazyLoader{\n        final static Singleton INSTANCE = new Singleton();\n    }\n    \n    // 只有当调用Singleton.getInstance时，程序才会访问LazyHolder.INSTANCE,才会触发对LazyLoader的初始化\n    // 然后新建一个实例\n    // 由于类初始化是线程安全的，并且仅被执行一次，可以确保多线程情况只有一个实例。\n    public static Singleton getInstance(){\n        return LazyLoader.INSTANCE;\n    }\n}\n```\n\n只有当调用Singleton.getInstance时，程序才会访问LazyHolder.INSTANCE,才会触发对LazyLoader的初始化(当遇到访问静态字段的指令时，初始化该静态字段所在的类)，由于类初始化是通过加锁的，并且仅被执行一次，可以确保多线程情况只有一个实例。\n\n<!--more-->\n\n### 双重检查\n\n```java\npublic class Singleton {\n\n    // instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。\n    // 1.给 instance 分配内存\n    // 2.调用 Singleton 的构造函数来初始化成员变量\n    // 3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）\n    // 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，\n    // 最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，\n    // 这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后报错。\n    private volatile static Singleton singleton;\n\n    private int a = 0;\n\n    private Singleton(){\n\n    }\n\n    public static Singleton getSingleton(){\n        if (singleton == null){\n            // 通过在synchronized的外面增加一层判断，就可以在对象一经创建以后，不再进入synchronized同步块。\n            // 这种方案不仅减小了锁的粒度，保证了线程安全，性能方面也得到了大幅提升。\n            synchronized (Singleton.class){\n                if (singleton == null){\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n}\n```\n\n","slug":"JAVA/单例模式","published":1,"updated":"2020-08-09T05:24:13.285Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdmsee8a002elguwx6496d1z","content":"<h3 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"> \t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LazyLoader</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 只有当调用Singleton.getInstance时，程序才会访问LazyHolder.INSTANCE,才会触发对LazyLoader的初始化</span></span><br><span class=\"line\">    <span class=\"comment\">// 然后新建一个实例</span></span><br><span class=\"line\">    <span class=\"comment\">// 由于类初始化是线程安全的，并且仅被执行一次，可以确保多线程情况只有一个实例。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> LazyLoader.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只有当调用Singleton.getInstance时，程序才会访问LazyHolder.INSTANCE,才会触发对LazyLoader的初始化(当遇到访问静态字段的指令时，初始化该静态字段所在的类)，由于类初始化是通过加锁的，并且仅被执行一次，可以确保多线程情况只有一个实例。</p>\n<a id=\"more\"></a>\n<h3 id=\"双重检查\"><a href=\"#双重检查\" class=\"headerlink\" title=\"双重检查\"></a>双重检查</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.给 instance 分配内存</span></span><br><span class=\"line\">    <span class=\"comment\">// 2.调用 Singleton 的构造函数来初始化成员变量</span></span><br><span class=\"line\">    <span class=\"comment\">// 3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</span></span><br><span class=\"line\">    <span class=\"comment\">// 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，</span></span><br><span class=\"line\">    <span class=\"comment\">// 最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，</span></span><br><span class=\"line\">    <span class=\"comment\">// 这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后报错。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通过在synchronized的外面增加一层判断，就可以在对象一经创建以后，不再进入synchronized同步块。</span></span><br><span class=\"line\">            <span class=\"comment\">// 这种方案不仅减小了锁的粒度，保证了线程安全，性能方面也得到了大幅提升。</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                    singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"> \t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LazyLoader</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 只有当调用Singleton.getInstance时，程序才会访问LazyHolder.INSTANCE,才会触发对LazyLoader的初始化</span></span><br><span class=\"line\">    <span class=\"comment\">// 然后新建一个实例</span></span><br><span class=\"line\">    <span class=\"comment\">// 由于类初始化是线程安全的，并且仅被执行一次，可以确保多线程情况只有一个实例。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> LazyLoader.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只有当调用Singleton.getInstance时，程序才会访问LazyHolder.INSTANCE,才会触发对LazyLoader的初始化(当遇到访问静态字段的指令时，初始化该静态字段所在的类)，由于类初始化是通过加锁的，并且仅被执行一次，可以确保多线程情况只有一个实例。</p>","more":"<h3 id=\"双重检查\"><a href=\"#双重检查\" class=\"headerlink\" title=\"双重检查\"></a>双重检查</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.给 instance 分配内存</span></span><br><span class=\"line\">    <span class=\"comment\">// 2.调用 Singleton 的构造函数来初始化成员变量</span></span><br><span class=\"line\">    <span class=\"comment\">// 3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</span></span><br><span class=\"line\">    <span class=\"comment\">// 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，</span></span><br><span class=\"line\">    <span class=\"comment\">// 最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，</span></span><br><span class=\"line\">    <span class=\"comment\">// 这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后报错。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通过在synchronized的外面增加一层判断，就可以在对象一经创建以后，不再进入synchronized同步块。</span></span><br><span class=\"line\">            <span class=\"comment\">// 这种方案不仅减小了锁的粒度，保证了线程安全，性能方面也得到了大幅提升。</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                    singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"How to see past your own perspective and find truth","comments":1,"date":"2019-05-21T03:15:07.000Z","_content":"You can't strive to inhabit that space if you don't already accept that you live in the same reality. To accept that, we've got to believe in truth, we've got to encourage more active ways of knowing. And we've got to have the humility to realize that we're not the measure of all things. \n\nhttps://www.ted.com/talks/michael_patrick_lynch_how_to_see_past_your_own_perspective_and_find_truth","source":"_posts/TED/How to see past your own perspective and find truth.md","raw":"---\nlayout: post\ntitle: \"How to see past your own perspective and find truth\"\ncomments: true\ndate: 2019-05-21 11:15:07\ntags: \n\t- TED\n---\nYou can't strive to inhabit that space if you don't already accept that you live in the same reality. To accept that, we've got to believe in truth, we've got to encourage more active ways of knowing. And we've got to have the humility to realize that we're not the measure of all things. \n\nhttps://www.ted.com/talks/michael_patrick_lynch_how_to_see_past_your_own_perspective_and_find_truth","slug":"TED/How to see past your own perspective and find truth","published":1,"updated":"2020-08-09T05:24:13.291Z","photos":[],"link":"","_id":"ckdmsee8c002glguwer45h0ws","content":"<p>You can’t strive to inhabit that space if you don’t already accept that you live in the same reality. To accept that, we’ve got to believe in truth, we’ve got to encourage more active ways of knowing. And we’ve got to have the humility to realize that we’re not the measure of all things. </p>\n<p><a href=\"https://www.ted.com/talks/michael_patrick_lynch_how_to_see_past_your_own_perspective_and_find_truth\" target=\"_blank\" rel=\"noopener\">https://www.ted.com/talks/michael_patrick_lynch_how_to_see_past_your_own_perspective_and_find_truth</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>You can’t strive to inhabit that space if you don’t already accept that you live in the same reality. To accept that, we’ve got to believe in truth, we’ve got to encourage more active ways of knowing. And we’ve got to have the humility to realize that we’re not the measure of all things. </p>\n<p><a href=\"https://www.ted.com/talks/michael_patrick_lynch_how_to_see_past_your_own_perspective_and_find_truth\" target=\"_blank\" rel=\"noopener\">https://www.ted.com/talks/michael_patrick_lynch_how_to_see_past_your_own_perspective_and_find_truth</a></p>\n"},{"layout":"post","title":"Does money make you mean?","comments":1,"date":"2019-05-20T03:15:07.000Z","_content":"# Does money make you mean?\n\n### what are we facing? \n\nAmerican dream is an idea in which **we all have an equal opportunity to succeed and prosper, as long as we apply ourselves and work hard.** And a piece of that means that sometimes, you need to put your own interests above the interests and well-being of other people around you. But **what we're finding is that the wealthier you are, the more likely you are to pursue a vision of personal success, of achievement and accomplishment, to the detriment of others around you.**\n\n<!--more--> \n\nWe're at unprecedented levels of economic inequality. What that means is that wealth is not only becoming increasingly concentrated in the hands of a select group of individuals, but the American dream is becoming increasingly unattainable for an increasing majority of us. And if it's the case, as we've been finding, that **the wealthier you are, the more entitled you feel to that wealth, and the more likely you are to prioritize your own interests above the interests of other people, and be willing to do things to serve that self-interest.**\n\n### what do we do? \n\nwe've been finding in our own laboratory research that small psychological interventions, small changes to people's values, small nudges in certain directions,can restore levels of egalitarianism and empathy. For instance, **reminding people of the benefits of cooperation or the advantages of community, cause wealthier individuals to be just as egalitarian as poor people.** \n\nhttps://www.ted.com/talks/paul_piff_does_money_make_you_mean","source":"_posts/TED/Does money make you mean.md","raw":"---\nlayout: post\ntitle: \"Does money make you mean?\"\ncomments: true\ndate: 2019-5-20 11:15:07\ntags: \n\t- TED\n---\n# Does money make you mean?\n\n### what are we facing? \n\nAmerican dream is an idea in which **we all have an equal opportunity to succeed and prosper, as long as we apply ourselves and work hard.** And a piece of that means that sometimes, you need to put your own interests above the interests and well-being of other people around you. But **what we're finding is that the wealthier you are, the more likely you are to pursue a vision of personal success, of achievement and accomplishment, to the detriment of others around you.**\n\n<!--more--> \n\nWe're at unprecedented levels of economic inequality. What that means is that wealth is not only becoming increasingly concentrated in the hands of a select group of individuals, but the American dream is becoming increasingly unattainable for an increasing majority of us. And if it's the case, as we've been finding, that **the wealthier you are, the more entitled you feel to that wealth, and the more likely you are to prioritize your own interests above the interests of other people, and be willing to do things to serve that self-interest.**\n\n### what do we do? \n\nwe've been finding in our own laboratory research that small psychological interventions, small changes to people's values, small nudges in certain directions,can restore levels of egalitarianism and empathy. For instance, **reminding people of the benefits of cooperation or the advantages of community, cause wealthier individuals to be just as egalitarian as poor people.** \n\nhttps://www.ted.com/talks/paul_piff_does_money_make_you_mean","slug":"TED/Does money make you mean","published":1,"updated":"2020-08-09T05:24:13.291Z","photos":[],"link":"","_id":"ckdmsee8d002ilguwtarac8jt","content":"<h1 id=\"Does-money-make-you-mean\"><a href=\"#Does-money-make-you-mean\" class=\"headerlink\" title=\"Does money make you mean?\"></a>Does money make you mean?</h1><h3 id=\"what-are-we-facing\"><a href=\"#what-are-we-facing\" class=\"headerlink\" title=\"what are we facing?\"></a>what are we facing?</h3><p>American dream is an idea in which <strong>we all have an equal opportunity to succeed and prosper, as long as we apply ourselves and work hard.</strong> And a piece of that means that sometimes, you need to put your own interests above the interests and well-being of other people around you. But <strong>what we’re finding is that the wealthier you are, the more likely you are to pursue a vision of personal success, of achievement and accomplishment, to the detriment of others around you.</strong></p>\n<a id=\"more\"></a> \n<p>We’re at unprecedented levels of economic inequality. What that means is that wealth is not only becoming increasingly concentrated in the hands of a select group of individuals, but the American dream is becoming increasingly unattainable for an increasing majority of us. And if it’s the case, as we’ve been finding, that <strong>the wealthier you are, the more entitled you feel to that wealth, and the more likely you are to prioritize your own interests above the interests of other people, and be willing to do things to serve that self-interest.</strong></p>\n<h3 id=\"what-do-we-do\"><a href=\"#what-do-we-do\" class=\"headerlink\" title=\"what do we do?\"></a>what do we do?</h3><p>we’ve been finding in our own laboratory research that small psychological interventions, small changes to people’s values, small nudges in certain directions,can restore levels of egalitarianism and empathy. For instance, <strong>reminding people of the benefits of cooperation or the advantages of community, cause wealthier individuals to be just as egalitarian as poor people.</strong> </p>\n<p><a href=\"https://www.ted.com/talks/paul_piff_does_money_make_you_mean\" target=\"_blank\" rel=\"noopener\">https://www.ted.com/talks/paul_piff_does_money_make_you_mean</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Does-money-make-you-mean\"><a href=\"#Does-money-make-you-mean\" class=\"headerlink\" title=\"Does money make you mean?\"></a>Does money make you mean?</h1><h3 id=\"what-are-we-facing\"><a href=\"#what-are-we-facing\" class=\"headerlink\" title=\"what are we facing?\"></a>what are we facing?</h3><p>American dream is an idea in which <strong>we all have an equal opportunity to succeed and prosper, as long as we apply ourselves and work hard.</strong> And a piece of that means that sometimes, you need to put your own interests above the interests and well-being of other people around you. But <strong>what we’re finding is that the wealthier you are, the more likely you are to pursue a vision of personal success, of achievement and accomplishment, to the detriment of others around you.</strong></p>","more":"<p>We’re at unprecedented levels of economic inequality. What that means is that wealth is not only becoming increasingly concentrated in the hands of a select group of individuals, but the American dream is becoming increasingly unattainable for an increasing majority of us. And if it’s the case, as we’ve been finding, that <strong>the wealthier you are, the more entitled you feel to that wealth, and the more likely you are to prioritize your own interests above the interests of other people, and be willing to do things to serve that self-interest.</strong></p>\n<h3 id=\"what-do-we-do\"><a href=\"#what-do-we-do\" class=\"headerlink\" title=\"what do we do?\"></a>what do we do?</h3><p>we’ve been finding in our own laboratory research that small psychological interventions, small changes to people’s values, small nudges in certain directions,can restore levels of egalitarianism and empathy. For instance, <strong>reminding people of the benefits of cooperation or the advantages of community, cause wealthier individuals to be just as egalitarian as poor people.</strong> </p>\n<p><a href=\"https://www.ted.com/talks/paul_piff_does_money_make_you_mean\" target=\"_blank\" rel=\"noopener\">https://www.ted.com/talks/paul_piff_does_money_make_you_mean</a></p>"},{"layout":"post","title":"Maven的理解","date":"2019-07-29T14:44:36.000Z","comments":1,"_content":"**Maven的用处**\n\n1.maven会自动帮我们引入适用的版本Jar包。\n\n2.maven完成自动化构建（清理→编译→编译→部署）。\n\n\n\n**Maven项目结构**\n\n1. 有一个pom.xml 用于维护当前项目都用了哪些jar包。\n2. 源代码都放在 src/main/java 下面。\n3. 测试代码都放在src/test/java 下面。\n4. 配置文件都放在src/main/resources 下面。\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1g5h44289m8j20m805waa9.jpg)","source":"_posts/JAVA/Maven理解.md","raw":"---\nlayout: post\ntitle: \"Maven的理解\"\ndate: 2019-7-29 22:44:36\ncomments: true\ntags: \n\t- JAVA\n---\n**Maven的用处**\n\n1.maven会自动帮我们引入适用的版本Jar包。\n\n2.maven完成自动化构建（清理→编译→编译→部署）。\n\n\n\n**Maven项目结构**\n\n1. 有一个pom.xml 用于维护当前项目都用了哪些jar包。\n2. 源代码都放在 src/main/java 下面。\n3. 测试代码都放在src/test/java 下面。\n4. 配置文件都放在src/main/resources 下面。\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1g5h44289m8j20m805waa9.jpg)","slug":"JAVA/Maven理解","published":1,"updated":"2020-08-09T05:24:13.283Z","photos":[],"link":"","_id":"ckdmsee8f002llguwkwzpvcq7","content":"<p><strong>Maven的用处</strong></p>\n<p>1.maven会自动帮我们引入适用的版本Jar包。</p>\n<p>2.maven完成自动化构建（清理→编译→编译→部署）。</p>\n<p><strong>Maven项目结构</strong></p>\n<ol>\n<li>有一个pom.xml 用于维护当前项目都用了哪些jar包。</li>\n<li>源代码都放在 src/main/java 下面。</li>\n<li>测试代码都放在src/test/java 下面。</li>\n<li>配置文件都放在src/main/resources 下面。</li>\n</ol>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1g5h44289m8j20m805waa9.jpg\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Maven的用处</strong></p>\n<p>1.maven会自动帮我们引入适用的版本Jar包。</p>\n<p>2.maven完成自动化构建（清理→编译→编译→部署）。</p>\n<p><strong>Maven项目结构</strong></p>\n<ol>\n<li>有一个pom.xml 用于维护当前项目都用了哪些jar包。</li>\n<li>源代码都放在 src/main/java 下面。</li>\n<li>测试代码都放在src/test/java 下面。</li>\n<li>配置文件都放在src/main/resources 下面。</li>\n</ol>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1g5h44289m8j20m805waa9.jpg\" alt></p>\n"},{"title":"ajax学习","author":"Zhang Peng","date":"2018-07-03T03:51:00.000Z","_content":"Ajax是一种异步请求数据的web开发技术，对于改善用户的体验和页面性能很有帮助。简单地说，在不需要重新刷新页面的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。常见运用场景有表单验证是否登入成功。\n\n<!--more--> \n\n需求：点击登陆按钮时，提交账号和密码给后端，异步刷新显示返回的数据。\n\n**Demo代码：**\n\n```javascript\n<script>\n    $(function() {\n        $(\"#submitBtn\").click(function() {\n            if(0 == $(\"#username\").val().length || 0==$(\"#password\").val().length){\n                $(\"#errorMessage\").text(\"输入账号密码为空\");\n                $(\"#loginErrorMessageDiv\").css(\"visibility\",\"visible\");\n                return false;\n            }else{\n            var username = $(\"#username\").val(),\n                password = $(\"#password\").val();\n\n                $.ajax({\n                    type: \"POST\",\n                    data: {username: username, password: password}, //传输的数据\n                    dataType:\"json\", //传输的数据类型\n                    url: \"/loginsuccess\", //提交目的地址\n                    success: function (data) { //返回的数据为data对象，该对象有msg和code两个属性\n                        console.log(data);\n                        if (data.code == 1) {\n                            $(\"#errorMessage\").text(data.msg);\n                            $(\"#loginErrorMessageDiv\").css(\"visibility\",\"visible\");\n                            return false;\n                        } else {\n                            window.location.href=data.msg;\n                            return true;\n                        }\n                    },\n                    error: function (data) {\n                        alert(\"认证失败\");\n                    }\n                });\n            }\n        });\n\n        $(\"input\").keyup(function(){\n            $(\"#loginErrorMessageDiv\").css(\"visibility\",\"hidden\");\n        });\n    });\n</script>\n```\n\n**效果图：**\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1c35oiij20pu0a3gr3.jpg)","source":"_posts/前端/ajax学习.md","raw":"---\ntitle: ajax学习\nauthor: Zhang Peng\ntags:\n  - 前端\ncategories: []\ndate: 2018-07-03 11:51:00\n---\nAjax是一种异步请求数据的web开发技术，对于改善用户的体验和页面性能很有帮助。简单地说，在不需要重新刷新页面的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。常见运用场景有表单验证是否登入成功。\n\n<!--more--> \n\n需求：点击登陆按钮时，提交账号和密码给后端，异步刷新显示返回的数据。\n\n**Demo代码：**\n\n```javascript\n<script>\n    $(function() {\n        $(\"#submitBtn\").click(function() {\n            if(0 == $(\"#username\").val().length || 0==$(\"#password\").val().length){\n                $(\"#errorMessage\").text(\"输入账号密码为空\");\n                $(\"#loginErrorMessageDiv\").css(\"visibility\",\"visible\");\n                return false;\n            }else{\n            var username = $(\"#username\").val(),\n                password = $(\"#password\").val();\n\n                $.ajax({\n                    type: \"POST\",\n                    data: {username: username, password: password}, //传输的数据\n                    dataType:\"json\", //传输的数据类型\n                    url: \"/loginsuccess\", //提交目的地址\n                    success: function (data) { //返回的数据为data对象，该对象有msg和code两个属性\n                        console.log(data);\n                        if (data.code == 1) {\n                            $(\"#errorMessage\").text(data.msg);\n                            $(\"#loginErrorMessageDiv\").css(\"visibility\",\"visible\");\n                            return false;\n                        } else {\n                            window.location.href=data.msg;\n                            return true;\n                        }\n                    },\n                    error: function (data) {\n                        alert(\"认证失败\");\n                    }\n                });\n            }\n        });\n\n        $(\"input\").keyup(function(){\n            $(\"#loginErrorMessageDiv\").css(\"visibility\",\"hidden\");\n        });\n    });\n</script>\n```\n\n**效果图：**\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1c35oiij20pu0a3gr3.jpg)","slug":"前端/ajax学习","published":1,"updated":"2020-08-09T05:24:13.294Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdmsee8h002nlguw46bnvrtu","content":"<p>Ajax是一种异步请求数据的web开发技术，对于改善用户的体验和页面性能很有帮助。简单地说，在不需要重新刷新页面的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。常见运用场景有表单验证是否登入成功。</p>\n<a id=\"more\"></a> \n<p>需求：点击登陆按钮时，提交账号和密码给后端，异步刷新显示返回的数据。</p>\n<p><strong>Demo代码：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    $(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        $(<span class=\"string\">\"#submitBtn\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"number\">0</span> == $(<span class=\"string\">\"#username\"</span>).val().length || <span class=\"number\">0</span>==$(<span class=\"string\">\"#password\"</span>).val().length)&#123;</span><br><span class=\"line\">                $(<span class=\"string\">\"#errorMessage\"</span>).text(<span class=\"string\">\"输入账号密码为空\"</span>);</span><br><span class=\"line\">                $(<span class=\"string\">\"#loginErrorMessageDiv\"</span>).css(<span class=\"string\">\"visibility\"</span>,<span class=\"string\">\"visible\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> username = $(<span class=\"string\">\"#username\"</span>).val(),</span><br><span class=\"line\">                password = $(<span class=\"string\">\"#password\"</span>).val();</span><br><span class=\"line\"></span><br><span class=\"line\">                $.ajax(&#123;</span><br><span class=\"line\">                    type: <span class=\"string\">\"POST\"</span>,</span><br><span class=\"line\">                    data: &#123;<span class=\"attr\">username</span>: username, <span class=\"attr\">password</span>: password&#125;, <span class=\"comment\">//传输的数据</span></span><br><span class=\"line\">                    dataType:<span class=\"string\">\"json\"</span>, <span class=\"comment\">//传输的数据类型</span></span><br><span class=\"line\">                    url: <span class=\"string\">\"/loginsuccess\"</span>, <span class=\"comment\">//提交目的地址</span></span><br><span class=\"line\">                    success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123; <span class=\"comment\">//返回的数据为data对象，该对象有msg和code两个属性</span></span><br><span class=\"line\">                        <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (data.code == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                            $(<span class=\"string\">\"#errorMessage\"</span>).text(data.msg);</span><br><span class=\"line\">                            $(<span class=\"string\">\"#loginErrorMessageDiv\"</span>).css(<span class=\"string\">\"visibility\"</span>,<span class=\"string\">\"visible\"</span>);</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"built_in\">window</span>.location.href=data.msg;</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    error: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">                        alert(<span class=\"string\">\"认证失败\"</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        $(<span class=\"string\">\"input\"</span>).keyup(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            $(<span class=\"string\">\"#loginErrorMessageDiv\"</span>).css(<span class=\"string\">\"visibility\"</span>,<span class=\"string\">\"hidden\"</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>效果图：</strong></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1c35oiij20pu0a3gr3.jpg\" alt></p>\n","site":{"data":{}},"excerpt":"<p>Ajax是一种异步请求数据的web开发技术，对于改善用户的体验和页面性能很有帮助。简单地说，在不需要重新刷新页面的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。常见运用场景有表单验证是否登入成功。</p>","more":"<p>需求：点击登陆按钮时，提交账号和密码给后端，异步刷新显示返回的数据。</p>\n<p><strong>Demo代码：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    $(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        $(<span class=\"string\">\"#submitBtn\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"number\">0</span> == $(<span class=\"string\">\"#username\"</span>).val().length || <span class=\"number\">0</span>==$(<span class=\"string\">\"#password\"</span>).val().length)&#123;</span><br><span class=\"line\">                $(<span class=\"string\">\"#errorMessage\"</span>).text(<span class=\"string\">\"输入账号密码为空\"</span>);</span><br><span class=\"line\">                $(<span class=\"string\">\"#loginErrorMessageDiv\"</span>).css(<span class=\"string\">\"visibility\"</span>,<span class=\"string\">\"visible\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> username = $(<span class=\"string\">\"#username\"</span>).val(),</span><br><span class=\"line\">                password = $(<span class=\"string\">\"#password\"</span>).val();</span><br><span class=\"line\"></span><br><span class=\"line\">                $.ajax(&#123;</span><br><span class=\"line\">                    type: <span class=\"string\">\"POST\"</span>,</span><br><span class=\"line\">                    data: &#123;<span class=\"attr\">username</span>: username, <span class=\"attr\">password</span>: password&#125;, <span class=\"comment\">//传输的数据</span></span><br><span class=\"line\">                    dataType:<span class=\"string\">\"json\"</span>, <span class=\"comment\">//传输的数据类型</span></span><br><span class=\"line\">                    url: <span class=\"string\">\"/loginsuccess\"</span>, <span class=\"comment\">//提交目的地址</span></span><br><span class=\"line\">                    success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123; <span class=\"comment\">//返回的数据为data对象，该对象有msg和code两个属性</span></span><br><span class=\"line\">                        <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (data.code == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                            $(<span class=\"string\">\"#errorMessage\"</span>).text(data.msg);</span><br><span class=\"line\">                            $(<span class=\"string\">\"#loginErrorMessageDiv\"</span>).css(<span class=\"string\">\"visibility\"</span>,<span class=\"string\">\"visible\"</span>);</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"built_in\">window</span>.location.href=data.msg;</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    error: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">                        alert(<span class=\"string\">\"认证失败\"</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        $(<span class=\"string\">\"input\"</span>).keyup(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            $(<span class=\"string\">\"#loginErrorMessageDiv\"</span>).css(<span class=\"string\">\"visibility\"</span>,<span class=\"string\">\"hidden\"</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>效果图：</strong></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1c35oiij20pu0a3gr3.jpg\" alt></p>"},{"layout":"post","title":"CSS定位 文档流 浮动","date":"2017-11-19T11:58:00.000Z","comments":1,"reward":true,"_content":"# ![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1ita8utj20n7028aa0.jpg)\n\n昨天写CSS的时候，发现div的高度不能自适应。然后在[CSS 浮动](http://www.cnblogs.com/jiqing9006/archive/2012/07/30/2615231.html)找到解决方案了。\n\n普通流就是正常的文档流，在HTML里面的写法就是从上到下，从左到右的排版布局。\n\n<!--more--> \n\n例：\n\n<div id=”01”></div><div id=”02”></div><div></div>\n\n很显然这是最普通的文档流，从左到右，一个挨一个按照顺序01先，02其次，03最后排列。\n\n![img](http://pic002.cnblogs.com/images/2012/422101/2012073014324651.jpg)\n\n一旦给其中的某个DIV进行FLOAT属性或者absolute定位（不包括static/relative，这两个依然保持正常的文档流），则它完全脱离文档流，不占空间。\n\n例：\n\n![img](http://pic002.cnblogs.com/images/2012/422101/2012073014343616.jpg)\n\n为了能更好辨认，我分别给01绿色，02灰色，03黄色。然后再给01左浮动。结果，01脱离了文档流，完全不占空间，所以02顺势顶替了01原来的位置，结果02被01盖住了。\n\n同理，absolute定位跟FLOAT一样，脱离了文档流，不再占原来文档流的空间了。再举一个大家在日常经常遇到的问题来印证—高度自适应\n\n反复想一想，高度自适应的原理其实就是这个：\n\n```\n<div id=”a”>\n\n<div id=”b”>这是b</div>\n\n<div id=”c”>这是c</div>\n\n</div>\n```\n\n这个结构是a包住b和c，颜色不变，a的高度为自动，b的高度为100，C的高度为500。b和c都为左浮动。\n\n![img](http://pic002.cnblogs.com/images/2012/422101/2012073014362919.jpg)\n\n很明显a没有被撑开了。原因是它们浮动了就不再占空间了。既然没有空间可占，那就等于容器里没有东西，所以不撑开。\n\n知道这个问题后，我就没有将b设置为浮动，高度就自适应到b的高度了。\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1j866vyj20n7028q2w.jpg)","source":"_posts/前端/CSS定位 文档流 浮动流.md","raw":"---\nlayout: post\ntitle: \"CSS定位 文档流 浮动\"\ndate: 2017-11-19 19:58\ncomments: true\nreward: true\ntags: \n\t- 前端\n---\n# ![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1ita8utj20n7028aa0.jpg)\n\n昨天写CSS的时候，发现div的高度不能自适应。然后在[CSS 浮动](http://www.cnblogs.com/jiqing9006/archive/2012/07/30/2615231.html)找到解决方案了。\n\n普通流就是正常的文档流，在HTML里面的写法就是从上到下，从左到右的排版布局。\n\n<!--more--> \n\n例：\n\n<div id=”01”></div><div id=”02”></div><div></div>\n\n很显然这是最普通的文档流，从左到右，一个挨一个按照顺序01先，02其次，03最后排列。\n\n![img](http://pic002.cnblogs.com/images/2012/422101/2012073014324651.jpg)\n\n一旦给其中的某个DIV进行FLOAT属性或者absolute定位（不包括static/relative，这两个依然保持正常的文档流），则它完全脱离文档流，不占空间。\n\n例：\n\n![img](http://pic002.cnblogs.com/images/2012/422101/2012073014343616.jpg)\n\n为了能更好辨认，我分别给01绿色，02灰色，03黄色。然后再给01左浮动。结果，01脱离了文档流，完全不占空间，所以02顺势顶替了01原来的位置，结果02被01盖住了。\n\n同理，absolute定位跟FLOAT一样，脱离了文档流，不再占原来文档流的空间了。再举一个大家在日常经常遇到的问题来印证—高度自适应\n\n反复想一想，高度自适应的原理其实就是这个：\n\n```\n<div id=”a”>\n\n<div id=”b”>这是b</div>\n\n<div id=”c”>这是c</div>\n\n</div>\n```\n\n这个结构是a包住b和c，颜色不变，a的高度为自动，b的高度为100，C的高度为500。b和c都为左浮动。\n\n![img](http://pic002.cnblogs.com/images/2012/422101/2012073014362919.jpg)\n\n很明显a没有被撑开了。原因是它们浮动了就不再占空间了。既然没有空间可占，那就等于容器里没有东西，所以不撑开。\n\n知道这个问题后，我就没有将b设置为浮动，高度就自适应到b的高度了。\n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1j866vyj20n7028q2w.jpg)","slug":"前端/CSS定位 文档流 浮动流","published":1,"updated":"2020-08-09T05:24:13.293Z","photos":[],"link":"","_id":"ckdmsee8j002plguw41lvmxss","content":"<h1 id><a href=\"#\" class=\"headerlink\" title></a><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1ita8utj20n7028aa0.jpg\" alt></h1><p>昨天写CSS的时候，发现div的高度不能自适应。然后在<a href=\"http://www.cnblogs.com/jiqing9006/archive/2012/07/30/2615231.html\" target=\"_blank\" rel=\"noopener\">CSS 浮动</a>找到解决方案了。</p>\n<p>普通流就是正常的文档流，在HTML里面的写法就是从上到下，从左到右的排版布局。</p>\n<a id=\"more\"></a> \n<p>例：</p>\n<div id=\"”01”\"></div><div id=\"”02”\"></div><div></div>\n\n<p>很显然这是最普通的文档流，从左到右，一个挨一个按照顺序01先，02其次，03最后排列。</p>\n<p><img src=\"http://pic002.cnblogs.com/images/2012/422101/2012073014324651.jpg\" alt=\"img\"></p>\n<p>一旦给其中的某个DIV进行FLOAT属性或者absolute定位（不包括static/relative，这两个依然保持正常的文档流），则它完全脱离文档流，不占空间。</p>\n<p>例：</p>\n<p><img src=\"http://pic002.cnblogs.com/images/2012/422101/2012073014343616.jpg\" alt=\"img\"></p>\n<p>为了能更好辨认，我分别给01绿色，02灰色，03黄色。然后再给01左浮动。结果，01脱离了文档流，完全不占空间，所以02顺势顶替了01原来的位置，结果02被01盖住了。</p>\n<p>同理，absolute定位跟FLOAT一样，脱离了文档流，不再占原来文档流的空间了。再举一个大家在日常经常遇到的问题来印证—高度自适应</p>\n<p>反复想一想，高度自适应的原理其实就是这个：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=”a”&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id=”b”&gt;这是b&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id=”c”&gt;这是c&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>这个结构是a包住b和c，颜色不变，a的高度为自动，b的高度为100，C的高度为500。b和c都为左浮动。</p>\n<p><img src=\"http://pic002.cnblogs.com/images/2012/422101/2012073014362919.jpg\" alt=\"img\"></p>\n<p>很明显a没有被撑开了。原因是它们浮动了就不再占空间了。既然没有空间可占，那就等于容器里没有东西，所以不撑开。</p>\n<p>知道这个问题后，我就没有将b设置为浮动，高度就自适应到b的高度了。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1j866vyj20n7028q2w.jpg\" alt></p>\n","site":{"data":{}},"excerpt":"<h1 id><a href=\"#\" class=\"headerlink\" title></a><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1ita8utj20n7028aa0.jpg\" alt></h1><p>昨天写CSS的时候，发现div的高度不能自适应。然后在<a href=\"http://www.cnblogs.com/jiqing9006/archive/2012/07/30/2615231.html\" target=\"_blank\" rel=\"noopener\">CSS 浮动</a>找到解决方案了。</p>\n<p>普通流就是正常的文档流，在HTML里面的写法就是从上到下，从左到右的排版布局。</p>","more":"<p>例：</p>\n<div id=\"”01”\"></div><div id=\"”02”\"></div><div></div>\n\n<p>很显然这是最普通的文档流，从左到右，一个挨一个按照顺序01先，02其次，03最后排列。</p>\n<p><img src=\"http://pic002.cnblogs.com/images/2012/422101/2012073014324651.jpg\" alt=\"img\"></p>\n<p>一旦给其中的某个DIV进行FLOAT属性或者absolute定位（不包括static/relative，这两个依然保持正常的文档流），则它完全脱离文档流，不占空间。</p>\n<p>例：</p>\n<p><img src=\"http://pic002.cnblogs.com/images/2012/422101/2012073014343616.jpg\" alt=\"img\"></p>\n<p>为了能更好辨认，我分别给01绿色，02灰色，03黄色。然后再给01左浮动。结果，01脱离了文档流，完全不占空间，所以02顺势顶替了01原来的位置，结果02被01盖住了。</p>\n<p>同理，absolute定位跟FLOAT一样，脱离了文档流，不再占原来文档流的空间了。再举一个大家在日常经常遇到的问题来印证—高度自适应</p>\n<p>反复想一想，高度自适应的原理其实就是这个：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=”a”&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id=”b”&gt;这是b&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id=”c”&gt;这是c&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>这个结构是a包住b和c，颜色不变，a的高度为自动，b的高度为100，C的高度为500。b和c都为左浮动。</p>\n<p><img src=\"http://pic002.cnblogs.com/images/2012/422101/2012073014362919.jpg\" alt=\"img\"></p>\n<p>很明显a没有被撑开了。原因是它们浮动了就不再占空间了。既然没有空间可占，那就等于容器里没有东西，所以不撑开。</p>\n<p>知道这个问题后，我就没有将b设置为浮动，高度就自适应到b的高度了。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1j866vyj20n7028q2w.jpg\" alt></p>"},{"layout":"post","title":"校园照片","date":"2016-12-29T11:58:00.000Z","comments":1,"reward":true,"_content":"\n拍的一些校园照片。\n\n<!-- more -->\n\n![](http://i.imgur.com/E2IO9ng.jpg)\n\n![](http://i.imgur.com/1bEwCSO.jpg)\n\n忠于自己...","source":"_posts/生活/校园照片.md","raw":"---\nlayout: post\ntitle: \"校园照片\"\ndate: 2016-12-29 19:58\ncomments: true\nreward: true\ntags: \n\t- 生活\n---\n\n拍的一些校园照片。\n\n<!-- more -->\n\n![](http://i.imgur.com/E2IO9ng.jpg)\n\n![](http://i.imgur.com/1bEwCSO.jpg)\n\n忠于自己...","slug":"生活/校园照片","published":1,"updated":"2020-08-09T05:24:13.298Z","photos":[],"link":"","_id":"ckdmsee8m002slguwdphz86c5","content":"<p>拍的一些校园照片。</p>\n<a id=\"more\"></a>\n<p><img src=\"http://i.imgur.com/E2IO9ng.jpg\" alt></p>\n<p><img src=\"http://i.imgur.com/1bEwCSO.jpg\" alt></p>\n<p>忠于自己…</p>\n","site":{"data":{}},"excerpt":"<p>拍的一些校园照片。</p>","more":"<p><img src=\"http://i.imgur.com/E2IO9ng.jpg\" alt></p>\n<p><img src=\"http://i.imgur.com/1bEwCSO.jpg\" alt></p>\n<p>忠于自己…</p>"},{"title":"万历王朝的兴衰史","author":"Zhang Peng","date":"2018-12-23T09:56:00.000Z","_content":"\n最近读了有关历史有关的书籍，发现万历王朝的兴衰，与当朝的皇帝和辅臣有关系。我想基于此，可以去凭借后人写的史书去分析一下这个王朝的兴衰。然后以此为鉴，避免掉入前人的坑。\n\n万历皇帝是从小在张居正的陪伴下成长起来的。由于年龄太小，每次临朝时还需要在衣袖里抽出一张别人事先为他书写的纸片，边看边答复各个官员的呈奏请示。在那时候他看来，张先生似乎永远就是智慧的象征，他的意见就代表了自己的旨意。\n\n万历十年，在张居正的努力下,国库日见充实，外部倭寇也已绝迹，成就了万历王朝欣欣向荣的十年。但也正是因为张居正位高权重，凡有弹劾张居正的官员都遭到了惩处。他的儿子在科举中分别中了状元，榜眼，引起了普遍的质疑，但他毫不在意。\n\n1582年，张居正长逝，他死时，北京的粮仓装满了够吃9年的粮食，府库里也堆满了银子。但也就在张居正仅去世半年后，反张派开始揭发事实，制造舆论，使他的形象逐渐变得虚伪和毒辣。这一切都让年轻的皇帝感到他对张居正的信任是一种错误。2年后，张居正被抄家了。\n\n万历二十年，宁夏副总兵哱拜叛变，为了对付叛乱，皇帝从北方辽东，山西等地调集军队进行镇压。这次军事行动花费了一百八十万两白银。同一年，明政府发兵抗击日本丰臣秀吉政权入侵朝鲜，花费七百八十万两。8年后，苗疆土司杨应龙叛乱，政府再次出兵镇压。史书记载：这三场战役为“万历三大征”，巩固了中华疆土，维护了明朝在东亚的主导地位。但国家财政的赤字已经达到了一百万两，而且年年赤字。这时，皇帝开始利用张居正留下的税务系统进行加税，勉强渡过难关。但随后在后金王朝的连绵进攻下，多次加税筹集军饷调遣军队，最终导致了民间经济的奔溃，出现大饥荒，带来了造反潮。\n\n古语有云：知史以明鉴，查古以至今。从万历角度来看，作为皇帝，一定要有自己的主见，对事情要自己的清晰看法，不能过于听信他人的看法。做事情去权衡各方的利益，去协调各方。\n\n从张居正角度来看，张居正一方面通过改革税法让政府收入大幅增加，成就明朝最富裕的十年，另一方面其在位权力过于庞大，排除异己，死后遭到抄家。我从中可以知道两点，第一点，权力要受到监管。第二点，很多事和人都是由黑与白交织成的灰色。从不同的方面看出来的颜色也不同。\n\n从国家角度来说，其实打仗就是伤敌一千，自损八百的事。就算打赢了胜仗，宣告了国家的主权地位，但国家的经费也会大大消耗。当国家财政无法支撑军饷时，政府就会想办法在民间获取经济来源，导致老百姓的日子跟着受苦。\n\n虽说明朝距离我们现在已有五六百年时间了，但历史事件背后的逻辑依然在当今出现。我想读史，给我最大的感受就是运用发现了现在的一些事情怎么和历史上的事情这么相似，这时去套用历史的逻辑去看现在的事情，会有新的发现。","source":"_posts/读书/万历王朝的兴衰史.md","raw":"---\ntitle: 万历王朝的兴衰史\nauthor: Zhang Peng\ntags:\n  - 读书\ncategories: []\ndate: 2018-12-23 17:56:00\n---\n\n最近读了有关历史有关的书籍，发现万历王朝的兴衰，与当朝的皇帝和辅臣有关系。我想基于此，可以去凭借后人写的史书去分析一下这个王朝的兴衰。然后以此为鉴，避免掉入前人的坑。\n\n万历皇帝是从小在张居正的陪伴下成长起来的。由于年龄太小，每次临朝时还需要在衣袖里抽出一张别人事先为他书写的纸片，边看边答复各个官员的呈奏请示。在那时候他看来，张先生似乎永远就是智慧的象征，他的意见就代表了自己的旨意。\n\n万历十年，在张居正的努力下,国库日见充实，外部倭寇也已绝迹，成就了万历王朝欣欣向荣的十年。但也正是因为张居正位高权重，凡有弹劾张居正的官员都遭到了惩处。他的儿子在科举中分别中了状元，榜眼，引起了普遍的质疑，但他毫不在意。\n\n1582年，张居正长逝，他死时，北京的粮仓装满了够吃9年的粮食，府库里也堆满了银子。但也就在张居正仅去世半年后，反张派开始揭发事实，制造舆论，使他的形象逐渐变得虚伪和毒辣。这一切都让年轻的皇帝感到他对张居正的信任是一种错误。2年后，张居正被抄家了。\n\n万历二十年，宁夏副总兵哱拜叛变，为了对付叛乱，皇帝从北方辽东，山西等地调集军队进行镇压。这次军事行动花费了一百八十万两白银。同一年，明政府发兵抗击日本丰臣秀吉政权入侵朝鲜，花费七百八十万两。8年后，苗疆土司杨应龙叛乱，政府再次出兵镇压。史书记载：这三场战役为“万历三大征”，巩固了中华疆土，维护了明朝在东亚的主导地位。但国家财政的赤字已经达到了一百万两，而且年年赤字。这时，皇帝开始利用张居正留下的税务系统进行加税，勉强渡过难关。但随后在后金王朝的连绵进攻下，多次加税筹集军饷调遣军队，最终导致了民间经济的奔溃，出现大饥荒，带来了造反潮。\n\n古语有云：知史以明鉴，查古以至今。从万历角度来看，作为皇帝，一定要有自己的主见，对事情要自己的清晰看法，不能过于听信他人的看法。做事情去权衡各方的利益，去协调各方。\n\n从张居正角度来看，张居正一方面通过改革税法让政府收入大幅增加，成就明朝最富裕的十年，另一方面其在位权力过于庞大，排除异己，死后遭到抄家。我从中可以知道两点，第一点，权力要受到监管。第二点，很多事和人都是由黑与白交织成的灰色。从不同的方面看出来的颜色也不同。\n\n从国家角度来说，其实打仗就是伤敌一千，自损八百的事。就算打赢了胜仗，宣告了国家的主权地位，但国家的经费也会大大消耗。当国家财政无法支撑军饷时，政府就会想办法在民间获取经济来源，导致老百姓的日子跟着受苦。\n\n虽说明朝距离我们现在已有五六百年时间了，但历史事件背后的逻辑依然在当今出现。我想读史，给我最大的感受就是运用发现了现在的一些事情怎么和历史上的事情这么相似，这时去套用历史的逻辑去看现在的事情，会有新的发现。","slug":"读书/万历王朝的兴衰史","published":1,"updated":"2020-08-09T05:24:13.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdmsee8n002ulguwuhh841a8","content":"<p>最近读了有关历史有关的书籍，发现万历王朝的兴衰，与当朝的皇帝和辅臣有关系。我想基于此，可以去凭借后人写的史书去分析一下这个王朝的兴衰。然后以此为鉴，避免掉入前人的坑。</p>\n<p>万历皇帝是从小在张居正的陪伴下成长起来的。由于年龄太小，每次临朝时还需要在衣袖里抽出一张别人事先为他书写的纸片，边看边答复各个官员的呈奏请示。在那时候他看来，张先生似乎永远就是智慧的象征，他的意见就代表了自己的旨意。</p>\n<p>万历十年，在张居正的努力下,国库日见充实，外部倭寇也已绝迹，成就了万历王朝欣欣向荣的十年。但也正是因为张居正位高权重，凡有弹劾张居正的官员都遭到了惩处。他的儿子在科举中分别中了状元，榜眼，引起了普遍的质疑，但他毫不在意。</p>\n<p>1582年，张居正长逝，他死时，北京的粮仓装满了够吃9年的粮食，府库里也堆满了银子。但也就在张居正仅去世半年后，反张派开始揭发事实，制造舆论，使他的形象逐渐变得虚伪和毒辣。这一切都让年轻的皇帝感到他对张居正的信任是一种错误。2年后，张居正被抄家了。</p>\n<p>万历二十年，宁夏副总兵哱拜叛变，为了对付叛乱，皇帝从北方辽东，山西等地调集军队进行镇压。这次军事行动花费了一百八十万两白银。同一年，明政府发兵抗击日本丰臣秀吉政权入侵朝鲜，花费七百八十万两。8年后，苗疆土司杨应龙叛乱，政府再次出兵镇压。史书记载：这三场战役为“万历三大征”，巩固了中华疆土，维护了明朝在东亚的主导地位。但国家财政的赤字已经达到了一百万两，而且年年赤字。这时，皇帝开始利用张居正留下的税务系统进行加税，勉强渡过难关。但随后在后金王朝的连绵进攻下，多次加税筹集军饷调遣军队，最终导致了民间经济的奔溃，出现大饥荒，带来了造反潮。</p>\n<p>古语有云：知史以明鉴，查古以至今。从万历角度来看，作为皇帝，一定要有自己的主见，对事情要自己的清晰看法，不能过于听信他人的看法。做事情去权衡各方的利益，去协调各方。</p>\n<p>从张居正角度来看，张居正一方面通过改革税法让政府收入大幅增加，成就明朝最富裕的十年，另一方面其在位权力过于庞大，排除异己，死后遭到抄家。我从中可以知道两点，第一点，权力要受到监管。第二点，很多事和人都是由黑与白交织成的灰色。从不同的方面看出来的颜色也不同。</p>\n<p>从国家角度来说，其实打仗就是伤敌一千，自损八百的事。就算打赢了胜仗，宣告了国家的主权地位，但国家的经费也会大大消耗。当国家财政无法支撑军饷时，政府就会想办法在民间获取经济来源，导致老百姓的日子跟着受苦。</p>\n<p>虽说明朝距离我们现在已有五六百年时间了，但历史事件背后的逻辑依然在当今出现。我想读史，给我最大的感受就是运用发现了现在的一些事情怎么和历史上的事情这么相似，这时去套用历史的逻辑去看现在的事情，会有新的发现。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近读了有关历史有关的书籍，发现万历王朝的兴衰，与当朝的皇帝和辅臣有关系。我想基于此，可以去凭借后人写的史书去分析一下这个王朝的兴衰。然后以此为鉴，避免掉入前人的坑。</p>\n<p>万历皇帝是从小在张居正的陪伴下成长起来的。由于年龄太小，每次临朝时还需要在衣袖里抽出一张别人事先为他书写的纸片，边看边答复各个官员的呈奏请示。在那时候他看来，张先生似乎永远就是智慧的象征，他的意见就代表了自己的旨意。</p>\n<p>万历十年，在张居正的努力下,国库日见充实，外部倭寇也已绝迹，成就了万历王朝欣欣向荣的十年。但也正是因为张居正位高权重，凡有弹劾张居正的官员都遭到了惩处。他的儿子在科举中分别中了状元，榜眼，引起了普遍的质疑，但他毫不在意。</p>\n<p>1582年，张居正长逝，他死时，北京的粮仓装满了够吃9年的粮食，府库里也堆满了银子。但也就在张居正仅去世半年后，反张派开始揭发事实，制造舆论，使他的形象逐渐变得虚伪和毒辣。这一切都让年轻的皇帝感到他对张居正的信任是一种错误。2年后，张居正被抄家了。</p>\n<p>万历二十年，宁夏副总兵哱拜叛变，为了对付叛乱，皇帝从北方辽东，山西等地调集军队进行镇压。这次军事行动花费了一百八十万两白银。同一年，明政府发兵抗击日本丰臣秀吉政权入侵朝鲜，花费七百八十万两。8年后，苗疆土司杨应龙叛乱，政府再次出兵镇压。史书记载：这三场战役为“万历三大征”，巩固了中华疆土，维护了明朝在东亚的主导地位。但国家财政的赤字已经达到了一百万两，而且年年赤字。这时，皇帝开始利用张居正留下的税务系统进行加税，勉强渡过难关。但随后在后金王朝的连绵进攻下，多次加税筹集军饷调遣军队，最终导致了民间经济的奔溃，出现大饥荒，带来了造反潮。</p>\n<p>古语有云：知史以明鉴，查古以至今。从万历角度来看，作为皇帝，一定要有自己的主见，对事情要自己的清晰看法，不能过于听信他人的看法。做事情去权衡各方的利益，去协调各方。</p>\n<p>从张居正角度来看，张居正一方面通过改革税法让政府收入大幅增加，成就明朝最富裕的十年，另一方面其在位权力过于庞大，排除异己，死后遭到抄家。我从中可以知道两点，第一点，权力要受到监管。第二点，很多事和人都是由黑与白交织成的灰色。从不同的方面看出来的颜色也不同。</p>\n<p>从国家角度来说，其实打仗就是伤敌一千，自损八百的事。就算打赢了胜仗，宣告了国家的主权地位，但国家的经费也会大大消耗。当国家财政无法支撑军饷时，政府就会想办法在民间获取经济来源，导致老百姓的日子跟着受苦。</p>\n<p>虽说明朝距离我们现在已有五六百年时间了，但历史事件背后的逻辑依然在当今出现。我想读史，给我最大的感受就是运用发现了现在的一些事情怎么和历史上的事情这么相似，这时去套用历史的逻辑去看现在的事情，会有新的发现。</p>\n"},{"layout":"post","title":"区块链初认识","date":"2017-11-20T06:58:00.000Z","comments":1,"reward":true,"_content":"\n读自：[区块链技术指南](https://www.gitbook.com/book/yeasy/blockchain_guide/details)\n\n我现在的理解来说区块链就是去中心化的分布式记账系统，只可能添加记录，发生过的记录都不可篡改。\n\n比特币是基于区块链技术的一种应用，其中都会涉及到密码学，博弈论，记账技术，分布式系统。\n\n关于博弈论，书中有个有趣的例子。\n\n<!--more--> \n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1k5mhmnj20r4088acj.jpg)","source":"_posts/读书/区块链初认识.md","raw":"---\nlayout: post\ntitle: \"区块链初认识\"\ndate: 2017-11-20 14:58\ncomments: true\nreward: true\ntags: \n\t- 读书\n---\n\n读自：[区块链技术指南](https://www.gitbook.com/book/yeasy/blockchain_guide/details)\n\n我现在的理解来说区块链就是去中心化的分布式记账系统，只可能添加记录，发生过的记录都不可篡改。\n\n比特币是基于区块链技术的一种应用，其中都会涉及到密码学，博弈论，记账技术，分布式系统。\n\n关于博弈论，书中有个有趣的例子。\n\n<!--more--> \n\n![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1k5mhmnj20r4088acj.jpg)","slug":"读书/区块链初认识","published":1,"updated":"2020-08-09T05:24:13.302Z","photos":[],"link":"","_id":"ckdmsee8p002xlguw1re7nv53","content":"<p>读自：<a href=\"https://www.gitbook.com/book/yeasy/blockchain_guide/details\" target=\"_blank\" rel=\"noopener\">区块链技术指南</a></p>\n<p>我现在的理解来说区块链就是去中心化的分布式记账系统，只可能添加记录，发生过的记录都不可篡改。</p>\n<p>比特币是基于区块链技术的一种应用，其中都会涉及到密码学，博弈论，记账技术，分布式系统。</p>\n<p>关于博弈论，书中有个有趣的例子。</p>\n<a id=\"more\"></a> \n<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1k5mhmnj20r4088acj.jpg\" alt></p>\n","site":{"data":{}},"excerpt":"<p>读自：<a href=\"https://www.gitbook.com/book/yeasy/blockchain_guide/details\" target=\"_blank\" rel=\"noopener\">区块链技术指南</a></p>\n<p>我现在的理解来说区块链就是去中心化的分布式记账系统，只可能添加记录，发生过的记录都不可篡改。</p>\n<p>比特币是基于区块链技术的一种应用，其中都会涉及到密码学，博弈论，记账技术，分布式系统。</p>\n<p>关于博弈论，书中有个有趣的例子。</p>","more":"<p><img src=\"http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1k5mhmnj20r4088acj.jpg\" alt></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckdmsedyk0002lguwa1038h9p","tag_id":"ckdmsedyq0005lguwimmyv40a","_id":"ckdmsedz0000alguwmp1vp6kc"},{"post_id":"ckdmsedyn0004lguwte49srd0","tag_id":"ckdmsedyz0009lguwfadjnl2r","_id":"ckdmsedzb000flguwdhfpqjo6"},{"post_id":"ckdmsedz9000elguws3083ntb","tag_id":"ckdmsedyz0009lguwfadjnl2r","_id":"ckdmsedze000ilguwi1qi8ila"},{"post_id":"ckdmsedys0006lguwbkue9jnv","tag_id":"ckdmsedz8000dlguwn89f7tau","_id":"ckdmsedzf000klguwws1iz4eq"},{"post_id":"ckdmsedzc000glguw5e2nrpwk","tag_id":"ckdmsedyq0005lguwimmyv40a","_id":"ckdmsedzh000mlguw7p8gzsvs"},{"post_id":"ckdmsedyv0007lguw7u64cv8v","tag_id":"ckdmsedze000hlguwf0f0891z","_id":"ckdmsedzk000plguw0eu875jg"},{"post_id":"ckdmsedyy0008lguww62a52gj","tag_id":"ckdmsedze000hlguwf0f0891z","_id":"ckdmsedzp000tlguw8pi60qsk"},{"post_id":"ckdmsedzn000slguw3kulllgd","tag_id":"ckdmsedz8000dlguwn89f7tau","_id":"ckdmsedzr000vlguw1yetutkt"},{"post_id":"ckdmsedz1000blguwgrepi7nb","tag_id":"ckdmsedze000hlguwf0f0891z","_id":"ckdmsedzu000ylguwu1rli60q"},{"post_id":"ckdmsedzp000ulguwu7d224w1","tag_id":"ckdmsedz8000dlguwn89f7tau","_id":"ckdmsedzw0010lguwvhzocr7z"},{"post_id":"ckdmsedzt000xlguw2m3csp5y","tag_id":"ckdmsedz8000dlguwn89f7tau","_id":"ckdmsedzy0013lguwfpjtwr27"},{"post_id":"ckdmsedz5000clguw16ixg23g","tag_id":"ckdmsedze000hlguwf0f0891z","_id":"ckdmsedzz0015lguwdwkjq1eq"},{"post_id":"ckdmsedzx0012lguwz2pggvqp","tag_id":"ckdmsedz8000dlguwn89f7tau","_id":"ckdmsee020018lguw80gotssg"},{"post_id":"ckdmsedzy0014lguw2hal4z0i","tag_id":"ckdmsedyq0005lguwimmyv40a","_id":"ckdmsee03001alguw91m1cst3"},{"post_id":"ckdmsedze000jlguwdwt51ozr","tag_id":"ckdmsedzw0011lguw2d5gy2iu","_id":"ckdmsee05001dlguw05e2czne"},{"post_id":"ckdmsedzz0016lguw75lzq7gg","tag_id":"ckdmsedzw0011lguw2d5gy2iu","_id":"ckdmsee07001flguw2z4y0cs4"},{"post_id":"ckdmsedzf000llguwjtmrz9pa","tag_id":"ckdmsee010017lguwi36noci0","_id":"ckdmsee08001hlguwbij3ba69"},{"post_id":"ckdmsedzi000olguwb2qv4b08","tag_id":"ckdmsee05001clguw0cvenhnl","_id":"ckdmsee08001ilguwi09d69es"},{"post_id":"ckdmsedzk000qlguwef3mxj0i","tag_id":"ckdmsee07001glguw8red1vqg","_id":"ckdmsee0b001klguwidrwi1a0"},{"post_id":"ckdmsedzv000zlguw8544adeo","tag_id":"ckdmsee05001clguw0cvenhnl","_id":"ckdmsee0c001llguwctby44o4"},{"post_id":"ckdmsee7r001rlguwrgpcjeb0","tag_id":"ckdmsee05001clguw0cvenhnl","_id":"ckdmsee7v001ulguwyahbqygu"},{"post_id":"ckdmsee7j001nlguw1hjc1akw","tag_id":"ckdmsee07001glguw8red1vqg","_id":"ckdmsee7w001wlguwwg3uh7ys"},{"post_id":"ckdmsee7j001nlguw1hjc1akw","tag_id":"ckdmsee7p001plguw1ax00ayb","_id":"ckdmsee7z001zlguwanfkq9rs"},{"post_id":"ckdmsee7s001slguwf04jfl3l","tag_id":"ckdmsee05001clguw0cvenhnl","_id":"ckdmsee810021lguw945sfwmt"},{"post_id":"ckdmsee7v001vlguw351z5uxp","tag_id":"ckdmsee7p001plguw1ax00ayb","_id":"ckdmsee820023lguwheoar1v2"},{"post_id":"ckdmsee7l001olguwlu272rhf","tag_id":"ckdmsee7p001plguw1ax00ayb","_id":"ckdmsee850025lguwr8i9s6nl"},{"post_id":"ckdmsee7x001xlguwwcbzzam2","tag_id":"ckdmsee05001clguw0cvenhnl","_id":"ckdmsee870027lguwu0vqq8vp"},{"post_id":"ckdmsee800020lguwc97i3qih","tag_id":"ckdmsedyz0009lguwfadjnl2r","_id":"ckdmsee880029lguwkl6kjp5u"},{"post_id":"ckdmsee7p001qlguwlqzfbsc7","tag_id":"ckdmsee7p001plguw1ax00ayb","_id":"ckdmsee89002blguw060wqblo"},{"post_id":"ckdmsee810022lguwqc45s1oo","tag_id":"ckdmsee07001glguw8red1vqg","_id":"ckdmsee8a002dlguw87eyua4g"},{"post_id":"ckdmsee820024lguwere5t16y","tag_id":"ckdmsee05001clguw0cvenhnl","_id":"ckdmsee8b002flguw73byn15i"},{"post_id":"ckdmsee860026lguw2jh38398","tag_id":"ckdmsee05001clguw0cvenhnl","_id":"ckdmsee8d002hlguwqe4ynvjq"},{"post_id":"ckdmsee870028lguwwjfribng","tag_id":"ckdmsee05001clguw0cvenhnl","_id":"ckdmsee8f002klguwlrvvd315"},{"post_id":"ckdmsee88002alguwata73xso","tag_id":"ckdmsee05001clguw0cvenhnl","_id":"ckdmsee8g002mlguw2mhido9o"},{"post_id":"ckdmsee89002clguwatpfeisc","tag_id":"ckdmsedyz0009lguwfadjnl2r","_id":"ckdmsee8i002olguw1kk3twka"},{"post_id":"ckdmsee8a002elguwx6496d1z","tag_id":"ckdmsee05001clguw0cvenhnl","_id":"ckdmsee8l002rlguwrb7w5l4u"},{"post_id":"ckdmsee8f002llguwkwzpvcq7","tag_id":"ckdmsee05001clguw0cvenhnl","_id":"ckdmsee8n002tlguwsm3xx0uq"},{"post_id":"ckdmsee8c002glguwer45h0ws","tag_id":"ckdmsee8e002jlguwwdbis3xu","_id":"ckdmsee8p002wlguweh3qq7e0"},{"post_id":"ckdmsee8m002slguwdphz86c5","tag_id":"ckdmsee010017lguwi36noci0","_id":"ckdmsee8q002ylguwhla7onkm"},{"post_id":"ckdmsee8d002ilguwtarac8jt","tag_id":"ckdmsee8e002jlguwwdbis3xu","_id":"ckdmsee8r0030lguw9xmccw41"},{"post_id":"ckdmsee8h002nlguw46bnvrtu","tag_id":"ckdmsee8o002vlguwl6s0e75h","_id":"ckdmsee8r0031lguw9ivffyqr"},{"post_id":"ckdmsee8j002plguw41lvmxss","tag_id":"ckdmsee8o002vlguwl6s0e75h","_id":"ckdmsee8s0033lguwsoyeb895"},{"post_id":"ckdmsee8n002ulguwuhh841a8","tag_id":"ckdmsee8r0032lguw6f33i9px","_id":"ckdmsee8s0035lguwtuw0cq24"},{"post_id":"ckdmsee8p002xlguw1re7nv53","tag_id":"ckdmsee8r0032lguw6f33i9px","_id":"ckdmsee8t0036lguwpc9q44tr"}],"Tag":[{"name":"个人提升","_id":"ckdmsedyq0005lguwimmyv40a"},{"name":"Java","_id":"ckdmsedyz0009lguwfadjnl2r"},{"name":"校招","_id":"ckdmsedz8000dlguwn89f7tau"},{"name":"Mysql","_id":"ckdmsedze000hlguwf0f0891z"},{"name":"计算机网络","_id":"ckdmsedzw0011lguw2d5gy2iu"},{"name":"生活","_id":"ckdmsee010017lguwi36noci0"},{"name":"JAVA","_id":"ckdmsee05001clguw0cvenhnl"},{"name":"leetcode","_id":"ckdmsee07001glguw8red1vqg"},{"name":"C++","_id":"ckdmsee7p001plguw1ax00ayb"},{"name":"TED","_id":"ckdmsee8e002jlguwwdbis3xu"},{"name":"前端","_id":"ckdmsee8o002vlguwl6s0e75h"},{"name":"读书","_id":"ckdmsee8r0032lguw6f33i9px"}]}}