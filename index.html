<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta name="referrer" content="no-referrer" />
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"luckzp.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ZhangPeng">
<meta property="og:url" content="https://luckzp.github.io/index.html">
<meta property="og:site_name" content="ZhangPeng">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhang Peng">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://luckzp.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ZhangPeng</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ZhangPeng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">To be what you want to be</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luckzp.github.io/2021/04/06/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangPeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/06/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" class="post-title-link" itemprop="url">架构设计原则</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-06 02:03:58" itemprop="dateCreated datePublished" datetime="2021-04-06T02:03:58+00:00">2021-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 02:12:38" itemprop="dateModified" datetime="2021-06-14T02:12:38+00:00">2021-06-14</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-users"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="firestore-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.架构设计考虑的方面</p>
<ul>
<li><p>扩展性（伸缩性）</p>
</li>
<li><p>可用性</p>
</li>
<li><p>可靠性</p>
</li>
<li><p>一致性</p>
</li>
<li><p>负载均衡</p>
</li>
<li><p>过载保护</p>
</li>
<li><p>灾难恢复和备份</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luckzp.github.io/2021/03/31/Netty%E5%88%9D%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangPeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/31/Netty%E5%88%9D%E8%AF%86/" class="post-title-link" itemprop="url">Netty初识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-31 10:40:18" itemprop="dateCreated datePublished" datetime="2021-03-31T10:40:18+00:00">2021-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 02:12:38" itemprop="dateModified" datetime="2021-06-14T02:12:38+00:00">2021-06-14</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-users"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="firestore-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.Netty 定义。<br>Netty is an <strong>asynchronous event-driven</strong> network application frameworkfor rapid development of maintainable high performance protocol servers &amp; clients. 2.为什么不用 Java 的 NIO 库而用 Netty。（抛出问题，用 netty 解决问题。）<br>编写代码复杂。<br>传统的库要基于 Socket 进行基本的 I/O 操作（bind()、connect()、read()和 write()）依赖于底层网络传输所提供的原语。<br>Netty 的 Channel 接口所提供的 API，大大地降低了直接使用 Socket 类的复杂性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Selector selector = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(String ip, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建选择器</span></span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">//打开监听通道</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//连接对应的服务器 ip , port</span></span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(ip, port));</span><br><span class="line">        <span class="comment">//注册select为连接状态</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端，启动成功...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//阻塞方法，轮询注册的channel,当至少一个channel就绪的时候才会继续往下执行</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">//获取就绪的SelectionKey</span></span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = keys.iterator();</span><br><span class="line">            SelectionKey key = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//迭代就绪的key</span></span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                key = it.next();</span><br><span class="line">                it.remove();</span><br><span class="line">                <span class="comment">//SelectionKey相当于是一个Channel的表示，标记当前channel处于什么状态</span></span><br><span class="line">                <span class="comment">// 按照channel的不同状态处理数据</span></span><br><span class="line">                process(key);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//channel处于可连接状态，发送消息给服务端</span></span><br><span class="line">        <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;connect事件就绪 ....&quot;</span>);</span><br><span class="line">            SocketChannel clientChannel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="keyword">if</span> (clientChannel.isConnectionPending()) &#123;</span><br><span class="line">                clientChannel.finishConnect();</span><br><span class="line">            &#125;</span><br><span class="line">            clientChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            String name = UUID.randomUUID().toString();</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端发送数据：&#123;&#125;&quot;</span> + name);</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.wrap(name.getBytes());</span><br><span class="line">            clientChannel.write(buffer);</span><br><span class="line">            clientChannel.register(key.selector(), SelectionKey.OP_READ);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">//获取对应的socket</span></span><br><span class="line">            System.out.println(<span class="string">&quot;read事件就绪 ....&quot;</span>);</span><br><span class="line">            SocketChannel socket = (SocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//设置一个读取数据的Buffer 大小为1024</span></span><br><span class="line">            ByteBuffer buff = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            StringBuilder content = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">int</span> len = socket.read(buff);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                buff.flip();</span><br><span class="line">                content.append(<span class="keyword">new</span> String(buff.array(), <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">                <span class="comment">//让客户端读取下一次read</span></span><br><span class="line">                System.out.println(<span class="string">&quot;客户端收到反馈：&quot;</span> + content);</span><br><span class="line">                key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                key.cancel();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        NioClient client = <span class="keyword">new</span> NioClient();</span><br><span class="line">        client.start(<span class="string">&quot;localhost&quot;</span>,<span class="number">8080</span>);</span><br><span class="line">        client.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">        <span class="keyword">new</span> EchoClient(host, port).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            b.group(group);</span><br><span class="line">            b.channel(NioSocketChannel.class);</span><br><span class="line">            b.handler(<span class="keyword">new</span> ClientHandlerInitializer());</span><br><span class="line">            <span class="comment">// 连接服务器</span></span><br><span class="line">            Channel ch = b.connect(host, port).sync().channel();</span><br><span class="line">            <span class="comment">// 接受系统输入</span></span><br><span class="line">            BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">            <span class="comment">// 连续输入</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                String line = in.readLine();</span><br><span class="line">                <span class="keyword">if</span> (line == <span class="keyword">null</span>) <span class="comment">// 如果是空行, 则跳过本次循环, 不输出</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                ch.writeAndFlush(line + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同的 IO 有不同的网络 API<br>Netty 为它所有的传输实现提供了一个通用 API 3.用 Netty 实现 NIO,BIO,AIO。<br>NIO 的性能最好，实际上 linux 内核并不支持 aio，通过 epoll(true/false)来区分 nio 或者 aio。<br>4.Netty 在其他方面的应用。<br>Dubbo,Zookeeper,Redission<br>5.Netty 与 OOM。 6.核心组件。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/431489/1623636657252-17c7ae20-0bce-42db-b43e-138cd16bcc5d.png#clientId=ucec7778f-a6a5-4&from=drop&id=u54151b0d&margin=%5Bobject%20Object%5D&name=%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210614101004.png&originHeight=893&originWidth=1176&originalType=binary%E2%88%B6=2&size=273869&status=done&style=none&taskId=ub29de705-d581-4897-b6eb-78f369785c9" alt="微信截图_20210614101004.png"><br>Channel-Socket<br>Channel 是一个连接，可以看作是传入（入站）或者传出（出站）数据的载体。因此，它可以被打开或者被关闭，连接或者断开连接。<br>ChaneelFuture-异步通知<br>Netty 中所有的 I/O 操作都是异步的。因为一个操作可能不会立即返回，所以我们需要一种用于在之后的某个时间点确定其结果的方法。为此，Netty 提供了<br>ChannelFuture 接口，其 addListener()方法注册了一个 ChannelFutureListener，以<br>便在某个操作完成时（无论是否成功）得到通知。<br>关于 ChannelFuture 的更多讨论 可以将 ChannelFuture 看作是将来要执行的操作的结果的<br>占位符。它究竟 什么时候 被执行则可能取决于若干的因素，因此不可能准确地预测，但是可以肯<br>定的是它 将会 被执行。此外，所有属于同一个 Channel 的操作都被保证其将以它们被调用的顺序<br>被执行。<br>EventLoop-控制，多线程处理，并发。<br>EventLoop 与 EventGroupLoop<br><img src="https://cdn.nlark.com/yuque/0/2021/png/431489/1620091628053-3bff2704-0bc9-49d2-8d00-44663d318bed.png#clientId=u7562e9d3-9a48-4&from=drop&id=uf626b9d9&margin=%5Bobject%20Object%5D&name=%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210504092642.png&originHeight=1162&originWidth=1326&originalType=binary%E2%88%B6=1&size=155535&status=done&style=none&taskId=udca0b64a-c1d8-48bf-86a8-a4448bcad74" alt="微信截图_20210504092642.png"><br>ChannelHandler，ChannelPipeline 和 ChannelHandlerContext<br><strong>ChannelHandler</strong>从应用程序开发人员的角度来看，Netty 的主要组件是 ChannelHandler，它充当了所有处理入站和出站数据的应用程序逻辑的容器。Netty 以适配器类的形式提供了大量默认的 ChannelHandler,帮我们简化了开发。<br><strong>ChannelPipeline</strong>提供了 ChannelHandler 链的容器，并定义了用于在该链上传播入站和出站事件流的 API。当 Channel 被添加到 ChannelPipeline 时，将会被分配一个<strong>ChannelHandlerContext</strong>的关系，代表 ChannelHandler 和 ChannelPipeline 的关系。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/431489/1620093990658-1fe0742c-5ddc-4716-a2ff-eb29d64d52d9.png#clientId=u7562e9d3-9a48-4&from=paste&height=158&id=u9f6fe988&margin=%5Bobject%20Object%5D&name=image.png&originHeight=316&originWidth=1054&originalType=binary%E2%88%B6=1&size=41726&status=done&style=none&taskId=u245fc795-88a4-40ff-b85f-2b836fbaf91&width=527" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/431489/1620094169648-72e1a305-ea6b-40ea-a098-c55d75471988.png#clientId=u7562e9d3-9a48-4&from=paste&height=301&id=u519c1ca9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=601&originWidth=1170&originalType=binary%E2%88%B6=1&size=96674&status=done&style=none&taskId=udd6e646c-26ea-48c9-b11b-d0ec35a7919&width=585" alt="image.png"><br><strong>ByteBuf</strong><br>网络数据的基本单位总是字节。Java NIO 提供了 ByteBuffer 作为它的字节容器，但是这个类使用起来过于复杂，而且也有些繁琐。<br>Netty 的 ByteBuffer 替代品是 ByteBuf ，一个强大的实现，既解决了 JDK API 的局限性，<br>又为网络应用程序的开发者提供了更好的 API。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/431489/1620131709419-3c5403fb-fb23-4aef-a707-c80e28985113.png#clientId=u36e6b809-5f6a-4&from=paste&height=205&id=u732834ba&margin=%5Bobject%20Object%5D&name=image.png&originHeight=410&originWidth=995&originalType=binary%E2%88%B6=1&size=61281&status=done&style=none&taskId=u05401848-c4cb-4d7a-9c74-843c18bc639&width=497.5" alt="image.png"><br>7.TCP 粘包拆包以及解决方案<br>TCP 粘包/拆包发⽣的原因（1）应⽤程序 write 写⼊的字节⼤⼩⼤于套接⼝发送缓冲区⼤⼩；<br>（2）进⾏ MSS（Maxitum Segment Size 最⼤分段⼤⼩）⼤⼩的 TCP 分段；<br>（3）以太⽹帧的 payload ⼤于 MTU（Maxitum Transmission Unit 最⼤传输单元）进⾏ IP 分⽚。<br>粘包问题的解决策略<br>（1）消息定⻓，例如每个报⽂的⼤⼩为固定⻓度 200 字节，如果不够，空位补空格；<br>（2）在包尾增加回⻋换换符进⾏分割，例如 FTP 协议；<br>（3）将消息分为消息头和消息体，消息头中包含表示消息总⻓度（或者消息体⻓度）的字段，通常设计思<br>想为消息头的⼀个字段使⽤ int32 来表示消息的总⻓度；<br>（4）更复杂的应⽤层协议。<br>8.Netty 应用<br>以 RocketMQ 为例<br>​</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luckzp.github.io/2021/03/06/%E6%8E%92%E6%9F%A5%E7%8E%B0%E7%BD%91%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangPeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/06/%E6%8E%92%E6%9F%A5%E7%8E%B0%E7%BD%91%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">排查现网问题分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-06 14:04:12" itemprop="dateCreated datePublished" datetime="2021-03-06T14:04:12+00:00">2021-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 02:12:38" itemprop="dateModified" datetime="2021-06-14T02:12:38+00:00">2021-06-14</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-users"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="firestore-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>吞吐量（TPS，QPS）：按时段考虑。<br>并发：按时刻考虑。 1.查看日志报错 too many connection，Mysql 连接数爆了。</p>
<ul>
<li><p>查询当前 Mysql 连接数和设置的最大连接数。</p>
</li>
<li><p>查询是否有慢查询。</p>
<p>2.数据库 CPU 使用率过高</p>
</li>
<li><p>SQL 查询频率很高，qps 是否过高。</p>
</li>
<li><p>SQL 未走到索引，导致扫描行数过多，甚至全表扫描。</p>
</li>
</ul>
<p>开启 MySQL 慢查询的步骤</p>
<p>在 my.cnf 的[mysqld]配置下，修改一下参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#启用记录慢SQL功能</span><br><span class="line">slow_query_log &#x3D; 1</span><br><span class="line">#设置超过1秒的SQL为慢SQL</span><br><span class="line">long_query_time &#x3D; 1</span><br><span class="line">#记录慢sql日志路径</span><br><span class="line">Slow_query_log_file &#x3D; &#x2F;data&#x2F;mysql&#x2F;mysql-slow.log</span><br><span class="line">重启mysql服务，让配置生效</span><br></pre></td></tr></table></figure>

<p>开启 mongo 慢查询日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1).mongodb慢查询日志是否开启：db.getProfilingLevel();</span><br><span class="line">2).0为关闭慢查询，1开启慢查询，2记录全部查询命令：设置慢查询状态为1，时长&gt;100ms：</span><br><span class="line">db.setProfilingLevel(1,100);</span><br><span class="line">3).返回最近的10条慢查询：db.system.profile. find ().limit(10). sort (&#123; ts : -1 &#125;).pretty();</span><br><span class="line">根据日志做出判断</span><br><span class="line">1).不合理的索引关键字：IXSCAN、keysExamined；若keysExamined (扫描索引建的记录数)大于</span><br><span class="line">nreturned(返回结果的记录数)，需要考虑优化索引；</span><br><span class="line">2).全表扫描关键字：COLLSCAN、docsExamined，记录中涉及全表扫描；</span><br></pre></td></tr></table></figure>

<p>3.QPS 有规律波动</p>
<ul>
<li>tcp 的全连接队列与半连接队列被占满。</li>
<li>TCP 连接不够用。</li>
</ul>
<p>启动 TCP 快速回收。</p>
<p>修改 linuxTCP 相关配置其中 net.ipv4. tcp_max_syn_backlog 为半连接队列长度，net.core.somaxconn 为全连接队列长度，这两个值要足够大。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luckzp.github.io/2021/02/21/%E5%BA%94%E5%AF%B9%E8%BF%9E%E7%8E%AF%E7%82%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangPeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/21/%E5%BA%94%E5%AF%B9%E8%BF%9E%E7%8E%AF%E7%82%AE/" class="post-title-link" itemprop="url">应对连环炮</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-21 02:38:08" itemprop="dateCreated datePublished" datetime="2021-02-21T02:38:08+00:00">2021-02-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 02:12:39" itemprop="dateModified" datetime="2021-06-14T02:12:39+00:00">2021-06-14</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-users"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="firestore-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>HashSet 的底层实现说下？</strong><br>内置 HashMap,将加入的元素作为 HashMap 的 key。<br><strong>说下 HashMap 的数据结构，为什么 loadFactor 是 0.75？</strong><br>数组+红黑树，0.75 是 HashMap 空间和时间的权衡，提高 loadFactor 会降低空间的开销，但是会增加查询时间的开销（get 和 put）。<br><strong>为什么要高位参与与运算？</strong><br>这其实也是扰动函数，为了降低哈希码的冲突。右位移 16 位，正好是 32bit 的一半，高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。<br>为什么它的 size 是 2 的 n 次方？<br>因为对 key 的 hashCode 进行扰动函数处理之后，是根据（n-1）&amp; hash 判断元素在数组中的位置的。<br>为什么默认是 16？讲下它的扩容机制。<br><strong>遍历数组，然后遍历数组链表，从链表头到尾，</strong>保留 next = e.next;先计算出节点在新 hashmp 的数组位置 i，然后用<strong>头插法将节点插入到新数组的头结点</strong>（e.next = new B）。e = next; do while(e != null)之后的一样。<br>什么时候转红黑树，为什么要转红黑树？<br>为什么它是线程不安全的，它的哪些方法是线程不安全的？<br>Put 的时候会导致数据会覆盖<br>为什么会造成死循环？1.8 是如何解决这个问题的？它的线程安全的实现有什么？ConcurrentHashMap 和 HashTable 有什么区别？说下它 1.7 和 1.8 的实现是什么？有什么区别？为什么要这么做？为什么说 ConcurrentHashMap 是线程安全的？它的 get 操作是有锁的吗？它是强一致性的吗？它为什么是弱一致性的？</p>
<ul>
<li>get 操作全程不需要加锁是因为 Node 的成员 val 是用 volatile 修饰的和数组用 volatile 修饰没有关系。</li>
<li>数组用 volatile 修饰主要是保证在数组扩容的时候保证可见性。</li>
<li>弱一致性，get 方法只能保证看到之前完成的操作，无法保证看到正在进行中的操作。</li>
</ul>
<p>ConcurrentHashMap 1.7 和 1.8 是如何扩容的？sizeCtl 参数是干什么的，讲讲变换过程？<br>为什么要用 volatile 修饰？说说它的功能？<br>,这个关键字只是告诉编译器这个变量是易变的,每次使用该变量时都要重新从内存读取。<br>什么是 MESI 协议？<br>多核 cpu 保证 cache 一致性<br>CPU 原语是什么？什么是可见性？<br><strong>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</strong><br>JMM 说说是什么？为什么要有 JMM？<br>所有的变量都存储在主内存中，每个线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读取主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。<br>Happened-before 是什么？它和 synchronized 的区别是什么？<br><strong>前一个操作的结果对后续操作时可见的</strong>。<br>synchronized：<br>锁的升级与降级说下是什么？自旋锁是什么？偏向锁是什么？Mark-Word 说下？锁的粒度是什么？锁消除了解吗？锁会被合并吗？什么时候会发生？<br><strong>锁消除</strong>：对于被检测出不可能存在竞争的共享数据的锁进行消除。(逃逸分析)<br><strong>锁粗化</strong>:虚拟机探测到一系列连续操作都对同一个对象加锁解锁，就将加锁的范围粗化到整个操作系列的外部。<br><strong>偏向锁</strong>：<strong>当锁对象第一次被线程获取的时候，进入偏向状态，标记为 101，同时 CAS 将线程 ID 进入到对象头的 Mark Word 中，如果成功，这个线程以后每次获取锁就不再需要进行同步操作，甚至 CAS 不都需要。当另一个线程尝试获取这个锁，偏向状态结束，恢复到未锁定状态或者轻量级状态。</strong><br><strong>轻量级锁</strong>：对象头的内存布局 Mark Word,有个 tag bits,记录了锁的四种状态:无琐状态，偏向锁状态，轻量级锁状态，重量级锁状态.轻量级锁相对重量级锁而言，使用 CAS 去避免重量级锁使用互斥量的开销。线程尝试获取锁时，如果锁处于无琐状态，先采用 CAS 去尝试获取锁，如果成功，锁状态更新为轻量级锁状态。如果有两条以上的线程争用一个锁，状态重为重量级锁。<br>你刚才说了 CAS，你能说下它是什么东西吗？为什么要引入 CAS？ABA 问题是如何解决的？AQS 了解吗？它是如何实现的？CLH 又是什么？<br>CLH,是虚拟的双向队列，即不存在队列实例，<strong>仅存在节点与节点之间的 pre 和 next 关系。AQS 将每条请求共享资源的线程封装成一个 CLH 锁队列的一个节点来实现锁的分配。</strong><br>ReentrantLock 和 synchronized 区别是什么？为什么 ReetrantLock 能实现公平锁？默认构造器是公平锁吗？为什么不是？<br>两者都是可重入锁(自己可以再次获取自己的内部锁)，锁计数器加 1;<br>synchronized 只能是是非公平锁，而 ReenTrantLock 默认实现非公平锁，也支持公平锁(先等先得)<br>synchronized 依赖于 JVM 实现，而 ReenTrantLock 是基于 JDK 实现的;<br>ReenTrantLock 功能加多：1、<strong>等待可中断</strong>，2、<strong>支持公平锁</strong>，3、<strong>基于 Condition 实现选择性唤醒;</strong><br>Copy-on-Write 了解吗？Fork/Join 又是什么？什么是线程，什么是协程？你刚才说了管程？你能说下这几个到底是做什么的吗？线程池说下参数，四种内置的拒绝策略，以及它的执行流程。你用过吗？为什么要这么设置参数？I/O 密集型应用和计算密集型应用如何设置其参数？你具体的业务线程池的参数是怎么设计的？为什么？测过吗？你定制化开发过吗？线程池预留了 3 个供子类扩展的方法你知道是哪三个吗？能做什么你知道吗？ThreadLocal 是什么？它为什么会造成内存泄漏？你实际开发中用到过吗？Spring 事务用这个干什么的？<br>Spring 事务管理通过使用 ThreadLocal，解除了事务管理模块与数据访问层的紧密耦合，提高了模块的可重用性，也保证了多线程环境下的对 connection 资源的有效管理，实现了线程安全。<br>什么是 Spring 事务的 SavePoint？<br>保存点，记录操作的当前位置，之后可以回滚到指定的位置<br>你知道死锁吗？如何解决死锁？<br><strong>产生死锁的原因主要是：</strong>（1） 因为系统资源不足。（2） 进程运行推进的顺序不合适。（3） 资源分配不当等。<br><strong>死锁的必要条件：</strong><br>  互斥条件（Mutual exclusion）：资源不能被共享，只能由一个进程使用。<br>  请求与保持条件（Hold and wait）：已经得到资源的进程可以再次申请新的资源。<br>非剥夺条件（No pre-emption）：已经分配的资源不能从相应的进程中被强制地剥夺。<br>循环等待条件（Circular wait）：系统中若干进程组成环路，改环路中每个进程都在等待相邻进程正占用的资源。<br>sleep 和 wait 的区别是什么？BIO、NIO、AIO 是什么？说下区别，以及如何使用？了解 Netty 吗？如何解决粘包问题？ChannelPipeline 又是什么？ByteBuf 知道吗？读写指针又是什么？为什么要用它，解决了 NIO 类库的 ByteBuffer 什么问题？它和 mina 的区别是什么？它的 Zero-Copy？了解过 FastThreadLocal 吗？它为什么比 ThreadLocal 快？有看过其中源码吗？Netty 解决了 NIO 类库的什么问题？空轮询又是什么？RPC 又是什么？序列化和反序列化又是什么？几个核心抽象说下。是干什么的？讲讲 Netty 的线程模型。</p>
<p>你说你了解虚拟机，你知道虚拟机的运行时数据区吗？哪些是线程共享的，哪些是线程独有的？<br>线程私有的：程序计数器<br>虚拟机栈<br>本地⽅法栈<br>线程共享的：<br>堆<br>⽅法区<br>直接内存 (⾮运⾏时数据区的⼀部分)<br>你了解 JVM 调优吗？调优过吗？为什么要这么设置？垃圾回收算法有几种？为什么要分代收集？<br>⽐如在新⽣代中，每次收集都会有⼤量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。⽽⽼年代的对象存活⼏率是⽐较⾼的，⽽且没有额外的空<br>间对它进⾏分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进⾏垃圾收集。<br>Young 区说说它的分布结构，为什么 Eden 区 80%？为什么大对象直接进入老年代？控制的参数是什么？一个对象如果不是大对象，怎样才能进入老年代？控制的参数是什么？什么时候会发生 OOM？你遇到过吗？怎么解决的？为什么低版本的 JDK 要把永久代内存调大点？默认大小是多少你知道吗？什么是 Major GC，什么是 Minor GC？什么情况下会频繁 GC？你查看过 GC 日志吗？什么时候回收对象？引用计数和可达性分析是什么？为什么 Java 使用后者？Python 使用前者？什么是 GCRoot？什么类型的对象可以作为 GCRoot？什么时候对象不可达？Java 的四种引用说下，分别用在什么场景？你知道 JDK 源码哪里有用到 WeakReference 吗？什么是 STW？什么是 Safepoint？类加载的过程说下，什么时候优化，以及不同的阶段的主要优化是什么？解语法糖是什么时候？为什么在编译的时候解语法糖？什么是双亲委派模型？可以破坏吗？各个 ClassLoader 加载哪部分类的？你自定义过 ClassLoader 吗？你说你用过 Jstack 诊断 CPU 使用率飙升的情况，说下具体步骤？Arthas 用过吗？Class 文件格式说下，什么是魔数，Class 文件的魔数是什么？JMX 了解吗？生产上有碰到过虚拟机的问题吗？怎么解决的？</p>
<p>ACID 说下是什么，如何实现的？<br>Atomicity Consistency Isolation Durability<br>你说你优化过 SQL，怎么优化的说下。like ‘%xx%’，like ‘%xx’，like ‘xx%’ 哪种情况会用到索引，为什么？说下 MySQL 执行流程。WAL(Write-Ahead Logging) 知道吗？redo log 和 undo log 是什么，它们作用说下。你说你改过 buffer_pool_size 等参数，为什么要改它？它里面的数据结构说下是什么？为什么冷热 3:7？join_buffer 你说你也改了，为什么？什么是驱动表和被驱动表？如何优化？你说你建了索引，什么是蔟集索引，什么是非蔟集索引？什么是回表？什么时候会索引失效？你的二级索引什么用得多？为什么优先使用普通索引，而不是唯一索引？MySQL 会死锁吗？什么是间隙锁？它会导致什么问题？MVCC 说下是什么？4 种事务说下是什么？哪种或者哪几种事务隔离级别能避免幻读？能避免脏读？你说你还开启了 binlog，能说说是什么吗？binlog 有几种格式？你选的是哪个？为什么？canal 用过吗？说说它的原理。MySQL 主从模式如何开启？你是如何优化 SQL 的？上亿级别的数据你是如何优化分页的？为什么不建议在 MySQL 中使用分区机制？几个主要的线程说下它们是什么？做什么的？MySQL 读写了解吗？如何实现的？能做到强一致性吗？为什么？为什么删了数据还是磁盘空间不变？自增主键用完了会怎么样？如何解决这个问题？自增主键什么时候是不连续的？这样做的好处是什么？为什么推荐用自增主键？B+ Tree 又是什么？如何迁移数据库？为什么不建议使用外键？在高版本的 MySQL 中 count(1) 和 count(*) 区别是什么？order by 是如何工作的？分页机制又是什么？ACL 和 RBAC 是什么？PBAC 和 ABAC 知道吗说下？grant 之后一定要刷新吗？视图用过吗？它的作用说下。视图和表的区别说下。存储过程写过吗？存储函数和存储过程的区别说下。为什么要分库分表？分库分表如何做到动态缩容/扩容？NoSQL 用过吗？OceanBase 了解吗？HBase 了解吗？HBase 有哪些坑，你碰到过吗？什么是 RegionServer？什么时候用 NoSQL，它能取代 RDBMS 吗？你说你用过 Elasticsearch，能说下它的请求执行过程吗？它的总体架构说下，画一下。它的插件你用过吗？你们的分词策略是什么？倒排索引说下是什么。</p>
<p>线程和进程说下区别？线程的几种状态说下。Java 中的线程和操作系统的线程关系？动态内存分配和回收策略是什么？什么是空闲列表和指针碰撞？具体用什么数据结构存的？什么时候用它们？空闲列表四种策略说下。Page Cache 知道吗，说说它的作用。Redis 和 Kafka 中间件如何通过 Page Cache 来优化？哪些类型会导致内存泄漏？TCP 和 HTTP 是什么？它们之间的关系说下。OSI 七层是哪七层？分别是干什么的？TCP 和 UDP 区别是什么？什么时候会导致 TCP 抖动？TCP 是如何保证稳定的？我就要用 UDP，如何使它和 TCP 一样能保证数据到达？CPU 是如何执行任务的？你知道 numa 架构吗？哪些中间件可以通过这个来怎么优化？为什么绑核能优化？什么是 Zero-Copy？你用的中间件中有哪些用到了这个特性？内核态和用户态是什么？硬件你了解过吗？什么是 x86？什么是 ARM？你说精简指令集？它精简了什么？ARM 架构的 CPU 是什么样的？画一下。M1 芯片为什么这么快，有了解吗？5G 有了解吗？有点题外话了，最后问你个问题，你说你是软件通信工程，通信学的什么？选修了什么？通信是学硬件吗？光纤为什么这么快？8 根线和 4 根线区别？傅立叶变换说下是什么？数字信号模拟信号？你大学在班级定位？前几？</p>
<p>Redis 它的 5 种基础类型和 6 个数据结构说下。<br>String、List、Set、Hash、ZSet 和简单动态字符串，链表，字典，跳跃表，整数集合，压缩列表。<br>HyperLogLog、BitMap、GEO、Stream 有接触过吗？什么时候用这些特殊数据结构？跳表又是什么，画一下？为什么使用跳表？<br>跳跃表（skiplist）是一种有序数据结构，<strong>它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。跳跃表通常是有序集合的底层实现之一，表中的节点按照分值大小进行排序。</strong><br>1、<strong>由很多层结构组成；</strong><br>2、<strong>每一层都是一个有序的链表，</strong>排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的 head 节点和后面的 nil 节点；<br>3、<strong>最底层的链表包含了所有的元素；</strong><br>4、如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）；<br>5、<strong>链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点；</strong><br>为什么不用红黑树？全局 Hash 表又是什么？如何扩容的？什么是渐进式 rehash？Redis 怎么做到的？IO 多路复用是什么？多路是什么？复用了什么？AOF 和 RDB 又是什么？为什么 Redis 没有实现 WAL 机制？AOF 持久化策略有哪三种？你们是怎么选的？AOF 什么时候重写？为什么重写？主从复制用到了哪种日志？主从复制过程说下。主从复制什么时候增量，什么时候全量？第一次连接时，网络中断了怎么办？Redis 主从是什么？主从从又是什么？为什么主从从可以减少主库压力？从库可以设置可写吗？从库可写会带来什么问题？主从什么时候会导致数据丢失？Redis 十万并发能支撑住吗？如何支撑十万以上并发？为什么操作大对象支持不了十万并发？Redis Cluster 是什么？ 你说到了 CRC16，你知道一致性哈希算法吗，能说下是什么吗？你说虚拟节点，说下如何实现？Codis 了解吗？你们的 Redis 集群方案是什么？Redis 是如何保证高可用的？哨兵机制了解吗？什么是主观下线什么是客观下线？选主的四个筛选条件优先级的条件依次递减分别是什么？打分又是什么？如何打分？缓存击穿、缓存雪崩、缓存穿透说下？如何解决？布隆过滤器又是什么？能手写个布隆过滤器吗？数据倾斜知道吗，如何解决？分布式锁了解过吗？讲讲分布式锁实现原理？Redisson 源码看过吗？它是如何实现的分布式锁？Lua 脚本保证原子性吗？分布式锁需要注意哪四个问题？Redis 事务说下。缓存污染知道是什么吗？如何淘汰数据的？分别是哪八种策略？Redis 对 lru 做了什么改变吗？lfu 又是什么？Redis 做了什么优化？Redis 多线程是什么多线程？默认开启吗？你们生产中用了吗？Redis 6 还有什么新特性？自定义过 Redis 数据类型吗？自定义过 Redis 命令吗？如何解决数据库和缓存数据不一致问题？Pika 知道吗？Tendis 和它的区别？如何实现一个 Key 千万并发？（这个有个群的群友的 Zoom 面试题）</p>
<p>消息中间件解决了哪几个问题？简单介绍下你用的 Kafka。从 Topic -&gt; Record&lt;Key,Value&gt; -&gt; Producer -&gt; acks -&gt; Interceptor -&gt; Broker -&gt; Page Cache -&gt; Controller -&gt; Coordinator -&gt; Partition -&gt; Replica -&gt; Leader Replica -&gt; Follower Replica -&gt; ISR -&gt; Unclean Leader Election -&gt; Consumer -&gt; Consumer Group -&gt; Consumer Offset -&gt; Consumer Group Offset -&gt; Idempotence -&gt; Transaction -&gt; Rebalance -&gt; High Watermark -&gt; Log Deletion -&gt; Leader Epoch -&gt; LEO -&gt; Zero Copy -&gt; Consumer Heartbeat -&gt; Zookeeper 到这结束。它和 RocketMQ、RabbitMQ 有什么区别？什么时候消息会丢失？Producer 网络抖动后，它的消息在哪存着，内存还是磁盘还是哪里？Producer 和 Consumer 什么时候建立的 TCP 连接？为什么这么做？Consumer 为什么要采取 pull 的方式？Producer 为什么采用 push 的方式？为什么用 TCP 不用 HTTP？高水位、LEO 是什么？Lead Epoch 知道吗？幂等性是如何实现的？说下 Kafka 事务，Kafka 事务实现的事务隔离级别？什么时候触发 Rebalance？如何避免？如何指定发送消息到指定 Partition？消息交付可靠性保障承诺三个说下，以及 Kafka 是如何实现它们的？哦，你说精准一次，怎么实现的？根据消息数以及消息大小，计算需要多少磁盘容量和带宽。Kafka 的 JVM 参数调优说下。 JMS 了解吗？<br><strong>RabbitMQ:</strong><br>1、如何保证消息的可靠性传输（如何处理消息丢失的问题）？<br>1）生产者弄丢了数据：可以开启 confirm 模式，每次写的消息都会分配一个唯一的 id，然后如果写入了 rabbitmq 中，rabbitmq 会给你回传一个 ack 消息，告诉你说这个消息 ok 了。如果 rabbitmq 没能处理这个消息，会回调你一个 nack 接口，告诉你这个消息接收失败，你可以重试。<strong>confirm 机制是异步的。</strong><br><strong>2）</strong>rabbitmq 弄丢了数据，<strong>开启 rabbitmq 的持久化</strong>，就是消息写入之后会<strong>持久化到磁盘</strong>。<strong>创建 queue 的时候将其设置为持久化的，发送消息的时候将</strong><br><strong>消息的 deliveryMode 设置为 2，就是将消息设置为持久化的，此时 rabbitmq 就会将消息持久化到磁盘上去。</strong>而且持久化<strong>可以跟生产者那边的 confirm 机制配合起来</strong>，只有消息被持久化到磁盘之后，才会通知生产者 ack 了。<br>3<strong>）消费端弄丢了数据：手动调用 rabbitmq 提供的 ack 机制。每次你自己代码里确保处理完的时候，再程序里 ack 一把。</strong>这样的话，如果你还没处理完，不就没有 ack？那 rabbitmq 就认为你还没处理完，这个时候 rabbitmq 会把这个消费分配给别的 consumer 去处理。<br><strong>2、保证消息是有顺序的；</strong><br><strong>拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</strong><br><strong>3、消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？</strong><br><strong>可能你的消费端出了问题，不消费了。</strong><br><strong>先修复 consumer 的问题，确保其恢复消费速度，临时紧急扩容，将 queue 资源和 consumer 资源扩大，增加消费能力，等快速消费完积压数据之后，得恢复原先部署架构。</strong><br><strong>rabbitmq，rabbitmq 是可以设置过期时间的，就是 TTL，大量积压在 mq 里，而是大量的数据会直接搞丢。批量重导，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。</strong><br><strong>4、如何保证消息不被重复消费啊</strong><br><strong>保证消息队列消费的幂等性就不怕，重复消费无所谓。主要是结合业务来谈：如写数据库，先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。如果是写 redis，那没问题了，反正每次都是 set，天然幂等性。如果是下订单，让生产者发送每条数据的时候，里面加一个全局唯一的 id，根据 ID 查询是否消费过了，如果已经处理，就忽视。</strong><br><strong>5、RabbitMQ 高可用性：</strong><br><strong>rabbitmq 有三种模式：单机模式，普通集群模式，镜像集群模式。单击模式，一个节点。普通集群，</strong>多台机器上启动多个 rabbitmq 实例，每个机器启动一个。但是你创建的 queue，只会放在一个 rabbtimq 实例上，但是每个实例都同步 queue 的元数据。实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。没做到所谓的分布式。<strong>镜像集群模式: 你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，然后每次你写消息到 queue 的时候，都会自动把消息到多个实例的 queue 里进行消息同步。一，这个性能开销也太大了吧，消息同步所有机器，导致网络带宽压力和消耗很重！第二，这么玩儿，就没有扩展性可言了。</strong><br>Spring Bean Scope 说下。Spring 的注入方式有几种，为什么推荐用构造器注入？<a href="/Resource">@Resource </a> 和 <a href="/Autowired">@Autowired </a> 区别说下。什么是 IoC 和 AOP？Spring 解决了什么？<a href="/Bean">@Bean </a> 和 @Component 区别说下。Spring Bean 的生命周期说下。Spring AOP 原理，各种 Advice 和 Advisor 说下。AOP 的两种代理方式是什么？AOP 一般作用说下。三级缓存解决循环依赖的过程说下。Spring 的事务传播行为说下。Spring 事务隔离级别说下。Spring 事务实现原理。Spring 用到了哪些设计模式，能分别讲讲它是如何实现的吗，具体是哪些类？BeanFactory 和 ApplicationContext 说下区别。说下 BeanFactory 和 FactoryBean 区别？BeanPostProcessor 和 BeanFactoryPostProcessor 区别是什么？Spring 事件知道吗？Spring 如何自定义 xml 解析？各种 Smart 开头的 Bean 的前置处理器，什么时候被调用，你知道吗？Spring Cache 是如何实现的？Spring Data JPA 呢？ 注解扫描如何实现的，你能手写个吗？写过 Spring 的插件吗？如何实现的？代码开源了吗？</p>
<p>Spring MVC 执行流程说下。<a href="/RestController">@RestController </a> 和 <a href="/Controller">@Controller </a> 区别说下。怎么取得 URL 中的 { } 里面的变量？Spring MVC 和 Struts2 比有什么优点？Spring MVC 怎么样设定重定向和转发的？说下 Spring MVC 的常用注解。如何解决 POST 请求中文乱码问题，GET 的又如何处理呢？Interceptor 和 Filter 区别？Spring MVC 的异常处理 ？怎样在方法里面得到 Request，或者 Session？Spring MVC 中函数的返回值是什么？怎么样把 ModelMap 里面的数据放入 Session 里面？Spring MVC 的控制器是不是单例模式,如果是,有什么问题,怎么解决？Spring MVC 的 RequestMapping 的方法是线程安全的吗？为什么？介绍下 WebApplicationContext。跨域问题如何解决？如何解决全局异常？validation 有了解吗？用过吗？Json 处理如何实现的？哦，你刚才说了父子容器，能讲讲什么是父子容器吗？Spring MVC 国际化有了解过吗？怎么实现的</p>
<p>Spring Boot 是如何实现自动装配的？运行 Spring Boot 有几种方式？Spring Boot Starter 工作原理。Spring Boot 核心注解说下。<a href="/Enable">@Enable </a> 类型注解是如何实现的？<a href="/Conditional">@Conditional </a> 类型注解呢？自定义过吗？说下异步调用@Async。什么是 YAML？Spring Boot Profiles 如何实现的？ bootstrap.properties 和 application.properties 说下区别。Spring Boot 事件和 Spring 事件有什么关系？Spring Boot Actuator 了解过吗？说一下。Spring Batcher 用过吗，说下。Spring Boot 是如何实现内嵌 Servlet 容器的，在哪行代码启动的？Spring Boot 完美实现了模块化编程，你认同吗？</p>
<p><strong>Spring Boot 的核心注解是哪个：</strong><br><strong>@SpringBootApplication，他包含了三个注解：</strong><br>@SpringBootConfiguration：组合了 @Configuration<br>注解，实现配置文件的功能。<br>从 Spring3.0，@Configuration 用于定义配置类，可替换 xml 配置文件，被注解的类内部包含有一个或多个被@Bean 注解的方法，这些方法将会被 AnnotationConfigApplicationContext 或 AnnotationConfigWebApplicationContext 类进行扫描，并用于构建 bean 定义，初始化 Spring 容器。<br>*<em>@SpringBootConfiguration<br>也是来源于**@Configuration，二者功能都是将当前类标注为配置类，并将当前类里以 @Bean 注解标记的方法的实例注入到 srping 容器中，实例名即为方法名。**<br>@ComponentScan：Spring 组件扫描。<br><strong>用于将一些标注了特定注解的 bean 定义批量采集注册到 Spring 的 IoC 容器之中，这些特定的注解大致包括：@Controller@Entity@Component@Service@Repository</strong><br>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项。<br>**@EnableAutoConfiguration<br>注解启用自动配置，其可以帮助 SpringBoot 应用将所有符合条件的 @Configuration 配置都加载到当前 IoC 容器之中，\</em>*<br><strong>6、开启 Spring Boot 特性有哪几种方式？</strong><br><strong>1）继承 spring-boot-starter-parent 项目 2）导入 spring-boot-dependencies 项目依赖</strong><br><strong>SpringBoot 内置 Tomcat/Jetty 容器，可以独立运行。</strong><br><strong>8、运行 Spring Boot 有哪几种方式？</strong><br><strong>1）打包用命令或者放到容器中运行</strong><br><strong>3）直接执行 main 方法运行</strong><br>2）用 Maven/ Gradle 插件运行<br><strong>Spring Boot 自动配置原理是什么？</strong><br><strong>扫描所有具有 META-INF/spring.factories 的 jar 包。spring-boot-autoconfigure-x.x.x.x.jar 里就有一个这样的 spring.factories 文件。</strong><br><strong>这个 spring.factories 文件也是一组一组的 key=value 的形式，其中一个 key 是 EnableAutoConfiguration 类的全类名，而它的 value 是一个 xxxxAutoConfiguration 的类名的列表，这些类名以逗号分隔。</strong><br><strong>这个@EnableAutoConfiguration 注解通过@SpringBootApplication 被间接的标记在了 Spring Boot 的启动类上。在 SpringApplication.run(…)的内部就会执行 selectImports()方法，找到所有 JavaConfig 自动配置类的全限定名对应的 class，然后将所有自动配置类加载到 Spring 容器中。</strong><br><strong>Spring<br>Boot 启动的时候会通过@EnableAutoConfiguration 注解找到 META-INF/spring.factories 配置文件中的所有自动配置类，并对其进行加载，而这些自动配置类都是以 AutoConfiguration 结尾来命名的，它实际上就是一个 JavaConfig 形式的 Spring 容器配置类，它能通过以 Properties 结尾命名的类中取得在全局配置文件中配置的属性如：server.port，而 XxxxProperties 类是通过@ConfigurationProperties 注解与全局配置文件中对应的属性进行绑定的。</strong><br><strong>Starters</strong><br>Starters 可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成 Spring 及其他技术，而不需要到处找示例代码和依赖包。Starters 包含了许多项目中需要用到的依赖，它们能快速持续的运行，都是一系列得到支持的管理传递性依赖。</p>
<p>Spring Cloud Netflix 听说你了解。画一下 Spring Cloud Netflix 架构图。说说 Eureka 默认多少秒发送心跳？增量还是全量？CP 还是 AP？如何防止脑裂的？二级缓存知道吗？Eureaka 的自我保护模式说下。ServiceInstance 和 DiscoryClient 知道吗？是干嘛的？分布式事务除了两段提交，还有什么实现方式？哦，你说 Saga，Saga 你说下是什么？Ribbon 是什么说一下，它解决了什么问题？Feign 又是什么？它和 Ribbon 什么关系？Dubbo 和 Feign 区别？Dubbo 的 SPI 知道吗？Zuul 是什么？它和 Nginx 有什么区别？除了 Zuul 还有什么网关可选？Hystrix 是什么？它是如何实现的？熔断、降级和限流他们的区别说一下。Hystrix 信号量机制，隔离策略细粒度控制如何做的？看过源码吗？你优化过吗？微服务十一点说一下分别是什么？分布式配置中心有哪些？你们用的 Apollo 还是 Spring Config 还是其他的？为什么？服务监控有了解吗？什么是幂等？如何实现接口幂等？如何实现分布式 Session？有更好的方法吗？哦，你说了 JWT，能详细说下吗？不同系统的间授权的 OAuth2 了解吗？</p>
<p>MyBatis 了解吗？一级缓存，二级缓存？# 和 $ 说下。如何实现的动态 SQL？ORM 是什么？和 Hibernate 区别？MyBatis 工作原理？MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？MyBatis 中如何指定使用哪一种 Executor 执行器？模糊查询 like 语句该怎么写？MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？MyBatis 如何执行批量操作？SqlSessionFactoryBean 是什么？如何实现和 Spring 的整合的？Mapper 方法可以重载吗？为什么不可以？MyBatis 是如何将 SQL 执行结果封装为目标对象并返回的？都有哪些映射形式？哦，你说简单封装了 JDBC，说下 JDBC 几个重要的类。为什么要预编译？有什么好处吗？</p>
<p>Nginx 了解吗，说下其优缺点？怎么实现 Nginx 集群？什么是反向代理？和正向代理区别是什么？Tomcat 和 Nginx 区别？限流怎么做的，有哪三种？令牌桶和漏斗算法是什么，区别是什么？如何在其之上使用 Lua 脚本？有几种负载均衡策略？你们生产上用的哪个？为什么？为什么 Nginx 性能这么高？有没有更高的？F5 又是什么？Nginx 是怎么处理请求的？Nginx 目录有哪些？nginx.conf 配置过吗？有哪些属性模块？静态资源放哪？虚拟主机配置？location 说下。location 语法说下。</p>
<p>Tomcat 你也了解？什么是 Tomcat 的 Connector？Service、Connector、Container 介绍下它们。详细说下它们是如何处理请求的，能画下它们的架构图吗？如何部署的？一定要放到 webapps 目录下吗？在哪配置？为什么不用 Jetty？区别是什么？Servlet 是线程安全的吗？为什么？怎样让它线程安全？Servlet 初始化过程？init 方法什么时候调用？Servlet 什么时候第一次初始化？JSP 知道吗？有几个内置对象？你说 JSP 是特殊的 Servlet，你看过源码吗？JSP 如何热部署的？EL 表达式知道吗？如何实现的？（大四某打车集团非滴滴校招的时候被问到的）</p>
<p>云原生了解吗？云原生十二要素说下。Cloud Foundry 平台你知道吗？HeroKu？Kong？</p>
<p>哦？你说是六边形架构？你说下什么是六边形架构？整洁架构呢？它们之间的区别？分层架构了解吗？MVP、MVC 架构说下。负载均衡算法七种说下。如何实现一个秒杀系统。一定不会超卖吗？如何解决？什么是 SOA？什么是微服务？以及两者的区别。什么是事件驱动架构？CAP 和 BASE 说下是什么？最终一致性和人弱一致性什么关系？画一下你们系统的整体架构图。QPS 和 TPS？你们的 QPS 是多少知道吗？压测过吗？说下点击网页的请求过程。哦，你说你是蓝绿部署，什么是蓝绿部署？什么是金丝雀发布？如何实现？</p>
<p>Docker 你也用？怎么构建 Docker 镜像？Docker 和虚拟机的区别？Docker 好处说下？Kubernetes 你也知道，说下它的组成结构？etcd 是什么？为什么不用 Zookeeper？pod 又是什么？你们生产上怎么用的？如何控制滚动更新过程？</p>
<p>你说你知道 DDD？能简单说下吗？你们代码落地了吗？是如何拆分服务的？事件风暴又是什么？你们有 Code Review 吗？具体规矩？领域事件是什么？子域、通用域、核心域、支撑域、限界上下文、聚合、聚合根、实体、值对象又是什么？你们有 EventBus 吗？如何使用的？</p>
<p>实际编程题</p>
<p>给二叉树后序和中序遍历，写前序遍历。手写个快排。翻转一下链表。O(1) 空间复杂度找出链表有环。DFS 找出二叉树搜索树第 k 大节点（这些都真的碰过了）。</p>
<p>实现一个多线程类，并用该线程类实例化 3 个线程 A,B,C；A 线程打印字符 A,B 线程打印字符 B，C 线程打印字符 C；启动这 3 个线程，要求启动线程的顺序为 C 线程-&gt;B 线程-&gt;A 线程，并且最后输出内容为：A B C。禁止使用 sleep 函数。</p>
<p>阿里应该还有各种多线程打印的问题，这个得准备。就是想拿个 6，太难了。这些只是最最最基础的内容。</p>
<p>接下来应该是更高级的算法题目，至少是 LeetCode Menium 难度的，翻转链表确实有点初级，练个半个小时就搞定了。暂时还没碰到，碰到我也挂了。应该是动态规划，滑动窗口，字符串的问题，手写 O(1) 时间复杂度的 LRU，回溯，贪心。</p>
<p>还有一种就是，你们目前技术的缺点是什么？如何优化？有没有更好的优化方案？换作是你，你会怎么做（滴滴面试，不按八股文套路来）？业务量突然增长几十倍，你怎么做？如何架构演进？你有架构设计过吗？你带过新人吗？怎么做的？</p>
<p>UML 类图？时序图？流程图？泳道图？甘特图？你用的什么工具？</p>
<p>你平时是怎么学习一门新技术的？</p>
<p>最近有看书吗？看的什么书？技术类的，能和我讲讲吗？</p>
<p>你为什么离职？（回答工资问题，领导不好的都会挂）下一家公司的期望是什么？期望薪资？你的职业发展规划？你为什么要这个数字的工资？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luckzp.github.io/2020/12/28/%E9%97%AE%E7%AD%94%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangPeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/28/%E9%97%AE%E7%AD%94%E5%BD%95/" class="post-title-link" itemprop="url">问答录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-28 15:07:55" itemprop="dateCreated datePublished" datetime="2020-12-28T15:07:55+00:00">2020-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 02:12:39" itemprop="dateModified" datetime="2021-06-14T02:12:39+00:00">2021-06-14</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-users"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="firestore-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>性价比高并仅仅指的是价格便宜的，相反价格贵也可以是性价比高。比如 4,5K 的 iphone 和 1,2K 的安卓手机。</li>
<li>价格便宜并不能成为护城河，降低价格是一个企业的核武器，最好不要用。</li>
</ul>
<p>仓位管理<br>仓位越重，对情绪也影响也越大。<br>投资 60%的现金总资产（注意是现金，不包括房贷，车贷），就算亏完了，也不影响生活。<br>入手基金分为 3 份，一份做持股资金，一份做波段备用金，一份做应急救援金（出现黑天鹅的情况）。</p>
<p>沉没成本<br>放弃可以规避历史成本的干扰，重新展开思考：假如我现在空仓，我会愿意现价买入这只股票吗？</p>
<p>伴随着财富的增加，人的各种劣根性也会显现：骄奢淫逸、心浮气躁、狂妄自大。<br>学习的过程是让内心平静，保持正直、真诚、勤奋、节俭、谦卑、善待身边人这些好的品格常驻心间。</p>
<p>介意别人比你赚钱更快，是一种不可饶恕的罪行。嫉妒是种愚蠢的行为，它是你唯一不可能从中得到任何乐趣的心理活动。它只会带来很多痛苦，毫无乐趣可言，为什么要去那么干呢？——查理.芒格</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luckzp.github.io/2020/09/16/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9B%B8%E4%BA%92%E6%B1%82%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangPeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/16/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9B%B8%E4%BA%92%E6%B1%82%E6%B3%95/" class="post-title-link" itemprop="url">二叉树前序、中序、后序遍历相互求法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-16 13:10:04" itemprop="dateCreated datePublished" datetime="2020-09-16T13:10:04+00:00">2020-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 02:12:39" itemprop="dateModified" datetime="2021-06-14T02:12:39+00:00">2021-06-14</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-users"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="firestore-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前序遍历:         GDAFEMHZ</p>
<p>中序遍历:         ADEFGHMZ</p>
<p><strong>画树求法：</strong>第一步，根据前序遍历的特点，我们知道根结点为 G</p>
<p>第二步，观察中序遍历 ADEFGHMZ。其中 root 节点 G 左侧的 ADEF 必然是 root 的左子树，G 右侧的 HMZ 必然是 root 的右子树。</p>
<p>第三步，观察左子树 ADEF，左子树的中的根节点必然是大树的 root 的 leftchild。在前序遍历中，大树的 root 的 leftchild 位于 root 之后，所以左子树的根节点为 D。</p>
<p>第四步，同样的道理，root 的右子树节点 HMZ 中的根节点也可以通过前序遍历求得。在前序遍历中，一定是先把 root 和 root 的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。</p>
<p>第五步，观察发现，上面的过程是递归的。先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了。该步递归的过程可以简洁表达如下：</p>
<p>1 确定根,确定左子树，确定右子树。</p>
<p>2 在左子树中递归。</p>
<p>3 在右子树中递归。</p>
<p>4 打印当前根。</p>
<p>那么，我们可以画出这个二叉树的形状：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/431489/1600261869483-93bca541-229c-46ae-b4dc-39d5df9a177f.jpeg#align=left&display=inline&height=231&margin=%5Bobject%20Object%5D&originHeight=231&originWidth=266&size=0&status=done&style=none&width=266"></p>
<p>那么，根据后序的遍历规则，我们可以知道，后序遍历顺序为：AEFDHZMG.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luckzp.github.io/2020/09/16/AVL%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangPeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/16/AVL%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91/" class="post-title-link" itemprop="url">AVL和红黑树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-16 02:10:52" itemprop="dateCreated datePublished" datetime="2020-09-16T02:10:52+00:00">2020-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 02:12:39" itemprop="dateModified" datetime="2021-06-14T02:12:39+00:00">2021-06-14</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-users"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="firestore-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="AVL-平衡二叉搜索树"><a href="#AVL-平衡二叉搜索树" class="headerlink" title="AVL 平衡二叉搜索树"></a><strong>AVL 平衡二叉搜索树</strong></h4><p>定义：平衡二叉树或为空树,或为如下性质的二叉排序树:<br>（1）左右子树深度之差的绝对值不超过 1;<br>（2）左右子树仍然为平衡二叉树.<br>平衡因子 BF=左子树深度－右子树深度.<br>平衡二叉树每个结点的平衡因子只能是 1，0，-1。若其绝对值超过 1，则该二叉排序树就是不平衡的。<br>如图所示为平衡树和非平衡树示意图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/431489/1600222307926-7e1b3089-1a7c-4369-b0ad-dafc0ce0593f.png#align=left&display=inline&height=270&margin=%5Bobject%20Object%5D&originHeight=270&originWidth=573&size=0&status=done&style=none&width=573"></p>
<h4 id="RBT-红黑树"><a href="#RBT-红黑树" class="headerlink" title="RBT 红黑树"></a><strong>RBT 红黑树</strong></h4><p><strong>AVL 是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；</strong><br><strong>红黑是弱平衡的，用非严格的平衡来换取增删节点时候旋转次数的降低；</strong><br><strong>所以简单说，搜索的次数远远大于插入和删除，那么选择 AVL 树，如果搜索，插入删除次数几乎差不多，应该选择 RB 树。</strong></p>
<p>红黑树上每个结点内含五个域，color，key，left，right，p。如果相应的指针域没有，则设为 NIL。<br>一般的，红黑树，满足以下性质，即只有满足以下全部性质的树，我们才称之为红黑树：<br>1）每个结点要么是红的，要么是黑的。<br>2）根结点是黑的。<br>3）每个叶结点，即空结点（NIL）是黑的。<br>4）如果一个结点是红的，那么它的俩个儿子都是黑的。<br>5）对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。<br>下图所示，即是一颗红黑树：</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luckzp.github.io/2020/09/12/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangPeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/12/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">自我提升总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-12 04:20:24" itemprop="dateCreated datePublished" datetime="2020-09-12T04:20:24+00:00">2020-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 02:12:39" itemprop="dateModified" datetime="2021-06-14T02:12:39+00:00">2021-06-14</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-users"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="firestore-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<p>说明：文章是基于结构性思维写出的，下图将文章进行高度概括，详细内容可见全文（选择性阅读即可）。</p>
<p><img src="http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1at98fsj21dy096dga.jpg#align=left&display=inline&height=330&margin=%5Bobject%20Object%5D&originHeight=330&originWidth=1798&status=done&style=none&width=1798"></p>
<h4 id="序言"><a href="#序言" class="headerlink" title="序言"></a><strong>序言</strong></h4><p>随着公司的规模的扩大，应届生的数量也逐渐增长。然而，从学校刚进入公司的我们，难免会有多多少少的不适应。我们如何能尽快的适应职场环境和更好的成长了？上个星期，公司特与智联教育学院合作，为我们制定了为期 5 天的培训课程，取得了非常好的效果。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/09/12/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87%E6%80%BB%E7%BB%93/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luckzp.github.io/2020/09/12/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%EF%BC%88DDD%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangPeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/12/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%EF%BC%88DDD%EF%BC%89/" class="post-title-link" itemprop="url">领域驱动设计（DDD）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-12 04:20:09" itemprop="dateCreated datePublished" datetime="2020-09-12T04:20:09+00:00">2020-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 02:12:39" itemprop="dateModified" datetime="2021-06-14T02:12:39+00:00">2021-06-14</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-users"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="firestore-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-名词解释"><a href="#1-名词解释" class="headerlink" title="1. 名词解释"></a>1. 名词解释</h3><ul>
<li><p>领域：将业务根据不同范围细分，当细分到一定的程度后，不同业务会有不同范围，<br>在这个范围内解决业务问题就是领域。</p>
</li>
<li><p>实体：就是业务对象，具有业务行为，业务逻辑和唯一 ID。实体类通常采用充血模型，包含了实体的属性和实体相关的所有业务逻辑方法，跨多个实体的领域逻辑则在领域服务中实现。</p>
</li>
<li><p>值对象：是若干个属性的集合，没有 ID，不包含业务逻辑，可以被其他实体共享，采用贫血模型。<strong>实体和值对象是微服务底层的最基础的对象，一起实现实体最基本的核心领域逻辑。</strong>&gt; 传统的数据建模是根据数据库范式设计的，每一个数据库表对应一个实体，每一个实体的属性值用单独<br>的一列来存储，一个实体主表会对应 N 个实体从表。值对象在数据库持久化做了简化了设计，它的数据库<br>设计大多采用非数据库范式，值对象的属性值和实体对象的属性值可以保存在不同表中。</p>
</li>
<li><p>聚合：是由业务和逻辑紧密关联的实体和值对象组合的，聚合是数据修改和持久化的<br>基本单元，每一个聚合对应一个仓储，实现数据的持久化。</p>
</li>
<li><p>聚合根：是实体，有实体的特点，具有全局唯一标识，是聚合的入口，聚合根与聚合根之间通<br>过 ID 关联的方式实现聚合之间的协同。</p>
</li>
<li><p>领域事件（Domain Event）：这种事件发生后通常会导致进一步的业务操作。</p>
</li>
</ul>
<h3 id="2-分层"><a href="#2-分层" class="headerlink" title="2. 分层"></a>2. 分层</h3><ul>
<li>用户接口层：面向前端提供服务适配，面向资源层提供资源适配。这一层聚集了接口适配相关的功能。</li>
<li>应用层：实现服务组合和编排，适应业务流程快速变化的需求。这一层聚集了应用服务和事件相关的<br>功能。</li>
<li>领域层：实现领域的核心业务逻辑。这一层聚集了领域模型的聚合、聚合根、实体、值对象、领域服务和<br>事件等领域对象，以及它们组合所形成的业务能力。</li>
<li>基础层：贯穿所有层，为各层提供基础资源服务。这一层聚集了各种底层资源相关的服务和能力。</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/aacc02d8ly1gbjk949oskj20qg0nfgqp.jpg#align=left&display=inline&height=843&margin=%5Bobject%20Object%5D&originHeight=843&originWidth=952&status=done&style=none&width=952"></p>
<p><img src="http://ww1.sinaimg.cn/large/aacc02d8ly1gbjkbj1kmtj20r20jtafu.jpg#align=left&display=inline&height=713&margin=%5Bobject%20Object%5D&originHeight=713&originWidth=974&status=done&style=none&width=974"></p>
<p><img src="http://ww1.sinaimg.cn/large/aacc02d8ly1gbjkbndlalj20db0jc74p.jpg#alt=%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luckzp.github.io/2020/09/12/%E5%BF%AB%E6%8E%92%E9%87%8C%E7%9A%84Partition%E5%BA%94%E7%94%A8-%E6%89%BE%E7%AC%ACK%E5%A4%A7%E7%9A%84%E6%95%B0%E5%AD%97%20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangPeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/12/%E5%BF%AB%E6%8E%92%E9%87%8C%E7%9A%84Partition%E5%BA%94%E7%94%A8-%E6%89%BE%E7%AC%ACK%E5%A4%A7%E7%9A%84%E6%95%B0%E5%AD%97%20/" class="post-title-link" itemprop="url">快排里的Partition应用-找第K大的数字</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-12 04:20:04" itemprop="dateCreated datePublished" datetime="2020-09-12T04:20:04+00:00">2020-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 02:12:39" itemprop="dateModified" datetime="2021-06-14T02:12:39+00:00">2021-06-14</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-users"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="firestore-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>tags:[刷题]</p>
<hr>
<h3 id="Partition-算法"><a href="#Partition-算法" class="headerlink" title="Partition 算法"></a>Partition 算法</h3><p>参考自：<a target="_blank" rel="noopener" href="http://blog.csdn.net/morewindows/article/details/6684558">白话经典算法系列之六 快速排序 快速搞定</a></p>
<h3 id="挖数填坑："><a href="#挖数填坑：" class="headerlink" title="挖数填坑："></a>挖数填坑：</h3><p><img src="http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1fmnsi4j20tv0kj45z.jpg#align=left&display=inline&height=739&margin=%5Bobject%20Object%5D&originHeight=739&originWidth=1075&status=done&style=none&width=1075"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将当期的第low个元素设置为枢轴值，对数组进行划分</span></span><br><span class="line">    <span class="keyword">int</span> x = nums[low];</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = high;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j&amp;&amp;nums[j]&lt;=x)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="comment">// 将比枢轴值大的元素移动到左端</span></span><br><span class="line">        nums[i]=nums[j];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j&amp;&amp;nums[i]&gt;=x)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="comment">// 将比枢轴值小的元素移动到右端</span></span><br><span class="line">        nums[j]=nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 枢轴存放到的最终位置</span></span><br><span class="line">    nums[i]=x;</span><br><span class="line">    <span class="comment">// 返回枢轴存放到的最终位置</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对算法最好的理解就是手动模拟一遍算法。</p>
<h3 id="FindKthNumber"><a href="#FindKthNumber" class="headerlink" title="FindKthNumber"></a>FindKthNumber</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>, end = nums.size();</span><br><span class="line">    <span class="keyword">int</span> target_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt;= end)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = partition(nums, begin, end);</span><br><span class="line">        <span class="keyword">if</span>(pos == k<span class="number">-1</span>)&#123;</span><br><span class="line">            target_num = nums[pos];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pos &gt; k<span class="number">-1</span>)&#123;</span><br><span class="line">            end = pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            begin = pos + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = nums[low];</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = high<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span>(i&lt;j&amp;&amp;nums[j]&lt;=x)</span><br><span class="line">        j--;</span><br><span class="line">      <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">        nums[i]=nums[j];</span><br><span class="line">      <span class="keyword">while</span>(i&lt;j&amp;&amp;nums[i]&gt;=x)</span><br><span class="line">        i++;</span><br><span class="line">      <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">        nums[j]=nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[i]=x;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>, end = nums.size();</span><br><span class="line">    <span class="keyword">int</span> target_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt;= end)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = partition(nums, begin, end);</span><br><span class="line">        <span class="keyword">if</span>(pos == k<span class="number">-1</span>)&#123;</span><br><span class="line">            target_num = nums[pos];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pos &gt; k<span class="number">-1</span>)&#123;</span><br><span class="line">            end = pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            begin = pos + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums=&#123;<span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, findKthLargest(nums, <span class="number">2</span>));</span><br><span class="line">  getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/">例题：Kth Largest Element in an Array</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhang Peng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Peng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        




  <script src="https://www.gstatic.com/firebasejs/6.3.3/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/6.3.3/firebase-firestore.js"></script>
  <script>
    firebase.initializeApp({
      apiKey   : 'AIzaSyAOxPsO3R2S_FEcgmCicMAdmH2WL4dcqQw',
      projectId: 'flash-spark-160014'
    });

    function getCount(doc, increaseCount) {
      // IncreaseCount will be false when not in article page
      return doc.get().then(d => {
        var count = 0;
        if (!d.exists) { // Has no data, initialize count
          if (increaseCount) {
            doc.set({
              count: 1
            });
            count = 1;
          }
        } else { // Has data
          count = d.data().count;
          if (increaseCount) {
            // If first view this article
            doc.set({ // Increase count
              count: count + 1
            });
            count++;
          }
        }

        return count;
      });
    }

    function appendCountTo(el) {
      return count => {
        el.innerText = count;
      }
    }
  </script>
  <script>
    (function() {
      var db = firebase.firestore();
      var articles = db.collection('articles');

      if (CONFIG.page.isPost) { // Is article page
        var title = document.querySelector('.post-title').innerText.trim();
        var doc = articles.doc(title);
        var increaseCount = CONFIG.hostname === location.hostname;
        if (localStorage.getItem(title)) {
          increaseCount = false;
        } else {
          // Mark as visited
          localStorage.setItem(title, true);
        }
        getCount(doc, increaseCount).then(appendCountTo(document.querySelector('.firestore-visitors-count')));
      } else if (CONFIG.page.isHome) { // Is index page
        var promises = [...document.querySelectorAll('.post-title')].map(element => {
          var title = element.innerText.trim();
          var doc = articles.doc(title);
          return getCount(doc);
        });
        Promise.all(promises).then(counts => {
          var metas = document.querySelectorAll('.firestore-visitors-count');
          counts.forEach((val, idx) => {
            appendCountTo(metas[idx])(val);
          });
        });
      }
    })();
  </script>




      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
