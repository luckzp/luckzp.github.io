<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta name="referrer" content="no-referrer" />
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"luckzp.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ZhangPeng">
<meta property="og:url" content="https://luckzp.github.io/page/2/index.html">
<meta property="og:site_name" content="ZhangPeng">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhang Peng">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://luckzp.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ZhangPeng</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ZhangPeng</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">To be what you want to be</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luckzp.github.io/2020/09/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangPeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">计算机网络基础概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-12 04:19:59" itemprop="dateCreated datePublished" datetime="2020-09-12T04:19:59+00:00">2020-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 02:12:39" itemprop="dateModified" datetime="2021-06-14T02:12:39+00:00">2021-06-14</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-users"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="firestore-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-OSI-和-TCP-IP-的体系结构，以及各层协议"><a href="#1-OSI-和-TCP-IP-的体系结构，以及各层协议" class="headerlink" title="1.OSI 和 TCP/IP 的体系结构，以及各层协议"></a>1.OSI 和 TCP/IP 的体系结构，以及各层协议</h3><p>OSI 分层 （7 层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br>TCP/IP 分层（4 层）：数据链路层、 传输层、网络层、 应用层。</p>
<p>分层的好处：</p>
<ul>
<li>各层之间的接口部分规划好之后，每个层次内部的设计就能自由改动了。</li>
<li>设计变得相对简单，每一层只考虑自己的分配任务。</li>
</ul>
<p>每一层的协议如下：<br>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）<br>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）<br>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）<br>传输层：TCP、UDP、SPX<br>会话层：NFS、SQL、NETBIOS、RPC<br>表示层：JPEG、MPEG、ASII<br>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS<br>每一层的作用如下：<br>物理层：通过媒介传输比特,确定机械及电气规范（比特 Bit）<br>数据链路层：将比特组装成帧和点到点的传递（帧 Frame）<br>网络层：负责数据包从源到宿的传递和网际互连（包 PackeT）<br>传输层：提供端到端的可靠报文传递和错误恢复（段 Segment）<br>会话层：建立、管理和终止会话（会话协议数据单元 SPDU）<br>表示层：对数据进行翻译、加密和压缩（表示协议数据单元 PPDU）<br>应用层：允许访问 OSI 环境的手段（应用协议数据单元 APDU）</p>
<h3 id="2-TCP-的三次握手与四次分手"><a href="#2-TCP-的三次握手与四次分手" class="headerlink" title="2.TCP 的三次握手与四次分手"></a>2.TCP 的三次握手与四次分手</h3><h4 id="摘自于http-www-jellythink-com-archives-705"><a href="#摘自于http-www-jellythink-com-archives-705" class="headerlink" title="摘自于http://www.jellythink.com/archives/705"></a>摘自于<a target="_blank" rel="noopener" href="http://www.jellythink.com/archives/705">http://www.jellythink.com/archives/705</a></h4><h4 id="三次握手是什么？"><a href="#三次握手是什么？" class="headerlink" title="三次握手是什么？"></a>三次握手是什么？</h4><p>TCP 是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在 TCP/IP 协议中，TCP 协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。这就是面试中经常会被问到的<strong>TCP 三次握手</strong>。只是了解 TCP 三次握手的概念，对你获得一份工作是没有任何帮助的，你需要去了解 TCP 三次握手中的一些细节。先来看图说话。</p>
<p><img src="http://ww1.sinaimg.cn/large/aacc02d8gy1gce7qfxhnzj20lt0c2jyk.jpg#align=left&display=inline&height=434&margin=%5Bobject%20Object%5D&originHeight=434&originWidth=785&status=done&style=none&width=785"></p>
<p>多么清晰的一张图，当然了，也不是我画的，我也只是引用过来说明问题了。</p>
<ol>
<li>第一次握手：建立连接。客户端发送连接请求报文段，将<code>SYN</code>位置为 1，<code>Sequence Number</code>为 x；然后，客户端进入<code>SYN_SEND</code>状态，等待服务器的确认；</li>
<li>第二次握手：服务器收到<code>SYN</code>报文段。服务器收到客户端的<code>SYN</code>报文段，需要对这个<code>SYN</code>报文段进行确 认，设置<code>Acknowledgment Number</code>为 x+1(<code>Sequence Number</code>+1)；同时，自己自己还要发送<code>SYN</code>请求信息，将<code>SYN</code>位置为 1，<code>Sequence Number</code>为 y；服务器端将上述所有信息放到一个报文段（即<code>SYN+ACK</code>报文段）中，一并发送给客户端，此时服务器进入<code>SYN_RECV</code>状态；</li>
<li>第三次握手：客户端收到服务器的<code>SYN+ACK</code>报文段。然后将<code>Acknowledgment Number</code>设置为 y+1，向服务器发送<code>ACK</code>报文段，这个报文段发送完毕以后，客户端和服务器端都进入<code>ESTABLISHED</code>状态，完成 TCP 三次握手。</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/aacc02d8gy1gdajkp4qdxj21hc0t4why.jpg#align=left&display=inline&height=1048&margin=%5Bobject%20Object%5D&originHeight=1048&originWidth=1920&status=done&style=none&width=1920"></p>
<p>完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是 TCP 三次握手的总体介绍。</p>
<p><strong>为了加深理解，举个例子。</strong></p>
<p><strong>A 和 B 之间建立了 TCP 连接，A 向 B 发送报文段，其中序号字段 seq=300，确认号字段 ACK =101，数据部分包含 7 个字节，那么在 B 对该报文的确认报文段中（）。</strong></p>
<p><strong>A. seq=301, ACK=101  B. seq=301, ACK=108  C.seq=101, ACK =107  D .seq=101, ACK= 307</strong></p>
<p><strong>解析：</strong></p>
<p>A 向 B 发送报文段，其中序号字段 seq=300，确认号字段 ACK =101。</p>
<p>A 对 B 说：“我已经收到你第 100 个序列号了，下个序列号要从 101 开始。我现在给你要以 300 序列号开始，给 7 个字节数据。“</p>
<p>B 这时应该对 A 说：”好的，我这就给你发送 101 的序列号，我这里收到了以 300 为起点，306 为终点的数据了，我现在要 307 序列号了。“</p>
<p>所以 B 对该报文的确认报文段中 seq=101, ACK= 307. 选 D.</p>
<h4 id="那四次分手呢？"><a href="#那四次分手呢？" class="headerlink" title="那四次分手呢？"></a>那四次分手呢？</h4><p>当客户端和服务器通过三次握手建立了 TCP 连接以后，当数据传送完毕，肯定是要断开 TCP 连接的啊。那对于 TCP 的断开连接，这里就有了神秘的“四次分手”。</p>
<p><img src="http://ww1.sinaimg.cn/large/aacc02d8gy1gce9y14bkgj20uy0i9n5x.jpg#align=left&display=inline&height=657&margin=%5Bobject%20Object%5D&originHeight=657&originWidth=1114&status=done&style=none&width=1114"></p>
<ol>
<li>第一次分手：主机 1（可以使客户端，也可以是服务器端），设置<code>Sequence Number</code>和<code>Acknowledgment Number</code>，向主机 2 发送一个<code>FIN</code>报文段；此时，主机 1 进入<code>FIN_WAIT_1</code>状态；这表示主机 1 没有数据要发送给主机 2 了；</li>
<li>第二次分手：主机 2 收到了主机 1 发送的<code>FIN</code>报文段，向主机 1 回一个<code>ACK</code>报文段，<code>Acknowledgment Number</code>为<code>Sequence Number</code>加 1；主机 1 进入<code>FIN_WAIT_2</code>状态；主机 2 告诉主机 1，我“同意”你的关闭请求；</li>
<li>第三次分手：主机 2 向主机 1 发送<code>FIN</code>报文段，请求关闭连接，同时主机 2 进入<code>LAST_ACK</code>状态；</li>
<li>第四次分手：主机 1 收到主机 2 发送的<code>FIN</code>报文段，向主机 2 发送<code>ACK</code>报文段，然后主机 1 进入<code>TIME_WAIT</code>状态；主机 2 收到主机 1 的<code>ACK</code>报文段以后，就关闭连接；此时，主机 1 等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，主机 1 也可以关闭连接了。</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/aacc02d8gy1gdajm38dtdj21hc0t4gpa.jpg#align=left&display=inline&height=1048&margin=%5Bobject%20Object%5D&originHeight=1048&originWidth=1920&status=done&style=none&width=1920"></p>
<p><strong>等待 2MSL 才 CLOSED 的原因是：</strong></p>
<ul>
<li>要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。</li>
<li>使已失效的连接请求报文段消失。</li>
</ul>
<p><strong>为什么连接的时候是三次握手，关闭的时候却是四次握手？</strong></p>
<p>因为当 Server 端收到 Client 端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当 Server 端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉 Client 端，”你发的 FIN 报文我收到了”。只有等到我 Server 端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四步握手。</p>
<h3 id="3-子网划分"><a href="#3-子网划分" class="headerlink" title="3.子网划分"></a>3.子网划分</h3><h4 id="现有两个-C-类网，202-203-204-0-，把它平均分成-4-个子网，写出每个子网的起始、终结-IP-和子网掩码。"><a href="#现有两个-C-类网，202-203-204-0-，把它平均分成-4-个子网，写出每个子网的起始、终结-IP-和子网掩码。" class="headerlink" title="现有两个 C 类网，202.203.204.0 ，把它平均分成 4 个子网，写出每个子网的起始、终结 IP 和子网掩码。"></a>现有两个 C 类网，202.203.204.0 ，把它平均分成 4 个子网，写出每个子网的起始、终结 IP 和子网掩码。</h4><p>202.203.204.0 分成 4 个平均的子网，这是个 C 类的网络 ，平均分成 4 个的话，也就是每个子网有 64 台机器。<br>2 的 2 次方=4 ，所以需要借 2 个主机位表示 网络 ，等于是 26 位的子网掩码.<br>子网掩码: 202.203.204.192<br>子网号 <strong>00</strong> 202.203.204.1 ~ 202.203.204.63<br>子网号 <strong>01</strong> 202.203.204.64 ~ 202.203.204.127<br>子网号 <strong>10</strong> 202.203.204.128 ~ 202.203.204.191<br>子网号 <strong>11</strong> 202.203.204.192 ~ 202.203.204.254</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luckzp.github.io/2020/09/12/%E6%B3%9B%E5%9E%8B%E7%B1%BB%E4%B8%8E%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangPeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/12/%E6%B3%9B%E5%9E%8B%E7%B1%BB%E4%B8%8E%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">泛型类与泛型方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-12 04:19:54" itemprop="dateCreated datePublished" datetime="2020-09-12T04:19:54+00:00">2020-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 02:12:39" itemprop="dateModified" datetime="2021-06-14T02:12:39+00:00">2021-06-14</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-users"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="firestore-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-泛型类"><a href="#1-泛型类" class="headerlink" title="1 泛型类"></a>1 泛型类</h3><p>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。<br>设计这个类的时候，在类的声明上，加上一个，表示该类支持泛型。 T 是 type 的缩写，也可以使用任何其他的合法的变量，比如 A,B,X 都可以，但是一般约定成俗使用 T，代表类型。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/09/12/%E6%B3%9B%E5%9E%8B%E7%B1%BB%E4%B8%8E%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luckzp.github.io/2020/09/12/%E5%8D%95%E4%BD%93%E5%88%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangPeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/12/%E5%8D%95%E4%BD%93%E5%88%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="post-title-link" itemprop="url">单体到微服务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-12 04:19:49" itemprop="dateCreated datePublished" datetime="2020-09-12T04:19:49+00:00">2020-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 02:12:39" itemprop="dateModified" datetime="2021-06-14T02:12:39+00:00">2021-06-14</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-users"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="firestore-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近读了《大型网站系统与 Java 中间件实践》，书 14 年的，老了点。后面的感觉没啥可看的，就讲讲学到的。<br>从单体项目转向分布式的项目，所要解决的问题和 Spring Cloud 组件相对应。</p>
<h3 id="1-服务之间网络通信问题"><a href="#1-服务之间网络通信问题" class="headerlink" title="1.服务之间网络通信问题"></a>1.服务之间网络通信问题</h3><p>在原来的单体项目中，只需要调不同的方法就能完成业务不同的操作。到了分布式中，根据业务的不同会拆分成不同的服务，A 服务依赖于 B 服务。这时候涉及 A 服务与 B 服务的网络通信问题（如下图）。</p>
<p><img src="http://ww1.sinaimg.cn/mw690/aacc02d8gy1gat1dnzjgpj20fv0ba0t0.jpg#align=left&display=inline&height=406&margin=%5Bobject%20Object%5D&originHeight=406&originWidth=571&status=done&style=none&width=571"></p>
<p>在 Spring Cloud 是靠着 Feign,Ribbon, Eureka 注册中心得以实现。</p>
<p><strong>Eureka</strong>：各个服务启动时，Eureka Client 都会将服务注册到 Eureka Server，并且 Eureka Client 还可以反过来从 Eureka Server 拉取注册表，从而知道其他服务在哪里。Eureka Serve 里面有一个注册表，保存了各服务所在的机器和端口号。</p>
<p><strong>Ribbon</strong>：首先 Ribbon 会从 Eureka Client 里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口号。Ribbon 使用负载均衡算法（默认使用的最经典的<strong>Round Robin 轮询算法</strong>）从一个服务的多台机器中选择一台。</p>
<p><strong>Feign</strong>：基于 Feign 的动态代理机制，根据注解和选择的机器，拼接请求 URL 地址，发起请求。</p>
<p><img src="http://ww1.sinaimg.cn/large/aacc02d8gy1gatmfoxtgzj20uk0cxmxw.jpg#align=left&display=inline&height=465&margin=%5Bobject%20Object%5D&originHeight=465&originWidth=1100&status=done&style=none&width=1100"></p>
<h3 id="2-某个服务挂了怎么办"><a href="#2-某个服务挂了怎么办" class="headerlink" title="2. 某个服务挂了怎么办"></a>2. 某个服务挂了怎么办</h3><p>在单体项目中，要是挂了，整个项目就用不了。在分布式架构中，A 服务挂了但是不影响 B 服务的运行，用户依然可以进行 B 服务的操作。在 SpringCloud 中通过<strong>Hystrix</strong>实现。</p>
<ul>
<li><strong>Hystrix</strong>：发起请求是通过 Hystrix 的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。</li>
</ul>
<p>当 A 服务挂了，A 服务会被熔断。请求 A 服务会立即返回。<br><strong>Hystrix 流程图</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/431489/1601187483087-d00e9c7b-5353-4845-ab1c-118ff6626f18.jpeg#align=left&display=inline&height=1065&margin=%5Bobject%20Object%5D&name=yuque_diagram%20%281%29.jpg&originHeight=1065&originWidth=1312&size=127730&status=done&style=none&width=1312" alt="yuque_diagram (1).jpg"></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5d56204a5188252bd409b5cb">https://juejin.im/post/5d56204a5188252bd409b5cb</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luckzp.github.io/2020/09/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangPeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">操作系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-12 04:19:39" itemprop="dateCreated datePublished" datetime="2020-09-12T04:19:39+00:00">2020-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 02:12:39" itemprop="dateModified" datetime="2021-06-14T02:12:39+00:00">2021-06-14</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-users"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="firestore-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-线程"><a href="#1-线程" class="headerlink" title="1.线程"></a>1.线程</h3><p>线程是程序执行流的最小单位。一个标准的线程由线程 ID，当当前指令(PC)，寄存器集合和堆栈(stack)组成。另外，线程是进程中的一个实体，是系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，<strong>但它可与同属一个进程的其他线程共享进程所拥有的资源</strong>。</p>
<p>线程共享的进程环境包括：<strong>进程代码段、进程的公有数据（如全局变量，利用这些共享的数据，线程很容易的实现相互之间的通信）、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户 ID 与进程组 ID。</strong></p>
<h3 id="2-进程的通信方式有哪些？"><a href="#2-进程的通信方式有哪些？" class="headerlink" title="2.进程的通信方式有哪些？"></a>2.进程的通信方式有哪些？</h3><ul>
<li>管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li>
<li>信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li>消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
<li>共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</li>
<li>套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luckzp.github.io/2020/09/12/%E8%B4%A2%E5%8A%A1%E5%88%86%E6%9E%90%E5%92%8C%E5%86%B3%E7%AD%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangPeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/12/%E8%B4%A2%E5%8A%A1%E5%88%86%E6%9E%90%E5%92%8C%E5%86%B3%E7%AD%96/" class="post-title-link" itemprop="url">财务分析和决策</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-12 04:19:34" itemprop="dateCreated datePublished" datetime="2020-09-12T04:19:34+00:00">2020-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 02:12:39" itemprop="dateModified" datetime="2021-06-14T02:12:39+00:00">2021-06-14</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-users"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="firestore-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一个企业所做的事情就是 3 件事情：<strong>经营，投资，融资</strong>。资产负债表，利润表，现金流量表这 3 大报表反映了一个企业的情况。</p>
<p>现金流量表这个维度，这个维度它描述了这个企业的未来是不是能够持续经营。<br>资产负债表和利润表，它们共同构成另一个维度，假设这个企业能够继续生存下去，那么它的状况会是什么样子的？</p>
<h3 id="1-资产负债表-Balance-Sheet"><a href="#1-资产负债表-Balance-Sheet" class="headerlink" title="1.资产负债表(Balance Sheet)"></a>1.资产负债表(Balance Sheet)</h3><p><img src="http://ww1.sinaimg.cn/large/aacc02d8gy1gc6n9gabqsj20ic0mz78a.jpg#align=left&display=inline&height=827&margin=%5Bobject%20Object%5D&originHeight=827&originWidth=660&status=done&style=none&width=660"></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/09/12/%E8%B4%A2%E5%8A%A1%E5%88%86%E6%9E%90%E5%92%8C%E5%86%B3%E7%AD%96/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luckzp.github.io/2020/09/12/TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangPeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/12/TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">TCP的拥塞控制机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-12 04:19:24" itemprop="dateCreated datePublished" datetime="2020-09-12T04:19:24+00:00">2020-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 02:12:39" itemprop="dateModified" datetime="2021-06-14T02:12:39+00:00">2021-06-14</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-users"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="firestore-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>拥塞控制（congestion control)是 TCP 协议的一项重要功能，TCP 的拥塞控制机制是从端到端的角度，推测网络是否发生拥塞，如果推断网络发生拥塞，则立即将数据发送速率降下来，以便缓解网络拥塞。<br>TCP 的拥塞控制算法包括了慢启动（slow start）、拥塞避免（congestion avoidance）、快速重传（fast retransmit）和快速恢复（fast recovery）四部分。</p>
<p><strong>慢启动（slow start）和拥塞避免（congestion avoidance）控制过程</strong>：<br>  -[1]. TCP 连接初始化，将拥塞窗口 cwind 设置为 1 个报文段，即 cwind=1；<br>  -[2]. 执行慢开始算法，cwind 按指数规律增长，直到 cwind == ssthresh 时，开始执行拥塞避免算法，cwind 按线性规律增长；<br>  -[3]. 当网络发生拥塞，把 ssthresh 值更新为拥塞前 ssthresh 值的一半，cwind 重新设置为 1，再按照 [2] 执行。</p>
<p><img src="http://img.blog.csdn.net/20150925124844736#align=left&display=inline&height=268&margin=%5Bobject%20Object%5D&originHeight=268&originWidth=611&status=done&style=none&width=611"></p>
<p><strong>例题：</strong></p>
<p>设某 TCP 的拥塞窗口的慢启动门限值初始为 8(单位为报文段，且最大报文段长度 1KB)，当拥塞窗口上升到 12 时，网络会发生超时。按照以上给出的条件，第 12 次传输网拥塞窗口的大小为( )。</p>
<ul>
<li>A. 5</li>
<li>B. 6</li>
<li>C. 7</li>
<li>D. 8</li>
</ul>
<p><strong>解析：B</strong></p>
<p>在慢启动和拥塞避免算法中，拥塞窗口初始值为 1，窗口大小开始按指数增长。当拥塞窗口大于慢启动门限后，停止使用慢启动算法，改用拥塞避免算法。此时，慢启动的门限值初始为 8，当拥塞窗口增大到 8 时改用拥塞避免算法，窗口大小按线性增长，毎次增长 1 个报文段。当增加到 12 时，出现超时，重新设置门限值为 6(12 的一半)，拥塞窗口再重新设为 1，执行慢启动算法，到门限值为 6 时执行拥塞避免算法。按照上面的算法，拥塞窗口的变化为 1、2、4、8、9、10、11、12、1、2、4、6、7、8、9…，从该序列可以看出，第 12 次传输时拥塞窗口大小为 6。</p>
<p><strong>注意：</strong>在以上的序列中，6 被加粗，原因是很多考生直接从 4 增加到 8，导致误选 D 选项。原因是拥塞窗口的大小是与门限值有关的，在慢开始算法中不能直接变化为大千门限值，所以 4 只能最多增加到 6，之后再执行拥塞避免算法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luckzp.github.io/2020/09/12/OKR%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangPeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/12/OKR%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">OKR学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-12 04:19:19" itemprop="dateCreated datePublished" datetime="2020-09-12T04:19:19+00:00">2020-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 02:12:39" itemprop="dateModified" datetime="2021-06-14T02:12:39+00:00">2021-06-14</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-users"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="firestore-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<h2 id="title-OKR-学习-date-2020-02-03-22-07-56"><a href="#title-OKR-学习-date-2020-02-03-22-07-56" class="headerlink" title="title: OKR 学习 date: 2020-02-03 22:07:56"></a>title: OKR 学习 date: 2020-02-03 22:07:56</h2><p>tags: 个人提升</p>
<h3 id="1-OKR-与心理学"><a href="#1-OKR-与心理学" class="headerlink" title="1. OKR 与心理学"></a>1. OKR 与心理学</h3><p>在人性角度上讲，承诺的事情就要去努力做到。深层次来看，OKR 便恰恰体现了这样一种“承诺”精神，这也是社会心理学中提到的“承诺和一致原理”，即人们通常<strong>会将自己的承诺与行动保持一致</strong>。此外，当我们看到许多人在同时做某件事情时，自己也会跟着去效仿，这就是社会心理学中所提到的“<strong>从众心理</strong>”。</p>
<h3 id="2-OKR-制定注意事项"><a href="#2-OKR-制定注意事项" class="headerlink" title="2. OKR 制定注意事项"></a>2. OKR 制定注意事项</h3><p>O：</p>
<ul>
<li>方向明确：目标不能太抽象，也不能含混不清，要让每个人都能看得懂。</li>
<li>目标对齐：下级要对齐上级的目标，即向上对齐，平级还要相互对齐，即水平对齐。</li>
<li>时间限制：目标需要有时间边界，不能遥遥无期，而且时间边界要恰到好处。</li>
<li><strong>O 尽可能要以动词形式开头。例如：打造……、建设……、实现……。</strong></li>
<li>O 最好能附上一句目标描述。建议为 O 增加一句话描述，就“为何我要写这个目</li>
</ul>
<p>标？”这一问题，来向大家讲解。</p>
<p>KR：</p>
<ul>
<li>有挑战性：关键结果要有挑战性，拒绝平庸，拒绝不切实际，要做到“跳一跳，就能够</li>
</ul>
<p>得着”。</p>
<ul>
<li>容易度量：无法度量的关键结果是没有任何意义的，宁可抛弃。</li>
<li>不是任务：关键结果需要对目标产生直接影响，它不是日常任务，也不是行动计划。</li>
</ul>
<p>O 和 KR 之间是“一对多”的关系。既然 OKR 需要考虑时间限制，最多不要超过 3 个，否则就容易导致精力有限，不够聚焦。每个 O 所包含的 KR 也无需太多，最多也不要超过 3 个。</p>
<p><img src="http://ww1.sinaimg.cn/large/aacc02d8ly1gbjkfbmdgdj20ri0ap3zp.jpg#alt=OKR%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/aacc02d8ly1gbjkg54iuwj20sz0f90wb.jpg#alt=OKR%E5%88%B6%E5%AE%9A%E6%8A%80%E5%B7%A7.png"></p>
<h3 id="3-OKR-与-KPI-区别"><a href="#3-OKR-与-KPI-区别" class="headerlink" title="3. OKR 与 KPI 区别"></a>3. OKR 与 KPI 区别</h3><ul>
<li>KPI 是是由上级领导制定，自己需要去执行，中间难免会有“讨价还价”的过程；OKR 是根据上级领导的 KR 来制定自己的 OKR，能激发其主观能动性。</li>
<li>KPI 是工业时代下的产物，它提倡用结果来说话，进而减少过程中的管理成本。适合于重复</li>
</ul>
<p>性机械劳动比如拧螺丝钉。OKR 是互联网时代下的产物，更适合用探索型工作，没有现成的指令和方法可以遵循。</p>
<p>OKR 与 KPI 结合使用：<strong>KPI 中包括的绩效指标一定是只看结果，而不看过程的，只要结果达到了就行，而 OKR 需要更多地关心过程，从结果中判断目标的具体达成情况。</strong></p>
<h3 id="4-OKR-的对齐"><a href="#4-OKR-的对齐" class="headerlink" title="4. OKR 的对齐"></a>4. OKR 的对齐</h3><ul>
<li>不建议将上级 KR 变成下级 O，这样会降低 OKR 系统的稳定性。比如，如果上级 KR 变化，就会导致下级 O 变化，从而导致下级 KR 变化。</li>
<li>OKR 所提倡的“对齐”指的是在 O 上做出支撑，下级需要支撑上级的 O，平级之间也要相互支撑，然而 KR 只是为了支撑自己的 O。</li>
</ul>
<h3 id="5-OKR-使用不当"><a href="#5-OKR-使用不当" class="headerlink" title="5. OKR 使用不当"></a>5. OKR 使用不当</h3><p>OKR 是自驱力较强的人自我成长的利器，一定要了解 OKR 的这一特性：OKR 落地不需要让人在后面不断催促，然后才能出结果的。否则，就必然会适得其反。在这过程中，如果你用了 OKR，反而让大家产生了更大的压力，那就起反作用了，因此也失去了 OKR 原本的“功效”。</p>
<h3 id="6-OKR-评分"><a href="#6-OKR-评分" class="headerlink" title="6. OKR 评分"></a>6. OKR 评分</h3><ul>
<li>1.0 分：不可能做到，但实际做到了。</li>
<li>0.7 分：希望能做到，实际也做到了。</li>
<li>0.3 分：肯定能做到，实际也做到了。</li>
<li>0 分：肯定能做到，但实际没做到。</li>
</ul>
<p>OKR 评分不是跟别人比，而是跟自己的过去比，自己有没有进步？有没有超越过去的自己？</p>
<p><img src="http://ww1.sinaimg.cn/large/aacc02d8ly1gbjkhb899lj20oi0by0tf.jpg#alt=%E8%AF%84%E5%88%86%E5%92%8C%E4%BF%A1%E5%BF%83%E6%8C%87%E6%95%B0%E5%85%B3%E7%B3%BB.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luckzp.github.io/2020/09/12/NIO%E5%88%9D%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangPeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/12/NIO%E5%88%9D%E8%AF%86/" class="post-title-link" itemprop="url">NIO初识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-12 04:19:14" itemprop="dateCreated datePublished" datetime="2020-09-12T04:19:14+00:00">2020-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 02:12:39" itemprop="dateModified" datetime="2021-06-14T02:12:39+00:00">2021-06-14</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-users"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="firestore-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>tags:[Java]</p>
<hr>
<h3 id="1-NIO-概念"><a href="#1-NIO-概念" class="headerlink" title="1.NIO 概念"></a>1.NIO 概念</h3><p>同步非阻塞 IO(socket 主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的 I/O 操作是同步阻塞的)，通常用于网络服务器进行多路复用 IO。Redis，Nginx, Tomcat8.X 采用这种方式，RabbitMQ 采用类似这种思想。</p>
<p><img src="http://ww1.sinaimg.cn/large/aacc02d8gy1gdqtd66t03j20gb05f0tw.jpg#align=left&display=inline&height=195&margin=%5Bobject%20Object%5D&originHeight=195&originWidth=587&status=done&style=none&width=587"><br>以 nginx 为例，ngnix 会有很多请求进来， epoll 会把他们都监视起来，然后像拨开关一样，谁有数据就拨向谁，然后调用相应的代码处理。</p>
<h3 id="2-epoll"><a href="#2-epoll" class="headerlink" title="2.epoll"></a>2.epoll</h3><p>epoll 可以理解为 event poll，不同于忙轮询和无差别轮询，epoll 之会把哪个流发生了怎样的 I/O 事件通知我们。此时我们对这些流的操作都是有意义的。（复杂度降低到了 O(k)，k 为产生 I/O 事件的流的个数)。</p>
<h3 id="3-selector"><a href="#3-selector" class="headerlink" title="3.selector"></a>3.selector</h3><p>新事件(读就绪、写就绪、有新连接到来)到来的时候，会在 selector 上注册标记位，标示可读、可写或者有连接到来。<br>**Selector.select()**是阻塞的，通过操作系统的通知（epoll）这个函数是阻塞的。可以在一个 while(true)里面调用这个函数而不用担心 CPU 空转。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luckzp.github.io/2020/09/12/MySQL%E4%B8%AD%E7%9A%84B+%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangPeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/12/MySQL%E4%B8%AD%E7%9A%84B+%E6%A0%91/" class="post-title-link" itemprop="url">MySQL中的B+树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-12 04:19:09" itemprop="dateCreated datePublished" datetime="2020-09-12T04:19:09+00:00">2020-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 02:12:39" itemprop="dateModified" datetime="2021-06-14T02:12:39+00:00">2021-06-14</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-users"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="firestore-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>tags:[MySQL]</p>
<hr>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>mysql 中的索引底层使用的是 B+树，索引存储在硬盘中，而非内存中。考虑性能，要减少磁盘 IO 次数。<br>构建 M 叉树，M 越大，树的高度越小，磁盘 IO 变少了。<br><strong>举例：</strong><br>如果 m 叉树中的 m 是 100，那对一亿个数据构建索引，树的高度也只是 3（层数是 4），最多只要 3 次磁盘 IO 就能获取到数据（第一层节点存在内存里）。磁盘 IO 变少了，查找数据的效率也就提高了。</p>
<p><strong>那 m 叉树中的 m 是不是越大越好呢？到底多大才最合适呢？</strong></p>
<p>不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是 4KB，这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。所以，我们在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘 IO 操作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luckzp.github.io/2020/09/12/MySQL%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangPeng">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/12/MySQL%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/" class="post-title-link" itemprop="url">MySQL实战-学习笔记(2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-12 04:19:04" itemprop="dateCreated datePublished" datetime="2020-09-12T04:19:04+00:00">2020-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 02:12:39" itemprop="dateModified" datetime="2021-06-14T02:12:39+00:00">2021-06-14</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-users"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="firestore-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>tags:[MySQL]</p>
<hr>
<h3 id="7-行锁功过：怎么减少行锁对性能的影响？"><a href="#7-行锁功过：怎么减少行锁对性能的影响？" class="headerlink" title="7 行锁功过：怎么减少行锁对性能的影响？"></a>7 行锁功过：怎么减少行锁对性能的影响？</h3><p><strong>两阶段锁协议</strong></p>
<p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。在一个事务中，把最可能发生锁冲突的 SQL 语句放在最后，减少锁行的时间。</p>
<h3 id="8-事务到底是隔离的还是不隔离的？"><a href="#8-事务到底是隔离的还是不隔离的？" class="headerlink" title="8 事务到底是隔离的还是不隔离的？"></a>8 事务到底是隔离的还是不隔离的？</h3><p><strong>可重复读</strong></p>
<p>事务 T 启动的时候会创建一个视图 read-view，之后事务 T 执行期间，即使有其他事务修改了数<br>据，事务 T 看到的仍然跟在启动时看到的一样。</p>
<p>一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。<br><strong>当前读 VS 快照读</strong></p>
<p>当事务隔离级别是可重复读时</p>
<ul>
<li>快照读： 读取的是事务开启前的数据，比如 select。```sql<br>select * from table …</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 当前读：总是读取已经提交完成的最新版本。特殊的读操作，插入 &#x2F; 更新 &#x2F; 删除操作，属于当前读，处理的都是当前的数据，需要加锁。&#96;&#96;&#96;sql</span><br><span class="line">select * from table where ? lock in share mode; S 锁，Gap 锁</span><br><span class="line"></span><br><span class="line">select * from table where ? for update; X 锁，Gap 锁</span><br><span class="line"></span><br><span class="line">insert; X 锁，Gap 锁</span><br><span class="line"></span><br><span class="line">update ; X 锁，Gap 锁</span><br><span class="line"></span><br><span class="line">delete; X 锁，Gap 锁</span><br></pre></td></tr></table></figure>

<p>读操作通常加共享锁（Share locks，S 锁，又叫读锁），写操作加排它锁（Exclusive locks，X 锁，又叫写锁）；加了共享锁的记录，其他事务也可以读，但不能写；加了排它锁的记录，其他事务既不能读，也不能写。</p>
<h3 id="9-普通索引和唯一索引，应该怎么选择？"><a href="#9-普通索引和唯一索引，应该怎么选择？" class="headerlink" title="9 普通索引和唯一索引，应该怎么选择？"></a>9 普通索引和唯一索引，应该怎么选择？</h3><p>Update 语句普通索引会用到 change buffer 减少磁盘 IO，先把数据记录到 change buffer,然后当查询的时候触发 merge 将数据同步到磁盘上，从而达到比唯一索引快的目的。但是针对于更新完后，立即访问对应的数据页，会增加了 change buffer 维护代价。</p>
<h3 id="13-为什么表数据删掉一半，表文件大小不变？"><a href="#13-为什么表数据删掉一半，表文件大小不变？" class="headerlink" title="13 为什么表数据删掉一半，表文件大小不变？"></a>13 为什么表数据删掉一半，表文件大小不变？</h3><p>delete 删除数据，但是实际上数据页并没有被删除，而是留着被复用。如果要减小文件大小通过 optimize table t 。通过如下程序实验，先通过存储过程 idata 新增数据然后查询表文件大小，后 delete 删除后发现表文件大小没变，最后通过 optimize table t 来减少了表文件大小。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line"><span class="keyword">set</span> i=<span class="number">1000</span>;</span><br><span class="line">while(i&lt;=10000)do</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(i, i);</span><br><span class="line"><span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(<span class="keyword">round</span>(<span class="keyword">sum</span>(DATA_LENGTH/<span class="number">1024</span>/<span class="number">1024</span>),<span class="number">2</span>),<span class="string">&#x27;M&#x27;</span>) <span class="keyword">from</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="keyword">CALL</span> idata();</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(<span class="keyword">round</span>(<span class="keyword">sum</span>(DATA_LENGTH/<span class="number">1024</span>/<span class="number">1024</span>),<span class="number">2</span>),<span class="string">&#x27;M&#x27;</span>) <span class="keyword">from</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="string">`user`</span> <span class="keyword">where</span> user_id &gt; <span class="number">6</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(<span class="keyword">round</span>(<span class="keyword">sum</span>(DATA_LENGTH/<span class="number">1024</span>/<span class="number">1024</span>),<span class="number">2</span>),<span class="string">&#x27;M&#x27;</span>) <span class="keyword">from</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="keyword">optimize</span> <span class="keyword">table</span> <span class="string">`user`</span>;</span><br></pre></td></tr></table></figure>

<h3 id="15-临时表"><a href="#15-临时表" class="headerlink" title="15 临时表"></a>15 临时表</h3><p>建表语法是</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">table</span> …</span><br></pre></td></tr></table></figure>

<p>临时表只能被创建它的 session 访问，所以在这个 session 结束的时候，会自动删除临时表。</p>
<h3 id="16-Join-使用注意"><a href="#16-Join-使用注意" class="headerlink" title="16 Join 使用注意"></a>16 Join 使用注意</h3><ol>
<li>小标表作为驱动表。</li>
<li>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与 join 的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhang Peng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Peng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        




  <script src="https://www.gstatic.com/firebasejs/6.3.3/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/6.3.3/firebase-firestore.js"></script>
  <script>
    firebase.initializeApp({
      apiKey   : 'AIzaSyAOxPsO3R2S_FEcgmCicMAdmH2WL4dcqQw',
      projectId: 'flash-spark-160014'
    });

    function getCount(doc, increaseCount) {
      // IncreaseCount will be false when not in article page
      return doc.get().then(d => {
        var count = 0;
        if (!d.exists) { // Has no data, initialize count
          if (increaseCount) {
            doc.set({
              count: 1
            });
            count = 1;
          }
        } else { // Has data
          count = d.data().count;
          if (increaseCount) {
            // If first view this article
            doc.set({ // Increase count
              count: count + 1
            });
            count++;
          }
        }

        return count;
      });
    }

    function appendCountTo(el) {
      return count => {
        el.innerText = count;
      }
    }
  </script>
  <script>
    (function() {
      var db = firebase.firestore();
      var articles = db.collection('articles');

      if (CONFIG.page.isPost) { // Is article page
        var title = document.querySelector('.post-title').innerText.trim();
        var doc = articles.doc(title);
        var increaseCount = CONFIG.hostname === location.hostname;
        if (localStorage.getItem(title)) {
          increaseCount = false;
        } else {
          // Mark as visited
          localStorage.setItem(title, true);
        }
        getCount(doc, increaseCount).then(appendCountTo(document.querySelector('.firestore-visitors-count')));
      } else if (CONFIG.page.isHome) { // Is index page
        var promises = [...document.querySelectorAll('.post-title')].map(element => {
          var title = element.innerText.trim();
          var doc = articles.doc(title);
          return getCount(doc);
        });
        Promise.all(promises).then(counts => {
          var metas = document.querySelectorAll('.firestore-visitors-count');
          counts.forEach((val, idx) => {
            appendCountTo(metas[idx])(val);
          });
        });
      }
    })();
  </script>




      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
