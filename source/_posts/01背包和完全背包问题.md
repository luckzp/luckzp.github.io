---
layout: post
title: "01背包和完全背包问题"
date: 2018-01-07 21:27
comments: true
reward: true
tags: 
	- 校招
---
### 01背包问题描述

容量为m的背包和n个物品，每个物品都有各自的体积v和价值val，从这n 个物品中选择多个物品放在包里而物品体积总数不超过包的容量m 时，能够得到的最大价值是多少？



**一般同学们会考录到用贪心的算法通过求最大的性价比来填满背包，这样会有什么样的不妥之处了？**

<!--more-->

### 贪心与背包问题的不同

- 首先说一下贪心是每一步都是最优的决策，就是每次方我都会放进去解决问题的目前最好的结果。
- 贪心虽然会带来每一次最优但是不一定是整体最优。(比如说C的性价比最高，但是放了C就不能放别的了，总价值就不如放A和B的多了)
- 背包可以从宏观上整体得到一个最优的结果。



### 01背包问题解析

- 问题的特点是：每种物品一件，可以选择放1或不放0。

- 用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：`f[i][v] = max(f[i-1][v-p[i]] + w[i], f[i-1][v])`

- 如果在这里第i件物品放的话就表明它是由第i-1的状态传递过来的并且加上新的价值w[i]，如果不放就表明这里是保持第i-1的状态没有增加新的价值。

代码如下：

```C
 for(i=0; i<=n; i++) dp[i][0] = 0;
        for(i=0; i<=v; i++) dp[0][i] = 0;

        for(i=1; i<=n; i++){
            for(j=0; j<=v; j++){
                dp[i][j] = dp[i-1][j];
                if(j>=p[i]) dp[i][j] = max(dp[i-1][j], dp[i-1][j-p[i]]+w[i]);
            }
        }
        printf("%d\n", dp[n][v]);
    }

```

手工模拟代码：

![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxv1f157poj20kk04h0w4.jpg)

解释这个表：
有三个物品 就用 (3,4), (4,5), (5,6) 表示（对应表左边）
用 C(i)(j) 表示表C ，j 为横， i 为纵
从 C(1)(1)开始，此时你只有一个物品 (3,4) 和一个 容量为 j = 1 的背包。
因为 3 > 1 所以不能装入，所以此时背包内物品价值为 C(1)(1)= 0
同理 C(1)(2)时，背包 j = 2，3 > 2，C(1)(2)= 0
C(1)(3)时 背包大小为 3 刚好能装下这个大小为 3 的物品 所以C(1)(3) = 4
之后因为只有物品 (3,4) 可选 所以包里价值都是 4
…………
C(3)(10)  的时候三种物品都可选，最佳组合是 (4,5) 和 (5,6)，所以C(3)(10) = 5 + 6 = 11.



### 01背包代码优化

原式子(二维的):  `f[i][v] = max{f[i-1][v-p[i]] + w[i], f[i-1][v]}`

现在要改成一维的(空间优化):  `f[v] = max{f[v-p[i]] + w[i], f[v]}`

注意上面的状态转移方程两边的是2个状态(左边的是这一状态  右边的是上一状态（二维的通过i可以看出来）)

`f[i][v]`是由`f[i-1][v-c[i]]`推出来的,现在要把二维的改成一维的,即要推f[v],要保证f[v]由f[v-c[i]]推出来，如果v是顺序递增的,则相当于`f[i][v]`变得是由`f[i][v-c[i]]`推出来的,而不是由原来的`f[i-1][v-c[i]]`推的.

具体分析见：[01背包问题 总结关于为什么01背包优化成1维数组后,内层循环是逆序的?](http://blog.csdn.net/xiajiawei0206/article/details/19933781)

`f[i][v]`只与`f[i-1][v]`和`f[i-1][v-C[i]]`有关，即只和i-1时刻状态有关，所以我们只需要用一维数组f[]来保存i-1时的状态f[]。
假设i-1时刻的f[]为{a0，a1，a2，…，av}，难么i时刻的f[]中第v个应该为max(av,av-C[i]+W[i])即max(f[v],f[v-C[i]]+W[i])，这就需要我们遍历V时逆序遍历，这样才能保证求i时刻f[v]时f[v-C[i]]是i-1时刻的值。如果正序遍历则当求f[v]时,其前面的f[0],f[1]，…，f[v-1]都已经改变过，里面存的都不是i-1时刻的值，这样求f[v]时利用f[v-C[i]]必定是错的值。最后f[V]即为最大价值.

```c
for(i=0; i<=v; i++){
            dp[i] = 0;
        }
        for(i=1; i<=n; i++){
            for(j=v; j>=0; j--){
                if(j>=p[i]) dp[j] = max_num(dp[j], dp[j-p[i]]+w[i]);
            }
        }
        printf("%d\n", dp[v]);
    }

```



### 完全背包问题描述

容量为m的背包和n种物品，每个物品都有各自的体积v和价值val，每种物品都有无限件可用，将哪些物品装入背包物品体积总数不超过包的容量m 时，能够得到的最大价值是多少？

### 完全背包问题解析

这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令`f[i][v]`表示前i种物品恰放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程：

`f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k*c[i]<=v}`


同样可以转换成一维数组来表示：

伪代码如下：

```c++
    for (int i=1; i<=n; i++)  
        for (int j=1; j<=v; j++)  
        {  
            if (p[i]<=j)  
            {  
                f[j]=max(f[j],f[j-p[i]]+w[i]);  
            }             
        }  
      
    cout<<f[v]<<endl;//输出最优解
```

# 顺序！

想必大家看出了和01背包的区别，这里的内循环是顺序的，而01背包是逆序的。
现在关键的是考虑：为何完全背包可以这么写？
在次我们先来回忆下，01背包逆序的原因？是为了是max中的两项是前一状态值，这就对了。
那么这里，我们顺序写，这里的max中的两项当然就是当前状态的值了，为何？
因为每种背包都是无限的。当我们把i从1到N循环时，f[v]表示容量为v在前i种背包时所得的价值，这里我们要添加的不是前一个背包，而是当前背包。所以我们要考虑的当然是当前状态。

