---
title: 20191107深入学习
date: 2019-11-14 16:01:17
tags: JAVA
---

### 1.  JVM分区是哪些，哪些是线程独有的

![TIM截图20191114162719.png](http://ww1.sinaimg.cn/large/aacc02d8ly1g8xnp68hsgj209q084750.jpg)

### 2. HashMap为什么线程不安全

- Put的时候会导致数据会覆盖

-  删除键值对 

-  addEntry中当加入新的键值对后键值对总数量超过门限值的时候会调用一个resize操作 

  比如有两个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录所要落到的桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的桶索引和线程B要插入的记录计算出来的桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了。

### 3. synchronized锁什么时候升级

![TIM截图20191121094106.png](http://ww1.sinaimg.cn/large/aacc02d8ly1g95f1ec5vej20nc0c2t99.jpg)

![TIM截图20191121094422.png](http://ww1.sinaimg.cn/large/aacc02d8ly1g95f29kxcaj20n608uglt.jpg)

### 4. lock可以用来做什么锁

- ReentrantLock
- ReentrantReadWriteLock.ReadLock
- ReentrantReadWriteLock.WriteLock
- StampedLock.ReadLockView
- StampedLock.WriteLockView

### 5. 哪些可以当做 GC Roots对象 

可以作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）

- 虚拟机栈（栈帧中的本地变量表）中引用的对象；
- 方法区中类静态属性引用的对象；
- 方法区中常量引用的对象；
- 本地方法栈中JNI（即一般说的Native方法）引用的对象；

总结就是，方法运行时，方法中引用的对象；类的静态变量引用的对象；类中常量引用的对象；Native方法中引用的对象。