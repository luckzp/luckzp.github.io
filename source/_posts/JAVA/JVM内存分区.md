---
layout: post
title: "JVM内存分区"
date: 2019-5-21 11:14:07
tags: Java
---

#### 1. JVM的内存模型

**线程私有：**

栈（方法栈）：线程在执行方法的时候会创建一个栈帧，栈帧包含：局部变量表，操作数栈，动态链接（与其他方法相链接），方法出口等信息。

本地方法栈：与栈类型，不同点是执行native方法。

程序计数器：保存当前字节码的位置

**线程共享：**

堆：由垃圾回收器管理。

-Xms: 堆的最小值

-Xmx: 堆的最大值

-XX:NewSize: 新生代最小值

-XX:MaxNewSize: 新生代最大值

新生代：Eden:From:To = 8:1:1

方法区：用以存储加载类的信息，常量，静态变量。JDK8以前，方法区是在堆永久代中，JDK8及以后取消了永久代，方法区挪到直接内存MetaSpace中。

永久代：

jdk1.7及以前： -XX:PermSize -XX:MaxPermSize

jdk1.8以后：-XX:MetaspaceSize -XX:MaxMetaspaceSize

![](http://ww1.sinaimg.cn/large/aacc02d8ly1g2v0u0kga5j20jv0dnmzd.jpg)

<!--more-->

局部变量存在虚拟机栈中，常量存在方法区中，成员变量则随着对象一起存在堆中。

Java 堆从 GC 的角度还可以细分为: 新生代( Eden 区 、 From Survivor 区 和 To Survivor 区 )和老年
代。



![](http://ww1.sinaimg.cn/large/aacc02d8ly1g2v1049rtij20ir05n3zt.jpg)

![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxuyutofxmj20vw0lidrd.jpg)



#### 2. 垃圾回收算法

**2.1 两种判断对象是否死亡的方法**

1.引用计数法

它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。

2.GC Roots可达性分析法

目前 Java 虚拟机的主流垃圾回收器采取的是可达性分析算法。这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。

**2.2 垃圾回收的三种方式**

**标记清除清除算法（Mark-Sweep）**

即把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。

缺点很明显，会造成内存碎片。JVM内部是要求内存连续的，所以就会出现总的空闲内存还比较充足但是无法分配对象的情况。

**压缩（Mark-Compact）**

即把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。

**复制（copying）**

即把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。

分代收集法是目前大部分 JVM 所采用的方法，**其核心思想是根据对象存活的不同生命周期将内存**
**划分为不同的域，**一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(Young
Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃
圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。

**新生代：复制算法** 

当Eden区域内存不够的时候触发MinorGC,MinorGC采用复制算法。因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少。

- Eden, From -> To 
- 清空 Eden, From
- To和From互换

当老年代空间不够用时，触发FullGC。

**老年代：压缩算法**

老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。

因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标
记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存.