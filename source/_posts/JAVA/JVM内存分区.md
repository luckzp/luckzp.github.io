---
layout: post
title: "JVM内存分区"
data: 2019-4-29 09:46:57
tags: 
	- JAVA
---

#### 1. JVM的内存模型

![](http://ww1.sinaimg.cn/large/aacc02d8ly1g2v0u0kga5j20jv0dnmzd.jpg)

<!--more-->

局部变量存在虚拟机栈中，常量存在方法区中，成员变量则随着对象一起存在堆中。

虚拟机栈存的是方法，每个方法包括：局部变量表，操作数栈，动态链接（与其他方法相链接），出口。

Java 堆从 GC 的角度还可以细分为: 新生代( Eden 区 、 From Survivor 区 和 To Survivor 区 )和老年
代。

![](http://ww1.sinaimg.cn/large/aacc02d8ly1g2v1049rtij20ir05n3zt.jpg)

![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxuyutofxmj20vw0lidrd.jpg)



![](http://ww1.sinaimg.cn/large/aacc02d8ly1fxuyvjd0o1j20qr0fddju.jpg)

#### 2. 垃圾回收算法

**2.1 两种判断对象是否死亡的方法**

1.引用计数法

它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。

2.GC Roots可达性分析法

目前 Java 虚拟机的主流垃圾回收器采取的是可达性分析算法。这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。

**2.2 垃圾回收的三种方式**

**标记清除清除算法（Mark-Sweep）**

即把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。

缺点很明显，会造成内存碎片。JVM内部是要求内存连续的，所以就会出现总的空闲内存还比较充足但是无法分配对象的情况。

**压缩（Mark-Compact）**

即把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。

**复制（copying）**

即把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。

分代收集法是目前大部分 JVM 所采用的方法，**其核心思想是根据对象存活的不同生命周期将内存**
**划分为不同的域，**一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(Young
Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃
圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。

**新生代：复制算法** 

因为新生代中每次垃圾回收都要
回收大部分对象，即要复制的操作比较少，但通常并不是按照 1：1 来划分新生代。一般将新生代
划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用
Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另
一块 Survivor 空间中。

每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量
存活对象的复制成本就可以完成收集.

**老年代：压缩算法**

老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。

因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标
记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存.