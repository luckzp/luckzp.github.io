---
layout: post
title: "面试复盘"
date: 2019-5-21 11:15:07
comments: true
tags: 
	- JAVA
---

### 1. redis分布式锁的实现

setnx命令为例子，由于Redis的单线程命令处理机制，如果有多个客户端同时执行setnx key value，
根据setnx的特性只有一个客户端能设置成功，setnx可以作为分布式锁的一种实现方案。

```java
public class RedisTool {
 
    private static final String LOCK_SUCCESS = "OK";
    private static final String SET_IF_NOT_EXIST = "NX";
    private static final String SET_WITH_EXPIRE_TIME = "PX";
 
    /**
     * 尝试获取分布式锁
     * @param jedis Redis客户端
     * @param lockKey 锁
     * @param requestId 请求标识
     * @param expireTime 超期时间
     * @return 是否获取成功
     */
    public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) {
 
        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);
 
        if (LOCK_SUCCESS.equals(result)) {
            return true;
        }
        return false;
 
    }
 
}
```

### 2. 多线程保证数据安全性

保证数据线程安全的思路基本有以下三种，这三种中又分别有不同的做法：

> 1. 线程封闭技术，让数据只能被单个线程所见。如Threadlocal
>
> 2. 使用原子类如AtomicInteger其底层就是volatile和CAS 共同作用的结果。
>
>    首先使用了volatile 保证了内存可见性。
>
>    然后使用了CAS（compare-and-swap）算法 保证了原子性。 其中CAS算法的原理就是里面包含三个值：内存值A  预估值V  更新值 B  当且仅当 V == A 时，V = B; 否则，不会执行任何操作。
>
> 3. 同步技术，正确的发布并维护共享数据。如synchronized锁，即线程A获取到锁后，线程B阻塞直到线程A释放锁，线程B才能获取到同一个锁 。

### 3. equals和hashcode

equals方法注重 **两个对象在逻辑上是否相等**。

> 1） 只要重写 equals ，就必须重写 hashCode 。
> 2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的
> 对象必须重写这两个方法。
> 3） 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals 。
> 说明： String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象
> 作为 key 来使用。

### 4. MQ消息事务一致性

主要是让消息持久化。

>1)  上游应用，执行业务并发送指令给可靠消息服务并保留消息副本。
>
>2)  可靠消息服务和 MQ消息组件，协调上下游消息的传递，并确保上下游数据的一致性。
>
>3)  下游应用，监听 MQ 的消息并执行自身业务并保留消息副本。

