---
title: 校招笔试题目总结（一）
urlname: bzulx4
date: 2020-09-12 12:20:19 +0800
tags: []
categories: []
---

---

## layout: posttitle: "校招笔试题目总结(一)"

date: 2017-9-4 19:58
comments: true
reward: true
tags:

- 校招

8 月 26 号辞去实习，回学校准备校招，刷了一些题目。在此做个自己认为常考题的总结。

### 1.在 32 位系统下 char\_ p[10]; char(\_p1)[10]，sizeof(p)和 sizeof (p1)分别值为？

![](https://wx4.sinaimg.cn/large/aacc02d8ly1fxvowcbqaqj20ie0b6dgo.jpg#alt=image)

### 2.C++类的内存大小计算

![](https://wx2.sinaimg.cn/large/aacc02d8ly1fxvowk1t20j20tx0gnjva.jpg#alt=image)

![](https://ws3.sinaimg.cn/large/aacc02d8ly1fxvowq8xj4j20tg076myx.jpg#alt=image)

### 3.排序算法性能的比较及应用

**时间复杂度**：简单选择排序、直接插入排序和冒泡排序的平均情况下的时间复杂度都为 O(n2)，但快速排序平均性能可以达到 O(nlog2n)，实际应用中常常优于其他排序算法。归并排序同样是基于分治的思想，最坏和平均时间复杂度均为 O(nlog2n)。

**空间复杂度**：简单选择排序、插入排序、冒泡排序、希尔排序和堆排序仅需借助常数个辅助空间。快速排序在空间上只使用一个小的辅助栈，用于实现递归，平均情况大小为 O(log2n)，最坏的情况下可能会增长到 O(n)。二路归并排序需要借助较多的辅助空间用于元素复制，大小为 O(n)。

**稳定性**：插入排序、冒泡排序、归并排序和基数排序是稳定的排序方法，而简单选择排序、快速排序、希尔排序和堆排序都是不稳定的排序方法。对排序方法的稳定性，应从本身的原理上去理解，而不应拘泥于死记硬背。

**应用**：

1. 若 n 较小时(n<=50)，则可以采用直接插入排序或简单选择排序。
2. 若文件的初始状态已按关键字基本有序，则选用直接插入或冒泡排序。
3. 若 n 较大，则应采用时同复杂度为 O(nlog2n)的排序方法快速排序、堆排序、归并排序。快速排序被认为是目前基于比较的内部排序法中最好的方法。若要求排序稳定且时间复杂度为 O(nlog2n),则可选用归并排序。
4. 若 n 很大，记录的关键字位数较少且可以分解时，采用基数排序较好。
5. 当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结

### 4.二叉树前序、中序、后序遍历相互求法

例：

前序遍历:         GDAFEMHZ

中序遍历:         ADEFGHMZ

**画树求法：**第一步，根据前序遍历的特点，我们知道根结点为 G

第二步，观察中序遍历 ADEFGHMZ。其中 root 节点 G 左侧的 ADEF 必然是 root 的左子树，G 右侧的 HMZ 必然是 root 的右子树。

第三步，观察左子树 ADEF，左子树的中的根节点必然是大树的 root 的 leftchild。在前序遍历中，大树的 root 的 leftchild 位于 root 之后，所以左子树的根节点为 D。

第四步，同样的道理，root 的右子树节点 HMZ 中的根节点也可以通过前序遍历求得。在前序遍历中，一定是先把 root 和 root 的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。

第五步，观察发现，上面的过程是递归的。先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了。该步递归的过程可以简洁表达如下：

1 确定根,确定左子树，确定右子树。

2 在左子树中递归。

3 在右子树中递归。

4 打印当前根。

那么，我们可以画出这个二叉树的形状：

![](http://www.cr173.com/up/2013-1/2013010715404717978.jpg#alt=img)

那么，根据后序的遍历规则，我们可以知道，后序遍历顺序为：AEFDHZMG.
