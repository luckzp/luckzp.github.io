---
layout: post
title: "校招笔试题目总结(一)"
date: 2017-9-4 19:58
comments: true
reward: true
tags: 
	- 校招
---

8月26号辞去实习，回学校准备校招，刷了一些题目。在此做个自己认为常考题的总结。

### 1.在32位系统下char* p[10]; char(*p1)[10]，sizeof(p)和sizeof (p1)分别值为？

![](http://ovuyz1070.bkt.clouddn.com/17-9-6/38990217.jpg)

<!--more--> 

### 2.C++类的内存大小计算

![](http://ovuyz1070.bkt.clouddn.com/17-9-6/33208.jpg)

![](http://ovuyz1070.bkt.clouddn.com/17-9-6/54076229.jpg)



### 3.排序算法性能的比较及应用

**时间复杂度**：简单选择排序、直接插入排序和冒泡排序的平均情况下的时间复杂度都为O(n^2),实现过程较简单，但直接插入排序和冒泡排序在最好的情况下时间复杂度可以达到O(n)，而简单选择排序则与序列的初始状态无关。希尔排序作为插入排序的拓展，对较大规模的排序都可以达到很高的效率，但是目前未得出其精确的渐近时间。堆排序是利用了一种称为堆，可以在线性时间内完成建堆，并且在O(nlog2n)内完成排序过程。快速排序是基于分治的思想，最坏情况下快速排序时间会达到O(n^2)，但快速排序平均性能可以达到O(nlog2n)，实际应用中常常优于其他排序算法。归并排序同样是基于分治的思想，最坏和平均时间复杂度均为O(nlog2n)。

**空间复杂度**：简单选择排序、插入排序、冒泡排序、希尔排序和堆排序仅需借助常数个辅助空间。快速排序在空间上只使用一个小的辅助栈，用于实现递归，平均情况大小为O(log2n)，最坏的情况下可能会增长到O(n)。二路归并排序需要借助较多的辅助空间用于元素复制，大小为O(n)。

**稳定性**：插入排序、冒泡排序、归并排序和基数排序是稳定的排序方法，而简单选择排序、快速排序、希尔排序和堆排序都是不稳定的排序方法。对排序方法的稳定性，应从本身的原理上去理解，而不应拘泥于死记硬背。

**应用**：

1. 若n较小时(n<=50)，则可以采用直接插入排序或简单选择排序。
2. 若文件的初始状态已按关键字基本有序，则选用直接插入或冒泡排序。
3. 若n较大，则应采用时同复杂度为O(nlog2n)的排序方法快速排序、堆排序、归并排序。快速排序被认为是目前基于比较的内部排序法中最好的方法。若要求排序稳定且时间复杂度为O(nlog2n),则可选用归并排序。
4. 若n很大，记录的关键字位数较少且可以分解时，采用基数排序较好。
5. 当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结

### 4.二叉树前序、中序、后序遍历相互求法

例：

前序遍历:         GDAFEMHZ

中序遍历:         ADEFGHMZ

**画树求法：**第一步，根据前序遍历的特点，我们知道根结点为G

第二步，观察中序遍历ADEFGHMZ。其中root节点G左侧的ADEF必然是root的左子树，G右侧的HMZ必然是root的右子树。

 第三步，观察左子树ADEF，左子树的中的根节点必然是大树的root的leftchild。在前序遍历中，大树的root的leftchild位于root之后，所以左子树的根节点为D。

第四步，同样的道理，root的右子树节点HMZ中的根节点也可以通过前序遍历求得。在前序遍历中，一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。

第五步，观察发现，上面的过程是递归的。先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了。该步递归的过程可以简洁表达如下：

1 确定根,确定左子树，确定右子树。

2 在左子树中递归。

3 在右子树中递归。

4 打印当前根。

那么，我们可以画出这个二叉树的形状：

![img](http://www.cr173.com/up/2013-1/2013010715404717978.jpg)

那么，根据后序的遍历规则，我们可以知道，后序遍历顺序为：AEFDHZMG.